[{"title":"Apply函数的实现","url":"/2022/09/07/Apply%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"Function.prototype.apply = function (thisArg, args) &#123;  const fn = this;  thisArg = thisArg != null ? Object(thisArg) : globalThis;  if (!(args instanceof Array)) &#123;    throw new Error(&quot;args is no array&quot;);  &#125;  args = args || [];  thisArg.fn = fn;  const result = thisArg.fn(...args);  delete thisArg.fn;  return result;&#125;;\n\n","categories":["javascript","原理"]},{"title":"Electron学习","url":"/2022/09/10/Electron%E5%AD%A6%E4%B9%A0/","content":"","categories":["Electron","note"]},{"title":"Enzyme react 单元测试","url":"/2022/09/25/Enzyme-react-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","content":"enyzme不再支持react18，如果需要使用请使用官方的测试工具React Testing Libraryenzyme &#x2F; ˈenzaɪm &#x2F;\nEnzyme是一种react的javascript的单元测试工具，可以轻松的测试react组件的输出，Enyzme的API主要是模仿jq的api来进行DOM的遍历和操作\n安装方式\nnpm i --save-dev enzyme enzyme-adapter-react-17\n\nenzyme的配置方式\nimport Enzyme from &#x27;enzyme&#x27;;import Adapter from &#x27;enzyme-adapter-react-17&#x27;;Enzyme.configure(&#123; adapter: new Adapter() &#125;);\n\nEnzyme的三种渲染组件的方式\nShallow Rendering是对官方的Shallow Renderer的封装，将组件渲染成虚拟DOM对象，只会渲染第一层，子组件将不会渲染出来，因此效率非常高，不需要DOM环境，并且可以以JQ的方式访问组件\nimport &#123; shallow &#125; from &#x27;enzyme&#x27;;const wrapper = shallow(&lt;MyComponent /&gt;);// ...\n\n常见的api.at(index) =&gt; ShallowWrapper通过索引获取对应的wrapper\nconst wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.find(Foo).at(0).props().foo).to.equal(&#x27;bar&#x27;);\n\n和get方法相似，但是返回值是reactElement不是wrapper\nfirst方法相当于at(0),last方法相当于返回最后一个\n.childAt(index) =&gt; ShallowWrapper通过索引找到第几个子元素，返回wrapper\nconst wrapper = shallow(&lt;ToDoList items=&#123;items&#125; /&gt;);expect(wrapper.find(&#x27;ul&#x27;).childAt(0).type()).to.equal(&#x27;li&#x27;);\n\n.children([selector]) =&gt; ShallowWrapper找到所有子元素，可以传入可选参数，返回wrapper\nconst wrapper = shallow(&lt;ToDoList items=&#123;items&#125; /&gt;);expect(wrapper.find(&#x27;ul&#x27;).children()).to.have.lengthOf(items.length);\n\n.closest(selector) =&gt; ShallowWrapper返回匹配到的选择器的第一个选择器的wrapper\nconst wrapper = shallow(&lt;MyComponent /&gt;);expect(wrapper.find(Foo).closest(&#x27;.bar&#x27;)).to.have.lengthOf(1);\n\nFull DOM Rendering完全渲染，它将组件渲染加载成一个真实的DOM节点，用来测试DOM API的交互和组件的生命周期，用到了jsdom来模拟浏览器环境\nimport &#123; mount &#125; from &#x27;enzyme&#x27;;const wrapper = mount(&lt;MyComponent /&gt;);\n\nStatic Rendered Markup静态渲染，它将React组件渲染成静态的HTML字符串，然后使用Cheerio这个库解析这段字符串，并返回一个Cheerio的实例对象，可以用来分析组件的html结构\nimport &#123; render &#125; from &#x27;enzyme&#x27;;const wrapper = render(&lt;MyComponent /&gt;);// ...\n","categories":["单元测试","Enzyme"]},{"title":"Promise的实现","url":"/2022/09/05/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"结构设计// 定义promise的三种状态const PROMISE_STATUS_PENDING = &quot;pending&quot;;const PROMISE_STATUS_FULFILLED = &quot;fulfilled&quot;;const PROMISE_STATUS_REJECTED = &quot;rejected&quot;;class myPromise &#123;  constructor(executor) &#123;    // 状态初始化    this.status = PROMISE_STATUS_PENDING;    // 定义resolve，reject的参数    this.value = undefined;    this.reason = undefined;    const resolve = (value) =&gt; &#123;      // 只有状态是padding的时候才可以进行改变，否则将不会有输出      if (this.status === PROMISE_STATUS_PENDING) &#123;        this.status = PROMISE_STATUS_FULFILLED;        this.value = value;        console.log(&quot;resolve被调用&quot;);      &#125;    &#125;;    const reject = (reason) =&gt; &#123;      if (this.status === PROMISE_STATUS_PENDING) &#123;        this.status = PROMISE_STATUS_REJECTED;        this.reason = reason;        console.log(&quot;reject被调用&quot;);      &#125;    &#125;;    try &#123;      executor(resolve, reject);    &#125; catch (error) &#123;      reject(error);    &#125;  &#125;&#125;const promise = new myPromise((resolve, reject) =&gt; &#123;  console.log(&quot;padding&quot;);  resolve(111);  reject(222);&#125;);\n\n\n\nthen方法的结构设计// 定义promise的三种状态const PROMISE_STATUS_PENDING = &quot;pending&quot;;const PROMISE_STATUS_FULFILLED = &quot;fulfilled&quot;;const PROMISE_STATUS_REJECTED = &quot;rejected&quot;;class myPromise &#123;  constructor(executor) &#123;    // 状态初始化    this.status = PROMISE_STATUS_PENDING;    // 定义resolve，reject的参数    this.value = undefined;    this.reason = undefined;    const resolve = (value) =&gt; &#123;      // 只有状态是padding的时候才可以进行改变，否则将不会有输出      if (this.status === PROMISE_STATUS_PENDING) &#123;        this.status = PROMISE_STATUS_FULFILLED;        // 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行        queueMicrotask(() =&gt; &#123;          console.log(&quot;resolve&quot;);          this.value = value;          this.onFulfilled(this.value);        &#125;);      &#125;    &#125;;    const reject = (reason) =&gt; &#123;      if (this.status === PROMISE_STATUS_PENDING) &#123;        this.status = PROMISE_STATUS_REJECTED;        queueMicrotask(() =&gt; &#123;          console.log(&quot;reject&quot;);          this.reason = reason;          this.onRejected(this.reason);        &#125;);      &#125;    &#125;;    try &#123;      executor(resolve, reject);    &#125; catch (error) &#123;      reject(error);    &#125;  &#125;  // then方法的实现  then(onFulfilled, onRejected) &#123;    this.onFulfilled = onFulfilled;    this.onRejected = onRejected;  &#125;&#125;const promise = new myPromise((resolve, reject) =&gt; &#123;  console.log(&quot;padding&quot;);  resolve(111);  reject(222);&#125;);// 此时不可以进行链式调用，否则会报错promise.then(  (res) =&gt; &#123;    console.log(&quot;res1:&quot;, res);    return 1111;  &#125;,  (err) =&gt; &#123;    console.log(&quot;err:&quot;, err);  &#125;);\n\n\n\nthen方法的结构设计-优化解决then在状态确定之后调用的问题// 定义promise的三种状态const PROMISE_STATUS_PENDING = &quot;pending&quot;;const PROMISE_STATUS_FULFILLED = &quot;fulfilled&quot;;const PROMISE_STATUS_REJECTED = &quot;rejected&quot;;class myPromise &#123;  constructor(executor) &#123;    // 状态初始化    this.status = PROMISE_STATUS_PENDING;    // 定义resolve，reject的参数    this.value = undefined;    this.reason = undefined;    this.onFulfilledFns = [];    this.onRejectedFns = [];    const resolve = (value) =&gt; &#123;      // 只有状态是padding的时候才可以进行改变，否则将不会有输出      if (this.status === PROMISE_STATUS_PENDING) &#123;        // 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_FULFILLED;          console.log(&quot;resolve&quot;);          this.value = value;          this.onFulfilledFns.forEach((fn) =&gt; &#123;            fn(this.value);          &#125;);        &#125;);      &#125;    &#125;;    const reject = (reason) =&gt; &#123;      if (this.status === PROMISE_STATUS_PENDING) &#123;        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_REJECTED;          console.log(&quot;reject&quot;);          this.reason = reason;          this.onRejectedFns.forEach((fn) =&gt; &#123;            fn(this.reason);          &#125;);        &#125;);      &#125;    &#125;;    try &#123;      executor(resolve, reject);    &#125; catch (error) &#123;      reject(error);    &#125;  &#125;  // then方法的实现  then(onFulfilled, onRejected) &#123;    //当调用then的时候，状态已经确定    if (this.status === PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled) &#123;      onFulfilled(this.value);    &#125;    if (this.status === PROMISE_STATUS_REJECTED &amp;&amp; onRejected) &#123;      onRejected(this.reason);    &#125;    // 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组    if (this.status === PROMISE_STATUS_PENDING) &#123;      this.onFulfilledFns.push(onFulfilled);      this.onRejectedFns.push(onRejected);    &#125;  &#125;&#125;const promise = new myPromise((resolve, reject) =&gt; &#123;  console.log(&quot;padding&quot;);  resolve(111);  reject(222);&#125;);// 调用then方法多次调用promise.then(  (res) =&gt; &#123;    console.log(&quot;res1:&quot;, res);  &#125;,  (err) =&gt; &#123;    console.log(&quot;err:&quot;, err);  &#125;);promise.then(  (res) =&gt; &#123;    console.log(&quot;res2:&quot;, res);  &#125;,  (err) =&gt; &#123;    console.log(&quot;err2:&quot;, err);  &#125;);// const promise = new Promise((resolve, reject) =&gt; &#123;//   resolve(&quot;aaaaa&quot;)// &#125;)// 在确定Promise状态之后, 再次调用thensetTimeout(() =&gt; &#123;  promise.then(    (res) =&gt; &#123;      console.log(&quot;res3:&quot;, res);    &#125;,    (err) =&gt; &#123;      console.log(&quot;err3:&quot;, err);    &#125;  );&#125;, 1000);\n\nthen方法的结构设计-优化二解决then方法链式调用// 定义promise的三种状态const PROMISE_STATUS_PENDING = &quot;pending&quot;;const PROMISE_STATUS_FULFILLED = &quot;fulfilled&quot;;const PROMISE_STATUS_REJECTED = &quot;rejected&quot;;// 工具函数function execFunctionWithCatchError(execFn, value, resolve, reject) &#123;  try &#123;    const result = execFn(value);    resolve(result);  &#125; catch (error) &#123;    reject(error);  &#125;&#125;class myPromise &#123;  constructor(executor) &#123;    // 状态初始化    this.status = PROMISE_STATUS_PENDING;    // 定义resolve，reject的参数    this.value = undefined;    this.reason = undefined;    this.onFulfilledFns = [];    this.onRejectedFns = [];    const resolve = (value) =&gt; &#123;      // 只有状态是padding的时候才可以进行改变，否则将不会有输出      if (this.status === PROMISE_STATUS_PENDING) &#123;        // 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_FULFILLED;          console.log(&quot;resolve&quot;);          this.value = value;          this.onFulfilledFns.forEach((fn) =&gt; &#123;            fn(this.value);          &#125;);        &#125;);      &#125;    &#125;;    const reject = (reason) =&gt; &#123;      if (this.status === PROMISE_STATUS_PENDING) &#123;        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_REJECTED;          console.log(&quot;reject&quot;);          this.reason = reason;          this.onRejectedFns.forEach((fn) =&gt; &#123;            fn(this.reason);          &#125;);        &#125;);      &#125;    &#125;;    try &#123;      executor(resolve, reject);    &#125; catch (error) &#123;      reject(error);    &#125;  &#125;  // then方法的实现  then(onFulfilled, onRejected) &#123;    // 返回一个promise,就可以进行链式调用了    return new myPromise((resolve, reject) =&gt; &#123;      //当调用then的时候，状态已经确定      if (this.status === PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled) &#123;        // try &#123;        //   const value = onFulfilled(this.value);        //   resolve(value);        // &#125; catch (error) &#123;        //   reject(error);        // &#125;        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);      &#125;      if (this.status === PROMISE_STATUS_REJECTED &amp;&amp; onRejected) &#123;        // try &#123;        //   const reason = onRejected(this.reason);        //   resolve(reason);        // &#125; catch (error) &#123;        //   reject(error);        // &#125;        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);      &#125;      // 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组      if (this.status === PROMISE_STATUS_PENDING) &#123;        this.onFulfilledFns.push(() =&gt; &#123;          // try &#123;          //   const value = onFulfilled(this.value);          //   resolve(value);          // &#125; catch (error) &#123;          //   reject(error);          // &#125;          execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);        &#125;);        this.onRejectedFns.push(() =&gt; &#123;          // try &#123;          //   const reason = onRejected(this.reason);          //   resolve(reason);          // &#125; catch (error) &#123;          //   reject(error);          // &#125;          execFunctionWithCatchError(onRejected, this.reason, resolve, reject);        &#125;);      &#125;    &#125;);  &#125;&#125;const promise = new myPromise((resolve, reject) =&gt; &#123;  console.log(&quot;padding&quot;);  resolve(111);  reject(222);&#125;);// 调用then方法多次调用promise  .then(    (res) =&gt; &#123;      console.log(&quot;res1:&quot;, res);      return &quot;aaaa&quot;;      // throw new Error(&quot;err message&quot;)    &#125;,    (err) =&gt; &#123;      console.log(&quot;err1:&quot;, err);      return &quot;bbbbb&quot;;      // throw new Error(&quot;err message&quot;)    &#125;  )  .then(    (res) =&gt; &#123;      console.log(&quot;res2:&quot;, res);    &#125;,    (err) =&gt; &#123;      console.log(&quot;err2:&quot;, err);    &#125;  );\n\ncatch的设计方法// 定义promise的三种状态const PROMISE_STATUS_PENDING = &quot;pending&quot;;const PROMISE_STATUS_FULFILLED = &quot;fulfilled&quot;;const PROMISE_STATUS_REJECTED = &quot;rejected&quot;;// 工具函数function execFunctionWithCatchError(execFn, value, resolve, reject) &#123;  try &#123;    const result = execFn(value);    resolve(result);  &#125; catch (error) &#123;    reject(error);  &#125;&#125;class myPromise &#123;  constructor(executor) &#123;    // 状态初始化    this.status = PROMISE_STATUS_PENDING;    // 定义resolve，reject的参数    this.value = undefined;    this.reason = undefined;    this.onFulfilledFns = [];    this.onRejectedFns = [];    const resolve = (value) =&gt; &#123;      // 只有状态是padding的时候才可以进行改变，否则将不会有输出      if (this.status === PROMISE_STATUS_PENDING) &#123;        // 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_FULFILLED;          this.value = value;          this.onFulfilledFns.forEach((fn) =&gt; &#123;            fn(this.value);          &#125;);        &#125;);      &#125;    &#125;;    const reject = (reason) =&gt; &#123;      if (this.status === PROMISE_STATUS_PENDING) &#123;        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_REJECTED;          this.reason = reason;          this.onRejectedFns.forEach((fn) =&gt; &#123;            fn(this.reason);          &#125;);        &#125;);      &#125;    &#125;;    try &#123;      executor(resolve, reject);    &#125; catch (error) &#123;      reject(error);    &#125;  &#125;  // then方法的实现  then(onFulfilled, onRejected) &#123;    // 将error传递下去交给catch处理    const defaultOnRejected = (err) =&gt; &#123;      throw err;    &#125;;    onRejected = onRejected || defaultOnRejected;    // 返回一个promise,就可以进行链式调用了    return new myPromise((resolve, reject) =&gt; &#123;      //当调用then的时候，状态已经确定      if (this.status === PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled) &#123;        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);      &#125;      if (this.status === PROMISE_STATUS_REJECTED &amp;&amp; onRejected) &#123;        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);      &#125;      // 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组      if (this.status === PROMISE_STATUS_PENDING) &#123;        if (onFulfilled) &#123;          this.onFulfilledFns.push(() =&gt; &#123;            execFunctionWithCatchError(              onFulfilled,              this.value,              resolve,              reject            );          &#125;);        &#125;        if (onRejected) &#123;          this.onRejectedFns.push(() =&gt; &#123;            execFunctionWithCatchError(              onRejected,              this.reason,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  catch(onRejected) &#123;    this.then(undefined, onRejected);  &#125;&#125;const promise = new myPromise((resolve, reject) =&gt; &#123;  console.log(&quot;状态pending&quot;);  // resolve(1111) // resolved/fulfilled  reject(2222);&#125;);// 调用then方法多次调用promise  .then((res) =&gt; &#123;    console.log(&quot;res:&quot;, res);  &#125;)  .catch((err) =&gt; &#123;    console.log(&quot;err:&quot;, err);  &#125;);\n\nfinally方法的设计// 定义promise的三种状态const PROMISE_STATUS_PENDING = &quot;pending&quot;;const PROMISE_STATUS_FULFILLED = &quot;fulfilled&quot;;const PROMISE_STATUS_REJECTED = &quot;rejected&quot;;// 工具函数function execFunctionWithCatchError(execFn, value, resolve, reject) &#123;  try &#123;    const result = execFn(value);    resolve(result);  &#125; catch (error) &#123;    reject(error);  &#125;&#125;class myPromise &#123;  constructor(executor) &#123;    // 状态初始化    this.status = PROMISE_STATUS_PENDING;    // 定义resolve，reject的参数    this.value = undefined;    this.reason = undefined;    this.onFulfilledFns = [];    this.onRejectedFns = [];    const resolve = (value) =&gt; &#123;      // 只有状态是padding的时候才可以进行改变，否则将不会有输出      if (this.status === PROMISE_STATUS_PENDING) &#123;        // 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_FULFILLED;          this.value = value;          this.onFulfilledFns.forEach((fn) =&gt; &#123;            fn(this.value);          &#125;);        &#125;);      &#125;    &#125;;    const reject = (reason) =&gt; &#123;      if (this.status === PROMISE_STATUS_PENDING) &#123;        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_REJECTED;          this.reason = reason;          this.onRejectedFns.forEach((fn) =&gt; &#123;            fn(this.reason);          &#125;);        &#125;);      &#125;    &#125;;    try &#123;      executor(resolve, reject);    &#125; catch (error) &#123;      reject(error);    &#125;  &#125;  // then方法的实现  then(onFulfilled, onRejected) &#123;    // 将error传递下去交给catch处理    const defaultOnRejected = (err) =&gt; &#123;      throw err;    &#125;;    const defaultOnFulfilled = (value) =&gt; &#123;      return value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    // 返回一个promise,就可以进行链式调用了    return new myPromise((resolve, reject) =&gt; &#123;      //当调用then的时候，状态已经确定      if (this.status === PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled) &#123;        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);      &#125;      if (this.status === PROMISE_STATUS_REJECTED &amp;&amp; onRejected) &#123;        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);      &#125;      // 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组      if (this.status === PROMISE_STATUS_PENDING) &#123;        if (onFulfilled) &#123;          this.onFulfilledFns.push(() =&gt; &#123;            execFunctionWithCatchError(              onFulfilled,              this.value,              resolve,              reject            );          &#125;);        &#125;        if (onRejected) &#123;          this.onRejectedFns.push(() =&gt; &#123;            execFunctionWithCatchError(              onRejected,              this.reason,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  catch(onRejected) &#123;    return this.then(undefined, onRejected);  &#125;  finally(onfinally) &#123;    this.then(      () =&gt; &#123;        onfinally();      &#125;,      () =&gt; &#123;        onfinally();      &#125;    );  &#125;&#125;const promise = new myPromise((resolve, reject) =&gt; &#123;  console.log(&quot;状态pending&quot;);  resolve(1111); // resolved/fulfilled  // reject(2222);&#125;);// 调用then方法多次调用promise  .then((res) =&gt; &#123;    console.log(&quot;res1:&quot;, res);    return &quot;aaaaa&quot;;  &#125;)  .then((res) =&gt; &#123;    console.log(&quot;res2:&quot;, res);  &#125;)  .catch((err) =&gt; &#123;    console.log(&quot;err:&quot;, err);  &#125;)  .finally(() =&gt; &#123;    console.log(&quot;finally&quot;);  &#125;);\n\npromise的类方法resolve&#x2F;reject// 定义promise的三种状态const PROMISE_STATUS_PENDING = &quot;pending&quot;;const PROMISE_STATUS_FULFILLED = &quot;fulfilled&quot;;const PROMISE_STATUS_REJECTED = &quot;rejected&quot;;// 工具函数function execFunctionWithCatchError(execFn, value, resolve, reject) &#123;  try &#123;    const result = execFn(value);    resolve(result);  &#125; catch (error) &#123;    reject(error);  &#125;&#125;class myPromise &#123;  constructor(executor) &#123;    // 状态初始化    this.status = PROMISE_STATUS_PENDING;    // 定义resolve，reject的参数    this.value = undefined;    this.reason = undefined;    this.onFulfilledFns = [];    this.onRejectedFns = [];    const resolve = (value) =&gt; &#123;      // 只有状态是padding的时候才可以进行改变，否则将不会有输出      if (this.status === PROMISE_STATUS_PENDING) &#123;        // 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_FULFILLED;          this.value = value;          this.onFulfilledFns.forEach((fn) =&gt; &#123;            fn(this.value);          &#125;);        &#125;);      &#125;    &#125;;    const reject = (reason) =&gt; &#123;      if (this.status === PROMISE_STATUS_PENDING) &#123;        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_REJECTED;          this.reason = reason;          this.onRejectedFns.forEach((fn) =&gt; &#123;            fn(this.reason);          &#125;);        &#125;);      &#125;    &#125;;    try &#123;      executor(resolve, reject);    &#125; catch (error) &#123;      reject(error);    &#125;  &#125;  // then方法的实现  then(onFulfilled, onRejected) &#123;    // 将error传递下去交给catch处理    const defaultOnRejected = (err) =&gt; &#123;      throw err;    &#125;;    const defaultOnFulfilled = (value) =&gt; &#123;      return value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    // 返回一个promise,就可以进行链式调用了    return new myPromise((resolve, reject) =&gt; &#123;      //当调用then的时候，状态已经确定      if (this.status === PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled) &#123;        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);      &#125;      if (this.status === PROMISE_STATUS_REJECTED &amp;&amp; onRejected) &#123;        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);      &#125;      // 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组      if (this.status === PROMISE_STATUS_PENDING) &#123;        if (onFulfilled) &#123;          this.onFulfilledFns.push(() =&gt; &#123;            execFunctionWithCatchError(              onFulfilled,              this.value,              resolve,              reject            );          &#125;);        &#125;        if (onRejected) &#123;          this.onRejectedFns.push(() =&gt; &#123;            execFunctionWithCatchError(              onRejected,              this.reason,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  catch(onRejected) &#123;    return this.then(undefined, onRejected);  &#125;  finally(onfinally) &#123;    this.then(      () =&gt; &#123;        onfinally();      &#125;,      () =&gt; &#123;        onfinally();      &#125;    );  &#125;  // 就是将value转成fulfilled状态可以进行then调用  static resolve(value) &#123;    return new myPromise((resolve) =&gt; &#123;      return resolve(value);    &#125;);  &#125;  // 将reason装成rejected状态  static reject(reason) &#123;    return new myPromise((resolve, reject) =&gt; &#123;      return reject(reason);    &#125;);  &#125;&#125;myPromise.resolve(&quot;Hello World&quot;).then((res) =&gt; &#123;  console.log(&quot;res:&quot;, res);&#125;);myPromise.reject(&quot;Error Message&quot;).catch((err) =&gt; &#123;  console.log(&quot;err:&quot;, err);&#125;);\n\npromise的类方法all&#x2F;allSettled// 定义promise的三种状态const PROMISE_STATUS_PENDING = &quot;pending&quot;;const PROMISE_STATUS_FULFILLED = &quot;fulfilled&quot;;const PROMISE_STATUS_REJECTED = &quot;rejected&quot;;// 工具函数function execFunctionWithCatchError(execFn, value, resolve, reject) &#123;  try &#123;    const result = execFn(value);    resolve(result);  &#125; catch (error) &#123;    reject(error);  &#125;&#125;class myPromise &#123;  constructor(executor) &#123;    // 状态初始化    this.status = PROMISE_STATUS_PENDING;    // 定义resolve，reject的参数    this.value = undefined;    this.reason = undefined;    this.onFulfilledFns = [];    this.onRejectedFns = [];    const resolve = (value) =&gt; &#123;      // 只有状态是padding的时候才可以进行改变，否则将不会有输出      if (this.status === PROMISE_STATUS_PENDING) &#123;        // 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_FULFILLED;          this.value = value;          this.onFulfilledFns.forEach((fn) =&gt; &#123;            fn(this.value);          &#125;);        &#125;);      &#125;    &#125;;    const reject = (reason) =&gt; &#123;      if (this.status === PROMISE_STATUS_PENDING) &#123;        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_REJECTED;          this.reason = reason;          this.onRejectedFns.forEach((fn) =&gt; &#123;            fn(this.reason);          &#125;);        &#125;);      &#125;    &#125;;    try &#123;      executor(resolve, reject);    &#125; catch (error) &#123;      reject(error);    &#125;  &#125;  // then方法的实现  then(onFulfilled, onRejected) &#123;    // 将error传递下去交给catch处理    const defaultOnRejected = (err) =&gt; &#123;      throw err;    &#125;;    const defaultOnFulfilled = (value) =&gt; &#123;      return value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    // 返回一个promise,就可以进行链式调用了    return new myPromise((resolve, reject) =&gt; &#123;      //当调用then的时候，状态已经确定      if (this.status === PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled) &#123;        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);      &#125;      if (this.status === PROMISE_STATUS_REJECTED &amp;&amp; onRejected) &#123;        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);      &#125;      // 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组      if (this.status === PROMISE_STATUS_PENDING) &#123;        if (onFulfilled) &#123;          this.onFulfilledFns.push(() =&gt; &#123;            execFunctionWithCatchError(              onFulfilled,              this.value,              resolve,              reject            );          &#125;);        &#125;        if (onRejected) &#123;          this.onRejectedFns.push(() =&gt; &#123;            execFunctionWithCatchError(              onRejected,              this.reason,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  catch(onRejected) &#123;    return this.then(undefined, onRejected);  &#125;  finally(onfinally) &#123;    this.then(      () =&gt; &#123;        onfinally();      &#125;,      () =&gt; &#123;        onfinally();      &#125;    );  &#125;  // 就是将value转成fulfilled状态可以进行then调用  static resolve(value) &#123;    return new myPromise((resolve) =&gt; &#123;      return resolve(value);    &#125;);  &#125;  // 将reason装成rejected状态  static reject(reason) &#123;    return new myPromise((resolve, reject) =&gt; &#123;      return reject(reason);    &#125;);  &#125;  // all传入一个promise数组，如果promise item状态都是fulfulled，all才是fuldilled状态，否则只要出现了reject就会变成renject  static all(promises) &#123;    return new myPromise((resolve, reject) =&gt; &#123;      const values = [];      promises.forEach((promise) =&gt; &#123;        promise.then(          (res) =&gt; &#123;            values.push(res);            if (values.length === promises.length) &#123;              resolve(values);            &#125;          &#125;,          (err) =&gt; &#123;            reject(err);          &#125;        );      &#125;);    &#125;);  &#125;  static allSettled(promises) &#123;    return new myPromise((resolve, reject) =&gt; &#123;      const values = [];      promises.forEach((promise) =&gt; &#123;        promise.then(          (res) =&gt; &#123;            values.push(&#123;              status: PROMISE_STATUS_FULFILLED,              value: res,            &#125;);            if (values.length === promises.length) &#123;              resolve(values);            &#125;          &#125;,          (err) =&gt; &#123;            values.push(&#123; status: PROMISE_STATUS_REJECTED, value: err &#125;);            if (values.length === promises.length) &#123;              resolve(values);            &#125;          &#125;        );      &#125;);    &#125;);  &#125;&#125;const p1 = new myPromise((resolve) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(1111);  &#125;, 1000);&#125;);const p2 = new myPromise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(2222);  &#125;, 2000);&#125;);const p3 = new myPromise((resolve) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(3333);  &#125;, 3000);&#125;);myPromise  .all([p1, p2, p3])  .then((res) =&gt; &#123;    console.log(res);  &#125;)  .catch((err) =&gt; &#123;    console.log(err);  &#125;);myPromise.allSettled([p1, p2, p3]).then((res) =&gt; &#123;  console.log(res);&#125;);\n\npromise类方法-any&#x2F;race// 定义promise的三种状态const PROMISE_STATUS_PENDING = &quot;pending&quot;;const PROMISE_STATUS_FULFILLED = &quot;fulfilled&quot;;const PROMISE_STATUS_REJECTED = &quot;rejected&quot;;// 工具函数function execFunctionWithCatchError(execFn, value, resolve, reject) &#123;  try &#123;    const result = execFn(value);    resolve(result);  &#125; catch (error) &#123;    reject(error);  &#125;&#125;class myPromise &#123;  constructor(executor) &#123;    // 状态初始化    this.status = PROMISE_STATUS_PENDING;    // 定义resolve，reject的参数    this.value = undefined;    this.reason = undefined;    this.onFulfilledFns = [];    this.onRejectedFns = [];    const resolve = (value) =&gt; &#123;      // 只有状态是padding的时候才可以进行改变，否则将不会有输出      if (this.status === PROMISE_STATUS_PENDING) &#123;        // 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_FULFILLED;          this.value = value;          this.onFulfilledFns.forEach((fn) =&gt; &#123;            fn(this.value);          &#125;);        &#125;);      &#125;    &#125;;    const reject = (reason) =&gt; &#123;      if (this.status === PROMISE_STATUS_PENDING) &#123;        queueMicrotask(() =&gt; &#123;          if (this.status !== PROMISE_STATUS_PENDING) return;          this.status = PROMISE_STATUS_REJECTED;          this.reason = reason;          this.onRejectedFns.forEach((fn) =&gt; &#123;            fn(this.reason);          &#125;);        &#125;);      &#125;    &#125;;    try &#123;      executor(resolve, reject);    &#125; catch (error) &#123;      reject(error);    &#125;  &#125;  // then方法的实现  then(onFulfilled, onRejected) &#123;    // 将error传递下去交给catch处理    const defaultOnRejected = (err) =&gt; &#123;      throw err;    &#125;;    const defaultOnFulfilled = (value) =&gt; &#123;      return value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    // 返回一个promise,就可以进行链式调用了    return new myPromise((resolve, reject) =&gt; &#123;      //当调用then的时候，状态已经确定      if (this.status === PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled) &#123;        execFunctionWithCatchError(onFulfilled, this.value, resolve, reject);      &#125;      if (this.status === PROMISE_STATUS_REJECTED &amp;&amp; onRejected) &#123;        execFunctionWithCatchError(onRejected, this.reason, resolve, reject);      &#125;      // 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组      if (this.status === PROMISE_STATUS_PENDING) &#123;        if (onFulfilled) &#123;          this.onFulfilledFns.push(() =&gt; &#123;            execFunctionWithCatchError(              onFulfilled,              this.value,              resolve,              reject            );          &#125;);        &#125;        if (onRejected) &#123;          this.onRejectedFns.push(() =&gt; &#123;            execFunctionWithCatchError(              onRejected,              this.reason,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  catch(onRejected) &#123;    return this.then(undefined, onRejected);  &#125;  finally(onfinally) &#123;    this.then(      () =&gt; &#123;        onfinally();      &#125;,      () =&gt; &#123;        onfinally();      &#125;    );  &#125;  // 就是将value转成fulfilled状态可以进行then调用  static resolve(value) &#123;    return new myPromise((resolve) =&gt; &#123;      return resolve(value);    &#125;);  &#125;  // 将reason装成rejected状态  static reject(reason) &#123;    return new myPromise((resolve, reject) =&gt; &#123;      return reject(reason);    &#125;);  &#125;  // all传入一个promise数组，如果promise item状态都是fulfulled，all才是fuldilled状态，否则只要出现了reject就会变成renject  static all(promises) &#123;    return new myPromise((resolve, reject) =&gt; &#123;      const values = [];      promises.forEach((promise) =&gt; &#123;        promise.then(          (res) =&gt; &#123;            values.push(res);            if (values.length === promises.length) &#123;              resolve(values);            &#125;          &#125;,          (err) =&gt; &#123;            reject(err);          &#125;        );      &#125;);    &#125;);  &#125;  static allSettled(promises) &#123;    return new myPromise((resolve, reject) =&gt; &#123;      const values = [];      promises.forEach((promise) =&gt; &#123;        promise.then(          (res) =&gt; &#123;            values.push(&#123;              status: PROMISE_STATUS_FULFILLED,              value: res,            &#125;);            if (values.length === promises.length) &#123;              resolve(values);            &#125;          &#125;,          (err) =&gt; &#123;            values.push(&#123; status: PROMISE_STATUS_REJECTED, value: err &#125;);            if (values.length === promises.length) &#123;              resolve(values);            &#125;          &#125;        );      &#125;);    &#125;);  &#125;  // 相当于是竞赛，谁的状态先改变就用谁的  static race(promsies) &#123;    return new myPromise((resolve, reject) =&gt; &#123;      promsies.forEach((promise) =&gt; &#123;        promise.then(resolve, reject);      &#125;);    &#125;);  &#125;  //有一个状态时fulfilled状态就是执行resolve,等所有都变成rejected状态才会是reject  和all相反  static any(promises) &#123;    return new myPromise((resolve, reject) =&gt; &#123;      const reasons = [];      promises.forEach((promise) =&gt; &#123;        promise.then(          (res) =&gt; &#123;            resolve(res);          &#125;,          (err) =&gt; &#123;            reasons.push(err);            if (reasons.length === promises.length) &#123;              reject(new AggregateError(reasons));            &#125;          &#125;        );      &#125;);    &#125;);  &#125;&#125;const p1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(1111);  &#125;, 3000);&#125;);const p2 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(2222);  &#125;, 2000);&#125;);const p3 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(3333);  &#125;, 3000);&#125;);myPromise  .race([p1, p2, p3])  .then((res) =&gt; &#123;    console.log(&quot;res:&quot;, res);  &#125;)  .catch((err) =&gt; &#123;    console.log(&quot;err:&quot;, err);  &#125;);myPromise  .any([p1, p2, p3])  .then((res) =&gt; &#123;    console.log(&quot;res:&quot;, res);  &#125;)  .catch((err) =&gt; &#123;    console.log(&quot;err:&quot;, err.errors);  &#125;);\n\n","categories":["javascript","搜集"]},{"title":"什么是Puppeteer","url":"/2022/11/08/Puppeteer/","content":"","categories":["Puppeteer"]},{"title":"React18+Typescript的使用","url":"/2022/10/05/React18-Typescript%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"","categories":["react","Typescript"]},{"title":"Redux笔记","url":"/2022/09/08/Redux%E7%AC%94%E8%AE%B0/","content":"##纯函数 确定的输入，一定会产生确定的输出；\n函数在执行过程中，不能产生副作用\nStore一个store文件夹由4个文件组成\nactionCreator.js\n这个文件是用来编写action,action是一个普通的JavaScript对象，用来描述这次更新的type和content\n强制使用action的好处是可以清晰的知道数据到底发生了什么样的变化，所有的数据变化都是可跟追、可预测的；\n当然，目前我们的action是固定的对象\n真实应用中，我们会通过函数来定义，返回一个action\nRedux要求我们通过action来更新数据,通过dispatch action来更新数据\n//actionCreator.jsconst &#123; ADD_NUMBER, CHANGE_NAME &#125; = require(&quot;./constants&quot;)const changeNameAction = (name) =&gt; (&#123;  type: CHANGE_NAME,  name&#125;)const addNumberAction = (num) =&gt; (&#123;  type: ADD_NUMBER,  num&#125;)module.exports = &#123;  changeNameAction,  addNumberAction&#125;\n\nconstants.js 用来定义type常量\nconst ADD_NUMBER = &quot;add_number&quot;const CHANGE_NAME = &quot;change_name&quot;module.exports = &#123;  ADD_NUMBER,  CHANGE_NAME&#125;\n\nreducer.js\nreducer是将state和action联系起来的桥梁，reducer是纯函数，reducer做的事情是将传入的state和action结合起来生成新的state\nconst &#123; ADD_NUMBER, CHANGE_NAME &#125; = require(&quot;./constants&quot;)// 初始化的数据const initialState = &#123;  name: &quot;why&quot;,  counter: 100&#125;function reducer(state = initialState, action) &#123;  switch(action.type) &#123;    case CHANGE_NAME:      return &#123; ...state, name: action.name &#125;    case ADD_NUMBER:      return &#123; ...state, counter: state.counter + action.num &#125;    default:      return state  &#125;&#125;module.exports = reducer\n\nindex.js\n创建store实例\nconst &#123; createStore &#125; = require(&quot;redux&quot;)const reducer =  require(&quot;./reducer.js&quot;)// 创建的storeconst store = createStore(reducer)module.exports = store\n\n使用store中的数据\nconst store = require(&quot;./store&quot;)console.log(store.getState())\n\n修改store中的数据\nstore.dispatch(changeNameAction(&quot;kobe&quot;))\n\n订阅store中的数据\nconst store = require(&quot;./store&quot;)const unsubscribe = store.subscribe(() =&gt; &#123;  console.log(&quot;订阅数据的变化:&quot;, store.getState())&#125;)// 修改store中的数据: 必须actionstore.dispatch(&#123; type: &quot;change_name&quot;, name: &quot;kobe&quot; &#125;)store.dispatch(&#123; type: &quot;change_name&quot;, name: &quot;lilei&quot; &#125;)unsubscribe()\n\nredux 三大核心 store action reducerredux 的三大原则\n单一数据源\n 整个应用程序的state被存储在一颗object tree中，并且这个object tree只存储在一个 store 中\nRedux并没有强制让我们不能创建多个Store，但是那样做并不利于数据的维护\n单一的数据源可以让整个应用程序的state变得方便维护、追踪、修改\n\n\nState是只读的\n​\t唯一修改State的方法一定是触发action，不要试图在其他地方通过任何的方式来修改State\n​    这样就确保了View或网络请求都不能直接修改state，它们只能通过action来描述自己想要如何修改state\n这样可以保证所有的修改都被集中化处理，并且按照严格的顺序来执行，所以不需要担心race condition（竟态）的问题\n\n\n使用纯函数来执行修改\n​\t通过reducer将 旧state和 actions联系在一起，并且返回一个新的State\n​    随着应用程序的复杂度增加，我们可以将reducer拆分成多个小的reducers，分别操作不同state tree的一部分\n但是所有的reducer都应该是纯函数，不能产生任何的副作用\n\n\n\n\n\n\nreact和redux结合使用react-redux的使用\n//index.jsimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;import App from &#x27;./App&#x27;;import &#123; Provider &#125; from &quot;react-redux&quot;import store from &quot;./store&quot;const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render(  // &lt;React.StrictMode&gt;    &lt;Provider store=&#123;store&#125;&gt;      &lt;App /&gt;    &lt;/Provider&gt;  // &lt;/React.StrictMode&gt;);\n\n//在组件中使用import React, &#123; PureComponent &#125; from &#x27;react&#x27;import &#123; connect &#125; from &quot;react-redux&quot;// import store from &quot;../store&quot;import &#123; addNumberAction, subNumberAction &#125; from &#x27;../store/counter&#x27;export class About extends PureComponent &#123;  calcNumber(num, isAdd) &#123;    if (isAdd) &#123;      this.props.addNumber(num)    &#125; else &#123;      this.props.subNumber(num)    &#125;  &#125;  render() &#123;    const &#123; counter, banners, recommends, userInfo &#125; = this.props    return (      &lt;div&gt;        &lt;div className=&#x27;user&#x27;&gt;          &lt;h2&gt;nickname: &#123;userInfo.nickname&#125;&lt;/h2&gt;        &lt;/div&gt;        &lt;h2&gt;About Page: &#123;counter&#125;&lt;/h2&gt;        &lt;div&gt;          &lt;button onClick=&#123;e =&gt; this.calcNumber(6, true)&#125;&gt;+6&lt;/button&gt;          &lt;button onClick=&#123;e =&gt; this.calcNumber(88, true)&#125;&gt;+88&lt;/button&gt;          &lt;button onClick=&#123;e =&gt; this.calcNumber(6, false)&#125;&gt;-6&lt;/button&gt;          &lt;button onClick=&#123;e =&gt; this.calcNumber(88, false)&#125;&gt;-88&lt;/button&gt;        &lt;/div&gt;        &lt;div className=&#x27;banner&#x27;&gt;          &lt;h2&gt;轮播图数据:&lt;/h2&gt;          &lt;ul&gt;            &#123;              banners.map((item, index) =&gt; &#123;                return &lt;li key=&#123;index&#125;&gt;&#123;item.title&#125;&lt;/li&gt;              &#125;)            &#125;          &lt;/ul&gt;        &lt;/div&gt;        &lt;div className=&#x27;recommend&#x27;&gt;          &lt;h2&gt;推荐数据:&lt;/h2&gt;          &lt;ul&gt;            &#123;              recommends.map((item, index) =&gt; &#123;                return &lt;li key=&#123;index&#125;&gt;&#123;item.title&#125;&lt;/li&gt;              &#125;)            &#125;          &lt;/ul&gt;        &lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;const mapStateToProps = (state) =&gt; (&#123;  counter: state.counter.counter,  banners: state.home.banners,  recommends: state.home.recommends,  userInfo: state.user.userInfo&#125;)const mapDispatchToProps = (dispatch) =&gt; (&#123;  addNumber(num) &#123;    dispatch(addNumberAction(num))  &#125;,  subNumber(num) &#123;    dispatch(subNumberAction(num))  &#125;&#125;)export default connect(mapStateToProps, mapDispatchToProps)(About)\n\n没有使用react-redux的写法\nimport React, &#123; PureComponent &#125; from &#x27;react&#x27;import store from &quot;../store&quot;import &#123; addNumberAction &#125; from &#x27;../store/counter&#x27;export class Home extends PureComponent &#123;  constructor() &#123;    super()    this.state = &#123;      counter: store.getState().counter.counter,      message: &quot;Hello World&quot;,      friends: [        &#123;id: 111, name: &quot;why&quot;&#125;,        &#123;id: 112, name: &quot;kobe&quot;&#125;,        &#123;id: 113, name: &quot;james&quot;&#125;,      ]    &#125;  &#125;  componentDidMount() &#123;    store.subscribe(() =&gt; &#123;      const state = store.getState().counter      this.setState(&#123; counter: state.counter &#125;)    &#125;)  &#125;  addNumber(num) &#123;    store.dispatch(addNumberAction(num))  &#125;  render() &#123;    const &#123; counter &#125; = this.state    return (      &lt;div&gt;        &lt;h2&gt;Home Counter: &#123;counter&#125;&lt;/h2&gt;        &lt;div&gt;          &lt;button onClick=&#123;e =&gt; this.addNumber(1)&#125;&gt;+1&lt;/button&gt;          &lt;button onClick=&#123;e =&gt; this.addNumber(5)&#125;&gt;+5&lt;/button&gt;          &lt;button onClick=&#123;e =&gt; this.addNumber(8)&#125;&gt;+8&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;export default Home\n\n我们可以将react组件中的异步操作放到redux中，使用中间件，中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码使用redux-thunk来发布异步请求\nimport &#123; createStore, applyMiddleware, compose &#125; from &quot;redux&quot;import thunk from &quot;redux-thunk&quot;import reducer from &quot;./reducer&quot;// 正常情况下 store.dispatch(object)// 想要派发函数 store.dispatch(function)// redux-devtoolsconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;trace: true&#125;) || compose;const store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)))export default store\n\n定义一个返回函数的action\nexport const fetchHomeMultidataAction = () =&gt; &#123;  // 如果是一个普通的action, 那么我们这里需要返回action对象  // 问题: 对象中是不能直接拿到从服务器请求的异步数据的  // return &#123;&#125;  return function(dispatch, getState) &#123;    // 异步操作: 网络请求    // console.log(&quot;foo function execution-----&quot;, getState().counter)    axios.get(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;      const banners = res.data.data.banner.list      const recommends = res.data.data.recommend.list      // dispatch(&#123; type: actionTypes.CHANGE_BANNERS, banners &#125;)      // dispatch(&#123; type: actionTypes.CHANGE_RECOMMENDS, recommends &#125;)      dispatch(changeBannersAction(banners))      dispatch(changeRecommendsAction(recommends))    &#125;)  &#125;  // 如果返回的是一个函数, 那么redux是不支持的  // return foo&#125;\n\n定义applyMiddleware中间件function applyMiddleware(store, ...fns) &#123;  fns.forEach(fn =&gt; &#123;    fn(store)  &#125;)&#125;export default applyMiddleware\n\n定义log中间件function log(store) &#123;  const next = store.dispatch  function logAndDispatch(action) &#123;    console.log(&quot;当前派发的action:&quot;, action)    // 真正派发的代码: 使用之前的dispatch进行派发    next(action)    console.log(&quot;派发之后的结果:&quot;, store.getState())  &#125;  // monkey patch: 猴补丁 =&gt; 篡改现有的代码, 对整体的执行逻辑进行修改  store.dispatch = logAndDispatch&#125;export default log\n\n定义thunk中间件function thunk(store) &#123;  const next = store.dispatch  function dispatchThunk(action) &#123;    if (typeof action === &quot;function&quot;) &#123;      action(store.dispatch, store.getState)    &#125; else &#123;      next(action)    &#125;  &#125;  store.dispatch = dispatchThunk&#125;export default thunk\n\nimport &#123; createStore, compose, combineReducers &#125; from &quot;redux&quot;import &#123; log, thunk, applyMiddleware &#125; from &quot;./middleware&quot;// import thunk from &quot;redux-thunk&quot;import counterReducer from &quot;./counter&quot;import homeReducer from &quot;./home&quot;import userReducer from &quot;./user&quot;// 正常情况下 store.dispatch(object)// 想要派发函数 store.dispatch(function)// 将两个reducer合并在一起const reducer = combineReducers(&#123;  counter: counterReducer,  home: homeReducer,  user: userReducer&#125;)// combineReducers实现原理(了解)// function reducer(state = &#123;&#125;, action) &#123;//   // 返回一个对象, store的state//   return &#123;//     counter: counterReducer(state.counter, action),//     home: homeReducer(state.home, action),//     user: userReducer(state.user, action)//   &#125;// &#125;// redux-devtoolsconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;trace: true&#125;) || compose;const store = createStore(reducer)applyMiddleware(store, log, thunk)export default store\n\ncombineReducersredux给我们提供了一个combineReducers函数可以方便的让我们对多个reducer进行合并\n事实上，它也是将我们传入的reducers合并到一个对象中，最终返回一个combination的函数（相当于我们之前的reducer函 数了）； \n 在执行combination函数的过程中，它会通过判断前后返回的数据是否相同来决定返回之前的state还是新的state；\n 新的state会触发订阅者发生对应的刷新，而旧的state可以有效的组织订阅者发生刷新\nRedux Toolkit的用法npm install @reduxjs/toolkit react-redux\n\nRedux Toolkit 是官方推荐的编写 Redux 逻辑的方法。\nredux toolkit API \n\nconfigureStore:包装createStore以提供简化的配置选项和良好的默认值。它可以自动组合你的 slice reducer，添加你提供 的任何 Redux 中间件，redux-thunk默认包含，并启用 Redux DevTools Extension\ncreateSlice:接受reducer函数的对象、切片名称和初始状态值，并自动生成切片reducer，并带有相应的actions\ncreateAsyncThunk:接受一个动作类型字符串和一个返回promise的函数，并生成一个pending&#x2F;fulfilled&#x2F;rejected基于该promise分派动作类型的 thunk\n\n//store.index.jsimport &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;import counterReducer from &quot;./features/counter&quot;import homeReducer from &quot;./features/home&quot;const store = configureStore(&#123;  reducer: &#123;    counter: counterReducer,    home: homeReducer  &#125;&#125;)export default store\n\n///features/counter.jsimport &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;const counterSlice = createSlice(&#123;  name: &quot;counter&quot;,//用户标记slice的名词,在之后的redux-devtool中会显示对应的名词；  //初始化值  initialState: &#123;    counter: 888  &#125;,  //相当于之前的reducer函数  reducers: &#123;    addNumber(state, &#123; payload &#125;) &#123;      state.counter = state.counter + payload    &#125;,    subNumber(state, &#123; payload &#125;) &#123;      state.counter = state.counter - payload    &#125;  &#125;&#125;)export const &#123; addNumber, subNumber &#125; = counterSlice.actionsexport default counterSlice.reducer\n\n&#x2F;&#x2F;在组件中使用\nimport React, &#123; PureComponent &#125; from &#x27;react&#x27;import &#123; connect &#125; from &quot;../hoc&quot;import &#123; addNumber &#125; from &quot;../store/features/counter&quot;export class About extends PureComponent &#123;  render() &#123;    const &#123; counter &#125; = this.props    return (      &lt;div&gt;        &lt;h2&gt;About Counter: &#123;counter&#125;&lt;/h2&gt;      &lt;/div&gt;    )  &#125;&#125;const mapStateToProps = (state) =&gt; (&#123;  counter: state.counter.counter&#125;)const mapDispatchToProps = (dispatch) =&gt; (&#123;  addNumber(num) &#123;    dispatch(addNumber(num))  &#125;&#125;)export default connect(mapStateToProps, mapDispatchToProps)(About)\n\nRedux Toolkit的异步操作Redux Toolkit默认已经给我们继承了Thunk相关的功能：createAsyncThunk\nimport &#123; createSlice, createAsyncThunk &#125; from &#x27;@reduxjs/toolkit&#x27;import axios from &#x27;axios&#x27;export const fetchHomeMultidataAction = createAsyncThunk(  &quot;fetch/homemultidata&quot;,   async (extraInfo, &#123; dispatch, getState &#125;) =&gt; &#123;    // console.log(extraInfo, dispatch, getState)    // 1.发送网络请求, 获取数据    const res = await axios.get(&quot;http://123.207.32.32:8000/home/multidata&quot;)    // 2.取出数据, 并且在此处直接dispatch操作(可以不做)    const banners = res.data.data.banner.list    const recommends = res.data.data.recommend.list    dispatch(changeBanners(banners))    dispatch(changeRecommends(recommends))    // 3.返回结果, 那么action状态会变成fulfilled状态    return res.data&#125;)const homeSlice = createSlice(&#123;  name: &quot;home&quot;,  initialState: &#123;    banners: [],    recommends: []  &#125;,  reducers: &#123;    changeBanners(state, &#123; payload &#125;) &#123;      state.banners = payload    &#125;,    changeRecommends(state, &#123; payload &#125;) &#123;      state.recommends = payload    &#125;  &#125;,  // extraReducers: &#123;  //   [fetchHomeMultidataAction.pending](state, action) &#123;  //     console.log(&quot;fetchHomeMultidataAction pending&quot;)  //   &#125;,  //   [fetchHomeMultidataAction.fulfilled](state, &#123; payload &#125;) &#123;  //     state.banners = payload.data.banner.list  //     state.recommends = payload.data.recommend.list  //   &#125;,  //   [fetchHomeMultidataAction.rejected](state, action) &#123;  //     console.log(&quot;fetchHomeMultidataAction rejected&quot;)  //   &#125;  // &#125;  extraReducers: (builder) =&gt; &#123;    // builder.addCase(fetchHomeMultidataAction.pending, (state, action) =&gt; &#123;    //   console.log(&quot;fetchHomeMultidataAction pending&quot;)    // &#125;).addCase(fetchHomeMultidataAction.fulfilled, (state, &#123; payload &#125;) =&gt; &#123;    //   state.banners = payload.data.banner.list    //   state.recommends = payload.data.recommend.list    // &#125;)  &#125;&#125;)export const &#123; changeBanners, changeRecommends &#125; = homeSlice.actionsexport default homeSlice.reducer\n\nRedux Toolkit的数据不可变性我们经常会进行浅拷贝来完成某些操作，但是浅拷贝事实上也是存在问题的\n比如过大的对象，进行浅拷贝也会造成性能的浪费\n比如浅拷贝后的对象，在深层改变时，依然会对之前的对象产生影响\n事实上Redux Toolkit底层使用了immerjs的一个库来保证数据的不可变性\n为了节约内存，又出现了一个新的算法：Persistent Data Structure（持久化数据结构或一致性 数据结构）；\n​\t用一种数据结构来保存数据；\n​\t当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会 对内存造成浪费；\n自定义connect函数//connect.js// connect的参数:// 参数一: 函数// 参数二: 函数// 返回值: 函数 =&gt; 高阶组件import &#123; PureComponent &#125; from &quot;react&quot;;import &#123; StoreContext &#125; from &quot;./StoreContext&quot;;// import store from &quot;../store&quot;export function connect(mapStateToProps, mapDispatchToProps, store) &#123;  // 高阶组件: 函数  return function(WrapperComponent) &#123;    class NewComponent extends PureComponent &#123;      constructor(props, context) &#123;        super(props)                this.state = mapStateToProps(context.getState())      &#125;      componentDidMount() &#123;        this.unsubscribe = this.context.subscribe(() =&gt; &#123;          // this.forceUpdate()          this.setState(mapStateToProps(this.context.getState()))        &#125;)      &#125;      componentWillUnmount() &#123;        this.unsubscribe()      &#125;      render() &#123;        const stateObj = mapStateToProps(this.context.getState())        const dispatchObj = mapDispatchToProps(this.context.dispatch)        return &lt;WrapperComponent &#123;...this.props&#125; &#123;...stateObj&#125; &#123;...dispatchObj&#125;/&gt;      &#125;    &#125;    NewComponent.contextType = StoreContext    return NewComponent  &#125;&#125;\n\n//StoreContext.jsimport &#123; createContext &#125; from &quot;react&quot;;export const StoreContext = createContext()\n\n","categories":["react","note"]},{"title":"vue2和vue3的区别(vue2向vue3迁移)(一)","url":"/2022/08/12/VUE3%E5%92%8CVUE2%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%B8%80)/","content":"\nvue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。\nvue3中使用Proxy来实现对数据劫持，vue2中使用Object.defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用$set和$delete方法。\nvue3删除了$set和$off,$once.移除了filter,内敛模板等特性\n在编译方面做了优化：生成Block tree,Slot编译优化，diff算法优\nvue3中已经去掉了事件总线，可以使用mitt\nvue3中增加了componsition API\nvue3中移除了$children\nvue3中的推荐的构建工具已经从vue cli转成vite\nvue3中的推荐的状态管理工具已经从vuex转成pinia\nIDE支持Vetur-&gt;Volar\nvue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰\n添加了全新的全局api :createApp()来替代new Vue()来创建vue实例\n\n\n\n\n2.x Global API\n3.x Instance API (app)\n\n\n\nVue.config\napp.config\n\n\nVue.config.productionTip\n删除\n\n\nVue.config.ignoredElements\napp.config.compilerOptions.isCustomElement\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\nVue.extend\n删除\n\n\n13.全局 API Treeshakingimport Vue from &#x27;vue&#x27;Vue.nextTick(() =&gt; &#123;  // something DOM-related&#125;)\n\n在Vue2.X中Vue.nextTick()是一个暴露在单个Vue对象中的全局的api，事实上，实例方法$nextTick()只是一个包装器，为了方便Vue.nextTick()，回调函数的this会自动绑定到当前实例中，但是在vite和webpack中，Vue.nextTick不可以进行treeshaking,所以在Vue3中做了优化，让nextTick可以进行treeShaking,全局的模块只能作为ES模块构建的命名导出来进行访问，\nimport &#123; nextTick &#125; from &#x27;vue&#x27;nextTick(() =&gt; &#123;  // something DOM-related&#125;)\n\nimport &#123; shallowMount &#125; from &#x27;@vue/test-utils&#x27;import &#123; MyComponent &#125; from &#x27;./MyComponent.vue&#x27;import &#123; nextTick &#125; from &#x27;vue&#x27;test(&#x27;an async feature&#x27;, async () =&gt; &#123;  const wrapper = shallowMount(MyComponent)  // execute some DOM-related tasks  await nextTick()  // run your assertions&#125;)\n\n如果在Vue3中使用Vue.nextTick()会导致臭名昭著的undefined is not a function错误\n通过此更改，如果模块捆绑器支持 tree-shaking，则未在 Vue 应用程序中使用的全局 API 将从最终捆绑包中删除，从而获得最佳文件大小\n以下Vue2的全局QAPI会受到影响\nVue.nextTick\nVue.observable（替换为Vue.reactive）\nVue.version\nVue.compile（仅在完整版本中）\nVue.set（仅在兼容版本中）&#x2F;&#x2F;不要使用\nVue.delete（仅在兼容版本中）&#x2F;&#x2F;不要使用\n\n除了如上全局API之外，许多内部组件将不再作为默认导入的一部分，需要使用到时再导入，有利于treeShaking,\n&lt;transition&gt;  &lt;div v-show=&quot;ok&quot;&gt;hello&lt;/div&gt;&lt;/transition&gt;\n\n会被编译成\nimport &#123; h, Transition, withDirectives, vShow &#125; from &#x27;vue&#x27;export function render() &#123;  return h(Transition, [withDirectives(h(&#x27;div&#x27;, &#x27;hello&#x27;), [[vShow, this.ok]])])&#125;\n\n可以减少包的大小\nnotice\n上述内容仅适用于与支持 tree-shaking 的捆绑器一起使用的ES 模块构建- UMD 构建仍然包含所有功能并在 Vue 全局变量上公开所有内容（并且编译器将生成适当的输出以使用全局 API 而不是导入）。\n再插件中使用时\nVue2.x中使用全局api\nconst plugin = &#123;  install: Vue =&gt; &#123;    Vue.nextTick(() =&gt; &#123;      // ...    &#125;)  &#125;&#125;\n\nVue3.x使用全局API\nimport &#123; nextTick &#125; from &#x27;vue&#x27;const plugin = &#123;  install: app =&gt; &#123;    nextTick(() =&gt; &#123;      // ...    &#125;)  &#125;&#125;\n\n在webpack中如果把上诉代码打包成一个buddle,他会把vue源码也会打包进去，如果要避免这样的发生可以使用externals排除\n// webpack.config.jsmodule.exports = &#123;  /*...*/  externals: &#123;    vue: &#x27;Vue&#x27;  &#125;&#125;\n\nrollUp中的写法\n// rollup.config.jsexport default &#123;  /*...*/  external: [&#x27;vue&#x27;]&#125;\n\n14.v-model在组建中使用v-model\n在vue2.x,v-model在组件上使用 a 相当于传递一个valueprop 并发出一个input事件：\n&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;&lt;!-- would be shorthand for: --&gt;&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;pageTitle = $event&quot; /&gt;\n\n如果想更改属性名和事件的时候，需要使用在组件中添加model选项，\n&lt;!-- ParentComponent.vue --&gt;&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;\n\n// ChildComponent.vueexport default &#123;  model: &#123;    prop: &#x27;title&#x27;,    event: &#x27;change&#x27;  &#125;,  props: &#123;    // this allows using the `value` prop for a different purpose    value: String,    // use `title` as the prop which take the place of `value`    title: &#123;      type: String,      default: &#x27;Default title&#x27;    &#125;  &#125;&#125;\n\n所以v-model实际上时这样的\n&lt;ChildComponent :title=&quot;pageTitle&quot; @change=&quot;pageTitle = $event&quot; /&gt;\n\n使用v-bind.sync#在某些情况下，我们可能需要一个道具的“双向绑定”（有时除了现有v-model的不同道具之外）。为此，我们建议以update:myPropName. 例如，对于ChildComponent上一个带有titleprop 的示例，我们可以通过以下方式传达分配新值的意图：\nthis.$emit(&#x27;update:title&#x27;, newValue)\n\n然后，如果需要，父级可以侦听该事件并更新本地数据属性。例如：\n&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;\n\n.sync为方便起见，我们使用修饰符对这种模式进行了简写：\n&lt;ChildComponent :title.sync=&quot;pageTitle&quot; /&gt;\n\n在Vue3.x中 自定义组件的双向数据绑定时使用modelValue，@update:modelValue来替代\n&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;&lt;!-- would be shorthand for: --&gt;&lt;ChildComponent  :modelValue=&quot;pageTitle&quot;  @update:modelValue=&quot;pageTitle = $event&quot;/&gt;\n\n如果需要修改model的名称则直接修改\n&lt;ChildComponent v-model:title=&quot;pageTitle&quot; /&gt;&lt;!-- would be shorthand for: --&gt;&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;\n\n也可以作为.sync的替代，可以在组件中双向数据绑定多个值\n&lt;ChildComponent v-model:title=&quot;pageTitle&quot; v-model:content=&quot;pageContent&quot; /&gt;&lt;!-- would be shorthand for: --&gt;&lt;ChildComponent  :title=&quot;pageTitle&quot;  @update:title=&quot;pageTitle = $event&quot;  :content=&quot;pageContent&quot;  @update:content=&quot;pageContent = $event&quot;/&gt;\n\n","categories":["vue","daily"]},{"title":"vue2和vue3的区别(vue2向vue3迁移)(二)","url":"/2022/08/12/Vue3%E5%92%8CVue%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%BA%8C)/","content":"15.key属性key主要适用于在Vue的虚拟DOM算法中，跟踪节点的，以便重用和修改现有的节点，以及何时修改或者重新排序。\n在Vue2.x中，key也被推荐用于v-if,v-else,v-else-if\n&lt;!-- Vue 2.x --&gt;&lt;div v-if=&quot;condition&quot; key=&quot;yes&quot;&gt;Yes&lt;/div&gt;&lt;div v-else key=&quot;no&quot;&gt;No&lt;/div&gt;\n\n在vue3.x中不再要求这么使用，因为vue会自己给他添加一个unique key\n&lt;!-- Vue 3.x --&gt;&lt;div v-if=&quot;condition&quot;&gt;Yes&lt;/div&gt;&lt;div v-else&gt;No&lt;/div&gt;\n\n如果你确实想添加key,必须保证key唯一\n&lt;!-- Vue 2.x --&gt;&lt;div v-if=&quot;condition&quot; key=&quot;a&quot;&gt;Yes&lt;/div&gt;&lt;div v-else key=&quot;a&quot;&gt;No&lt;/div&gt;&lt;!-- Vue 3.x (recommended solution: remove keys) --&gt;&lt;div v-if=&quot;condition&quot;&gt;Yes&lt;/div&gt;&lt;div v-else&gt;No&lt;/div&gt;&lt;!-- Vue 3.x (alternate solution: make sure the keys are always unique) --&gt;&lt;div v-if=&quot;condition&quot; key=&quot;a&quot;&gt;Yes&lt;/div&gt;&lt;div v-else key=&quot;b&quot;&gt;No&lt;/div&gt;\n\n &lt;template v-for&gt;\nvue2.x中 &lt;template&gt;标签不能拥有key,只能在他的子元素中设置key\n\n&lt;!-- Vue 2.x --&gt;&lt;template v-for=&quot;item in list&quot;&gt;  &lt;div :key=&quot;&#x27;heading-&#x27; + item.id&quot;&gt;...&lt;/div&gt;  &lt;span :key=&quot;&#x27;content-&#x27; + item.id&quot;&gt;...&lt;/span&gt;&lt;/template&gt;\n\n在vue3.x中，key应该被设置在template上\n\n\n\n  ...\n  ...\n\n\n\nv-for也是一样\n&lt;!-- Vue 2.x --&gt;&lt;template v-for=&quot;item in list&quot;&gt;  &lt;div v-if=&quot;item.isVisible&quot; :key=&quot;item.id&quot;&gt;...&lt;/div&gt;  &lt;span v-else :key=&quot;item.id&quot;&gt;...&lt;/span&gt;&lt;/template&gt;&lt;!-- Vue 3.x --&gt;&lt;template v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;  &lt;div v-if=&quot;item.isVisible&quot;&gt;...&lt;/div&gt;  &lt;span v-else&gt;...&lt;/span&gt;&lt;/template&gt;\n\n16.v-if 与 v-for 优先级在vue2.x中，在相同的元素中v-for的优先级更高\nVue3.x中，v-if的优先级更高\n17.v-bindvue2.x中\n&lt;!-- template --&gt;&lt;div id=&quot;red&quot; v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;!-- result --&gt;&lt;div id=&quot;red&quot;&gt;&lt;/div&gt;\n\nvue3.x中\n&lt;!-- template --&gt;&lt;div id=&quot;red&quot; v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;!-- result --&gt;&lt;div id=&quot;blue&quot;&gt;&lt;/div&gt;&lt;!-- template --&gt;&lt;div v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot; id=&quot;red&quot;&gt;&lt;/div&gt;&lt;!-- result --&gt;&lt;div id=&quot;red&quot;&gt;&lt;/div&gt;\n\n对于绑定相同的属性，v2不会覆盖，而v3会被覆盖 v3中绑定有顺序要求\n18.v-on.native已经被移除19.函数式组件vue2.x中函数式组件主要用于性能优化，他的初始化速度要快于有状态组件，而且可以返回多个根节点，vue3.x中有状态组件的性能优化可以和无状态组件一样，而且还可以有多个跟节点\n20.异步组件vue2.x中异步组件的写法是\nconst asyncModal = () =&gt; import(&#x27;./Modal.vue&#x27;)\n\n或者可配置\nconst asyncModal = &#123;  component: () =&gt; import(&#x27;./Modal.vue&#x27;),  delay: 200,  timeout: 3000,  error: ErrorComponent,  loading: LoadingComponent&#125;\n\nvue3中添加了一个定义异步组件的方法\nimport &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;import ErrorComponent from &#x27;./components/ErrorComponent.vue&#x27;import LoadingComponent from &#x27;./components/LoadingComponent.vue&#x27;// Async component without optionsconst asyncModal = defineAsyncComponent(() =&gt; import(&#x27;./Modal.vue&#x27;))// Async component with optionsconst asyncModalWithOptions = defineAsyncComponent(&#123;  loader: () =&gt; import(&#x27;./Modal.vue&#x27;),  delay: 200,  timeout: 3000,  errorComponent: ErrorComponent,  loadingComponent: LoadingComponent&#125;)\n\n而且vue2.x中的配置选项component变成了loader\nvue3.x不再接受resolve，reject参数，而是返回一个promise\n// 2.x versionconst oldAsyncComponent = (resolve, reject) =&gt; &#123;  /* ... */&#125;// 3.x versionconst asyncComponent = defineAsyncComponent(  () =&gt;    new Promise((resolve, reject) =&gt; &#123;      /* ... */    &#125;))\n\n21.emits Optionvue2.x中不需要声明emits的值\n&lt;template&gt;  &lt;div&gt;    &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;    &lt;button v-on:click=&quot;$emit(&#x27;accepted&#x27;)&quot;&gt;OK&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    props: [&#x27;text&#x27;]  &#125;&lt;/script&gt;\n\nvue3.x中需要定义emits\n&lt;template&gt;  &lt;div&gt;    &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;    &lt;button v-on:click=&quot;$emit(&#x27;accepted&#x27;)&quot;&gt;OK&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    props: [&#x27;text&#x27;],    emits: [&#x27;accepted&#x27;]  &#125;&lt;/script&gt;\n\n下面例子中&lt;template&gt;  &lt;button v-on:click=&quot;$emit(&#x27;click&#x27;, $event)&quot;&gt;OK&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  emits: [] // without declared event&#125;&lt;/script&gt;\n\n在父组件中监听click事件\n&lt;my-button v-on:click=&quot;handleClick&quot;&gt;&lt;/my-button&gt;\n\nclick会被触发两次\n22.$listener移除23.$attrs中包含class和stylevue2.x中，class和style属性在 Vue 2 虚拟 DOM 实现中得到一些特殊处理。因此，它们不包含在 中$attrs，而所有其他属性都包含在 中。\n使用时会出现这样的副作用inheritAttrs: false：\n这样$attr中的属性不再自动绑定到子组件的根元素上，而是由开发者来决定怎么绑定他们，但是class和style不属于$attr的一部分，任然会应用在根元素上\n&lt;template&gt;  &lt;label&gt;    &lt;input type=&quot;text&quot; v-bind=&quot;$attrs&quot; /&gt;  &lt;/label&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  inheritAttrs: false&#125;&lt;/script&gt;\n\n&lt;my-component id=&quot;my-id&quot; class=&quot;my-class&quot;&gt;&lt;/my-component&gt;\n\n真正渲染成的html\n&lt;label class=&quot;my-class&quot;&gt;  &lt;input type=&quot;text&quot; id=&quot;my-id&quot; /&gt;&lt;/label&gt;\n\n在Vue3.x中则包含这些\n24.v-on不再支持数字的keycode25.不在支持$on,$off,$oncevue2.x中支持事件总线\n// eventBus.jsconst eventBus = new Vue()export default eventBus\n\n// ChildComponent.vueimport eventBus from &#x27;./eventBus&#x27;export default &#123;  mounted() &#123;    // adding eventBus listener    eventBus.$on(&#x27;custom-event&#x27;, () =&gt; &#123;      console.log(&#x27;Custom event triggered!&#x27;)    &#125;)  &#125;,  beforeDestroy() &#123;    // removing eventBus listener    eventBus.$off(&#x27;custom-event&#x27;)  &#125;&#125;\n\n// ParentComponent.vueimport eventBus from &#x27;./eventBus&#x27;export default &#123;  methods: &#123;    callGlobalCustomEvent() &#123;      eventBus.$emit(&#x27;custom-event&#x27;) // if ChildComponent is mounted, we will have a message in the console    &#125;  &#125;&#125;\n\nvue3.x中事件总线可以使用第三方的库来实现，例如mitt或tiny-emitter\n// eventBus.jsimport emitter from &#x27;tiny-emitter/instance&#x27;export default &#123;  $on: (...args) =&gt; emitter.on(...args),  $once: (...args) =&gt; emitter.once(...args),  $off: (...args) =&gt; emitter.off(...args),  $emit: (...args) =&gt; emitter.emit(...args)&#125;\n\n26.filtersvue3.x移除了过滤器，可以使用methods和computed来替代\n全局的过滤器可以使用如下方式来在vue3中定义\n// main.jsconst app = createApp(App)app.config.globalProperties.$filters = &#123;  currencyUSD(value) &#123;    return &#x27;$&#x27; + value  &#125;&#125;\n\n&lt;template&gt;  &lt;h1&gt;Bank Account Balance&lt;/h1&gt;  &lt;p&gt;&#123;&#123; $filters.currencyUSD(accountBalance) &#125;&#125;&lt;/p&gt;&lt;/template&gt;\n\n27.删除了inline-template28.删除了$childrenvue2.x可以使用$children来访问直接子组件，vue3.x使用refs来替代就可以了\n29.自定义指令指令的钩子函数已经重新命名，更好的和组件的生命周期配合，此外，expression字符串不再作为binding对象的一部分传递\nvue2.x中的directive的可选项\nbind  指令只绑定一次到元素中\ninserted  元素只被插入父元素中一次\nupdate  该hook表示当元素更新时，children还没有更新\ncomponentUpdated  表示组件和子元素都更新完毕\nunbind 表示解绑\nvue2.x的自定义指令\n&lt;p v-highlight=&quot;&#x27;yellow&#x27;&quot;&gt;Highlight this text bright yellow&lt;/p&gt;\n\nVue.directive(&#x27;highlight&#x27;, &#123;  bind(el, binding, vnode) &#123;    el.style.background = binding.value  &#125;&#125;)\n\nvue3.x中新增了created    这个声明周期是在元素的属性和事件被应用之前\nbind -&gt;beforeMount\ninserted -&gt;mounted\nbeforeUpdate 类似于组件的beforeUpdate\nupdate被移除\ncomponentUpdated → updated\nbeforeUnmount: new! Similar to component lifecycle hooks, this will be called right before an element is unmounted\nunbind -&gt; unmounted\nconst MyDirective = &#123;  created(el, binding, vnode, prevVnode) &#123;&#125;, // new  beforeMount() &#123;&#125;,  mounted() &#123;&#125;,  beforeUpdate() &#123;&#125;, // new  updated() &#123;&#125;,  beforeUnmount() &#123;&#125;, // new  unmounted() &#123;&#125;&#125;\n\n&lt;p v-highlight=&quot;&#x27;yellow&#x27;&quot;&gt;Highlight this text bright yellow&lt;/p&gt;\n\nconst app = Vue.createApp(&#123;&#125;)app.directive(&#x27;highlight&#x27;, &#123;  beforeMount(el, binding, vnode) &#123;    el.style.background = binding.value  &#125;&#125;)\n\n30.data optionvue2.x中还可以使用对象作为data的值。vue3.x不可以使用对象作为data,必须使用function\n31.元素的挂载在vue2.x中当挂载的元素是一个templayte的时候，渲染的内容会替换掉需要挂载的元素，在vue3.x中，需要被渲染的内容会添加到元素的children中，替代元素的innerHTML\nvue2.x中\nnew Vue(&#123;  el: &#x27;#app&#x27;,  data() &#123;    return &#123;      message: &#x27;Hello Vue!&#x27;    &#125;  &#125;,  template: `    &lt;div id=&quot;rendered&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;  `&#125;)// orconst app = new Vue(&#123;  data() &#123;    return &#123;      message: &#x27;Hello Vue!&#x27;    &#125;  &#125;,  template: `    &lt;div id=&quot;rendered&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;  `&#125;)app.$mount(&#x27;#app&#x27;)\n\n挂载到对应的元素上\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    Some app content  &lt;/div&gt;&lt;/body&gt;\n\n最终渲染的效果\n&lt;body&gt;  &lt;div id=&quot;rendered&quot;&gt;Hello Vue!&lt;/div&gt;&lt;/body&gt;\n\nvue3.x中的效果\nconst app = Vue.createApp(&#123;  data() &#123;    return &#123;      message: &#x27;Hello Vue!&#x27;    &#125;  &#125;,  template: `    &lt;div id=&quot;rendered&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;  `&#125;)app.mount(&#x27;#app&#x27;)\n\n&lt;body&gt;  &lt;div id=&quot;app&quot; data-v-app=&quot;&quot;&gt;    &lt;div id=&quot;rendered&quot;&gt;Hello Vue!&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;\n\n32.transition的变化.v-enter已被替换成.v-enter-from\n33.vNode 生命周期事件在vue2.x中，可以使用事件来监听组件生命周期处于哪个阶段，这些事件的前缀是hook:,在 Vue 3 中，此前缀已更改为vue:. 此外，这些事件现在可用于 HTML 元素和组件\nvue2.x \nhook:后面跟的是生命周期函数的名称\n&lt;template&gt;  &lt;child-component @hook:updated=&quot;onUpdated&quot;&gt;&lt;/template&gt;\n\nvue3.x中\n&lt;template&gt;  &lt;child-component @vue:updated=&quot;onUpdated&quot;&gt;&lt;/template&gt;\n\n34.数组的监听vue3.x中，数组的监听需要加上deep\nwatch: &#123;  bookList: &#123;    handler(val, oldVal) &#123;      console.log(&#x27;book list changed&#x27;)    &#125;,    deep: true  &#125;,&#125;\n\n","categories":["vue","daily"]},{"title":"vue3笔记","url":"/2022/08/16/Vue3%E7%AC%94%E8%AE%B0(%E4%B8%80)/","content":"1.vue手脚架代价脚本  两种方式vue create  项目名  构建工具是webpacknpm init vue@latest  \t1.安装一个本地工具：create-vue  \t2.使用create-vue创建一个vue项目  构建工具是vite\n\n2.$attrs3.emitsvue3中增加了$emit事件的声明\n4.reactive只能传入一个对象，定义复杂类型的数据，事实上编写的data函数在内部也是调用reactive来完成响应式的5.ref函数，用于定义简单类型的数据，也可以定义复杂类型的数据。ref会进行自动解包，ref的解包是浅层解包但是在深层次引用的时候，使用的时候是直接使用，在设置的时候需要用.value\n6.ref和reactive的使用场景​\t\treactive可以应用于本地的数据，多个数据之间是有联系的，是聚合数据\n​\t\t其他场景可以运用ref,定义网络请求中的数据也是用ref\n\nreadonly\n\n​\t不要违反单项数据流，把响应式的reactive或者ref传递给子组件，子组件可以修改数据，为了不要让子组件修改数据，可以将传入的响应式变成readonly\nconst obj1=readonly(obj)//可以将这个obj1传递过去\n\nreadonly会返回原始对象的只读代理，本质上是劫持proxy的set方法，不能进行设置新的值\n8.isProxy判断是否是由reactive或者readonly创建的proxy\n9.isReactive 检查对象是否是由reactive创建的响应式代理，如果该代理是由readonly创建的，但是包裹reactive,也是true\n10.isReadonly 是否是readonly\n11.toRow返回reactive或者readonly代理的原始对象\n12.shallowReactive  创建一个响应式代理，跟踪本身的property,但是不会执行嵌套对象的深层响应式代理\n13.shallowReadonly 只读的浅层\n14.toRefs 将响应式对象转换成普通对象，里面的property转成ref,可以进行解构成ref响应式\nconst &#123;a&#125;=toRefs(reactive(&#123;a:&quot;zjag&quot;&#125;)  //可以用于reactive的解构\n\nreactive默认情况下解构的值没有响应式\n15.setup的生命周期16.Provide函数17.路由钩子函数18.beforeEach 全局的前置守卫beforeEach是会在导航触发的时候被调用，他又两个参数to,from,又返回值，返回false则会取消当前导航，不返回或者返回undefined则使用默认导航，返回一个路由地址，可以是字符串，也可以是object，包括路由信息\n19.什么是MVVM，和MVC的区别20.data必须是一个函数，并且返回一个对象，在vue2中，也可以传入一个对象，在vue3中必须使用函数\n21.箭头函数不能定义method中的函数，因为箭头函数中·没有this,箭头函数的this是由上层作用域的this来决定的，所以不会指定到当前组件实例\n22.在源码中this的指向\n23.v-once 表示当前元素或者组件只会更新一次，就是初始化以后就不会再次渲染，包含的子组件也是渲染也是渲染一次，在特定多的场合使用可以提高性能\n24.v-text&lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt;&lt;h1 v-text=&quot;count&quot;&gt;&lt;/h1&gt;  //二者是等价的\n\n25.v-html可以将字符串转换成html\n默认情况下，如果我们展示的内容本身是html 的，那么vue并不会对其进行特殊的解析。\n如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示\n&lt;h1 v-html=&quot;content&quot;&gt;&lt;/h1&gt; data() &#123;         return &#123;           count: 0,           content: `&lt;span style=&quot;color: red; font-size: 30px;&quot;&gt;哈哈哈&lt;/span&gt;`,         &#125;;       &#125;,\n\n26.v-pre用于跳过元素和他的子元素的编译过程，显示原始的Mustach标签，就是不会对其进行编译\n\n\n\n27.v-cloak这个指令保持在元素上直到关联的组件实例结束编译，需要和css结合使用\n\n\n28.v-memo适用于性能优化，只有对应的数组中属性的值发生变化时才会重新渲染\n\n\n29.v-bind v-bind的简写\n30.class绑定的语法动态绑定的class可以和普通的class一起使用\n:class可以是字符串，属性，对象，数组，计算属性返回一个对象，或是使用方法的调用返回一个对象或者数组\n31.style绑定的语法\n32.:[name]&#x3D;”value”  动态绑定属性33.如下 &lt;h1 v-bind=&quot;obj&quot;&gt;&lt;/h1&gt; //绑定对象 可以将所有对象的属性遍历，绑定过去\n\n34.v-on事件绑定  @简写35.v-on事件的参数传递\n36.v-on的修饰符.stop - 调用 event.stopPropagation()。\n.prevent - 调用 event.preventDefault()。\n.capture - 添加事件侦听器时使用 capture 模式。\n.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。\n.{keyAlias} - 仅当事件是从特定键触发时才触发回调。\n.once - 只触发一次回调。\n.left - 只当点击鼠标左键时触发。\n.right - 只当点击鼠标右键时触发。\n.middle - 只当点击鼠标中键时触发。\n.passive - { passive: true } 模式添加侦听器\n37.v-if ,v-else, v-else-ifv-if的渲染原理\nv-if是惰性的，只有在条件判断为true的时候，才会重新渲染。当为false的时候不会渲染\n38.v-show39.template元素template元素可以在页面中不做渲染，可以用于包裹元素，但是不会在页面中渲染\n40.v-for和v-show的区别首先，在用法上的区别：\nv-show是不支持template；\nv-show不可以和v-else一起使用；\n其次，本质的区别：\nv-show元素无论是否需要显示到浏览器上，它的DOM实际都是有存在的，只是通过CSS的display属性来进行切换；\nv-if当条件为false时，其对应的原生压根不会被渲染到DOM中；\n开发中如何进行选择呢？\n如果我们的原生需要在显示和隐藏之间频繁的切换，那么使用v-show；\n如果不会频繁的发生切换，那么使用v-if；\n41.v-for\n42.数组跟新检测vue会对以下数组的方法进行包裹，所以通过这些方法变更数组可以触发页面的更新\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n这些方法都会直接修改原来的数组，\n对于一些纯函数的数组方法，他会返回一个新的数组，所以必须将这个新的数组赋值给原来的属性\n43.v-for中key的作用key属性主要适用于Diff算法中，在新旧node对比时辨识vnode,如果不使用key,vue会使用一种最大限度减少动态元素并且尽可能的尝试就地复用或者修改相同类型的元素的算法\n而使用了key时，他会基于key的变化重新排列元素顺序，并且会移除&#x2F;销毁key不存在的元素\n44.什么是vnodevnode 全称virual node 就是虚拟节点，组件和元素都会被抽象成一个个虚拟节点，vnode本质就是一个个对象\n45.diff算法针对有key的vnode进行diff操作时\n1.首先会对新旧节点进行遍历，从头部开始，遇到相同的节点则继续，直到遇到不用的节点则跳出\n2.然后再从新旧vnode节点的尾部开始遍历，遇到相同的节点则继续，遇到不同的节点则会跳出\n3.如果最后新的节点更多，那么就添加新的节点\n4.如果旧的节点比较多，则会移除旧的节点\n5.如果中间存在无序的节点，就通过key建立所用途最大限度的复用旧节点\n46.computed​\tcomputed有缓存，只有依赖的属性发生变化的时候才会重新执行\n​\tcomputed和method的区别\n​\t\t\tcomputed是计算属性，method是方法，每次都会调用，computed只有数据变化时才会调用\n​\tcomputed的get set写法\n\n47.watch\n回调的触发时机#当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。\n默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。\n如果想在侦听器回调中能访问被 Vue 更新之后的DOM，你需要指明 flush: &#39;post&#39; 选项：\nexport default &#123;  // ...  watch: &#123;    key: &#123;      handler() &#123;&#125;,      flush: &#x27;post&#x27;    &#125;  &#125;&#125;\n\n48.jsconfig.json主要是给vscode中给项目更好的提示，没有也没关系//vue.config.jsconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123;  transpileDependencies: true,  configureWebpack: &#123;    resolve: &#123;      // 配置路径别名      // @是已经配置好的路径别名: 对应的是src路径      alias: &#123;        &quot;utils&quot;: &quot;@/utils&quot;       &#125;    &#125;  &#125;&#125;)\n\n//jsconfig.json&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;es5&quot;,    &quot;module&quot;: &quot;esnext&quot;,    &quot;baseUrl&quot;: &quot;./&quot;,//定义根目录    &quot;moduleResolution&quot;: &quot;node&quot;,    &quot;paths&quot;: &#123;      &quot;@/*&quot;: [        &quot;src/*&quot;      ],      //webpack配置了别名，为了给项目中更好的提示，可以在这里配置，否则写的时候没有提示      &quot;utils/*&quot;: [        &quot;src/utils/*&quot;      ]    &#125;,    &quot;lib&quot;: [      &quot;esnext&quot;,      &quot;dom&quot;,      &quot;dom.iterable&quot;,      &quot;scripthost&quot;    ]  &#125;&#125;\n\n49.v-model50.使用手脚架开发npm install @vue/cli -g   //安装手脚架npm update @vue/cli -g //更手脚架Vue create 项目的名称这种方式采用webpack作为构建工具现在官方已经不再作为推荐的手脚搭建工具了开始使用npm init vue@latest 命令  使用vite作为构建工具\n\n\n\n\n\n\n\n\n\n\nimport &#123; createApp &#125; from &quot;vue/dist/vue.esm-bundler&quot;;// import App from &#x27;./App.vue&#x27;/** * 当App是以对象的形式写的话就要使用 vue/dist/vue.esm-bundler * 这两种方式的不同，使用对象的方式，是因为如果引入的是vue,vue是runtime的代码，，不会编译template成\t * vnode,需要使用vue/dist/vue.esm-bundler * 里面包括compiler+runtime，可以将template-&gt;createVNode-&gt;Vnode-&gt;DOM,对象的写法是由 * vue/dist/vue.esm-bundler的源码来完成的，.vue文件的写法是由vue-loader来完成template-&gt;vnode的过程 */const App = &#123;  data() &#123;    return &#123;&#125;;  &#125;,  template: `&lt;h1&gt;vue&lt;/h1&gt;`,&#125;;createApp(App).mount(&quot;#app&quot;);\n\n51.注册组件的方式全局组件\n局部组件\n52.父组件向子组件传递数据父组件向子组件传递数据是通过props来完成的\n&lt;script&gt;export default &#123;  // 写法一  // props: [&quot;height&quot;, &quot;name&quot;, &quot;gender&quot;, &quot;width&quot;],  // 写法二  // props: &#123;  //   height: Object,  //   name: Number,  //   gender: String,  //   width: Number,  // &#125;,  // 第三种写法  // 当默认值是对象或者函数的时候，必须返回一个函数  props: &#123;    propsB: &#123;      // 当props是一个函数的时候，这个不是一个工厂函数，而是作为一个默认值      type: Function,      default() &#123;        return &quot;default&quot;;      &#125;,    &#125;,    h: [Number, String], //可以是多种类型    a: &#123;      type: Number,      required: true, //表示是必填值    &#125;,    height: &#123;      type: Object,      default: () =&gt; (&#123; name: &quot;hhhh&quot; &#125;),    &#125;,    name: &#123;      type: String,      default: &quot;我是string&quot;,    &#125;,    gender: &#123;      type: Array,      default() &#123;        return [1, 2, 3];      &#125;,    &#125;,    width: &#123;      type: Number,      default: 88888,    &#125;,  &#125;,&#125;;&lt;/script&gt;\n\nprop常见的两种用法字符串数组，就是数组中的字符串就是attribute的名称，传递的数据类型时只能是字符串，不能是其他类型\n&lt;show-info name=&quot;why&quot; :age=&quot;18&quot; :height=&quot;1.88&quot;              address=&quot;广州市&quot; abc=&quot;cba&quot; class=&quot;active&quot; /&gt;//传递的数据类型不是string值，是其他类型或者是变量，必须用v-bind/:\n\n对象类型，对象类型我们可以指定attribute名称时，指定传递类型默认值，校验等\n&lt;show-info :age=&quot;100&quot; show-message=&quot;哈哈哈哈&quot;/&gt;\n\nprops允许的数据类型String,Number,Boolean,Array,Object,Date,Function,Symbol\nprops的命名html中attribute名大小写不敏感，所以浏览器会把所有大写解释为小写，在模板中使用驼峰规则，的prop名要写成短横线\n53.非prop的attribute当我们传递一个组件某个属性值，但是这个属性值没有对应的props和emits，就是非props的attribute，例如class,style,id等。\n当组件有单个根节点时，非prop的attribute就会默认绑定到根节点上\n如果不希望绑定到根节点，想要手动的绑定节点，可以在组件中设置\ninheritAttr:false\n\n就可以通过$attrs来访问所有的非props的attribute\n&lt;template&gt;  &lt;div&gt;    &lt;h1 :class=&quot;$attr.class&quot;&gt;hhhhhhhh&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    inheritAttrs:false  &#125;\n\n多个根节点的attribute\n如果是多个根节点的情况，多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个元素上\n&lt;template&gt;  &lt;div&gt;    &lt;h1 v-bind=&quot;$attr&quot;&gt;hhhhhhhh&lt;/h1&gt;    &lt;div&gt;33333&lt;/div&gt;    &lt;div&gt;4444&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n\n注意template模板中允许有多个根节点\n54.子组件向父组件从传递数据//子组件&lt;template&gt;  &lt;div class=&quot;add&quot;&gt;    &lt;button @click=&quot;btnClick(1)&quot;&gt;+1&lt;/button&gt;    &lt;button @click=&quot;btnClick(5)&quot;&gt;+5&lt;/button&gt;    &lt;button @click=&quot;btnClick(10)&quot;&gt;+10&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    // 1.emits数组语法    emits: [&quot;add&quot;],    // 2.emmits对象语法    // emits: &#123;    //   add: function(count) &#123;    //     if (count &lt;= 10) &#123;    //       return true    //     &#125;    //     return false    //   &#125;    // &#125;,    methods: &#123;      btnClick(count) &#123;        console.log(&quot;btnClick:&quot;, count)        // 让子组件发出去一个自定义事件        // 第一个参数自定义的事件名称        // 第二个参数是传递的参数        this.$emit(&quot;add&quot;, 100)      &#125;    &#125;  &#125;&lt;/script&gt;\n\n//app,vue&lt;add-counter @add=&quot;addBtnClick&quot;&gt;&lt;/add-counter&gt;\n\n55.插槽slot插槽的使用过程其实是抽取共性、预留不同\n//show-message.vue//插槽的定义方式，使用&lt;slot&gt;标签进行占位，可以写入默认值，没有传递时就是用默认值&lt;div class=&quot;content&quot;&gt;    &lt;slot&gt;      &lt;p&gt;我是默认内容, 哈哈哈&lt;/p&gt;    &lt;/slot&gt;  &lt;/div&gt;\n\n//插槽的使用&lt;show-message&gt;      &lt;a href=&quot;#&quot;&gt;百度一下&lt;/a&gt;&lt;/show-message&gt;\n\n56.具名插槽的使用当需要插入不同的模块到不同的slot的时候，需要定义具体的名字。默认情况下不带名字时，会有默认的名字。\n一个不带 name 的slot，会带有隐含的名字 default；\n具名插槽使用的时候缩写：\n跟 v-on 和 v-bind 一样，v-slot 也有缩写； \n 即把参数之前的所有内容 (v-slot:) 替换为字符 #；\n//nav-bar.vue&lt;template&gt;  &lt;div class=&quot;nav-bar&quot;&gt;    &lt;div class=&quot;left&quot;&gt;      &lt;slot name=&quot;left&quot;&gt;left&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;center&quot;&gt;      &lt;slot name=&quot;center&quot;&gt;center&lt;/slot&gt;    &lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;      &lt;slot name=&quot;right&quot;&gt;right&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;other&quot;&gt;    &lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;\n\n//App.vue&lt;template&gt;  &lt;nav-bar&gt;  //简写    &lt;template #left&gt;      &lt;button&gt;&#123;&#123; leftText &#125;&#125;&lt;/button&gt;    &lt;/template&gt;    &lt;template #center&gt;      &lt;span&gt;内容&lt;/span&gt;    &lt;/template&gt;//完整写法    &lt;template v-slot:right&gt;      &lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;    &lt;/template&gt;  &lt;/nav-bar&gt;  &lt;!-- nav-bar只给一个插槽传入数据 --&gt;  &lt;nav-bar&gt;  //动态插槽名    &lt;template v-slot:[position]&gt;      &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;    &lt;/template&gt;  &lt;/nav-bar&gt;  &lt;button @click=&quot; position = &#x27;left&#x27; &quot;&gt;左边&lt;/button&gt;  &lt;button @click=&quot; position = &#x27;center&#x27; &quot;&gt;中间&lt;/button&gt;  &lt;button @click=&quot; position = &#x27;right&#x27; &quot;&gt;右边&lt;/button&gt;&lt;/template&gt;&lt;script&gt;  import NavBar from &#x27;./NavBar.vue&#x27;  export default &#123;    components: &#123;      NavBar    &#125;,    data() &#123;      return &#123;        position: &quot;center&quot;,        leftText: &quot;返回&quot;      &#125;    &#125;  &#125;&lt;/script&gt;\n\n57.渲染作用域在vue模板中，父级模板的所有内容都是在父级作用域中编译完成的\n子模版中所有内容都是在作用域中编译完成的，所以具名插槽的作用域是在父级，而作用域插槽的作用域是在子模版中\n58.作用域插槽作用域插槽可以通过插槽访问子组件的内容，而修改每个具体的样式\n//tabControll.vue&lt;template&gt;  &lt;div class=&quot;tab-control&quot;&gt;    &lt;template v-for=&quot;(item, index) in titles&quot; :key=&quot;item&quot;&gt;      &lt;div class=&quot;tab-control-item&quot;           :class=&quot;&#123; active: index === currentIndex &#125;&quot;           @click=&quot;itemClick(index)&quot;&gt;        &lt;slot :item=&quot;item&quot; abc=&quot;cba&quot;&gt;          &lt;span&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt;//这是默认值        &lt;/slot&gt;      &lt;/div&gt;    &lt;/template&gt;  &lt;/div&gt;&lt;/template&gt;\n\n//App.vue&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;!-- 1.tab-control --&gt;    &lt;tab-control :titles=&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;                  @tab-item-click=&quot;tabItemClick&quot;/&gt;    &lt;!-- &lt;tab-control :titles=&quot;[&#x27;流行&#x27;, &#x27;最新&#x27;, &#x27;优选&#x27;]&quot;/&gt; --&gt;    &lt;!-- 2.展示内容 --&gt;    &lt;h1&gt;&#123;&#123; pageContents[currentIndex] &#125;&#125;&lt;/h1&gt;    &lt;!-- 1.tab-control: button --&gt;    &lt;tab-control :titles=&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;                  @tab-item-click=&quot;tabItemClick&quot;&gt;      &lt;template v-slot:default=&quot;props&quot;&gt;        &lt;button&gt;&#123;&#123; props.item &#125;&#125;&lt;/button&gt;      &lt;/template&gt;    &lt;/tab-control&gt;        &lt;!-- 2.tab-control: a元素(重要) --&gt;    &lt;tab-control :titles=&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;                  @tab-item-click=&quot;tabItemClick&quot;&gt;      &lt;template #default=&quot;props&quot;&gt;        &lt;a href=&quot;#&quot;&gt;&#123;&#123; props.item &#125;&#125;&lt;/a&gt;      &lt;/template&gt;    &lt;/tab-control&gt;    &lt;!-- 3.独占默认插槽的简写(了解) --&gt;    &lt;tab-control :titles=&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;                  @tab-item-click=&quot;tabItemClick&quot;&gt;      &lt;template v-slot=&quot;props&quot;&gt;        &lt;button&gt;&#123;&#123; props.item &#125;&#125;&lt;/button&gt;      &lt;/template&gt;    &lt;/tab-control&gt;    &lt;!-- 4.如果只有一个默认插槽, 那么template可以省略 --&gt;    &lt;tab-control :titles=&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;                  @tab-item-click=&quot;tabItemClick&quot;                 v-slot=&quot;props&quot;&gt;      &lt;button&gt;&#123;&#123; props.item &#125;&#125;&lt;/button&gt;    &lt;/tab-control&gt;  &lt;/div&gt;&lt;/template&gt;\n\n59.非父子组件之间的通信1.全局的事件总线\nvue3中移除了$on,$off,$once方法，如果需要使用事件总线，可以使用第三方库，或者通过自己写的事件总线方法。事件总线不经可以用于非父子组件的通信，也可以用于任意组件的通信\n//event-bus.js  事件总线初始化import &#123; HYEventBus &#125; from &#x27;hy-event-store&#x27;const eventBus = new HYEventBus()export default eventBus\n\n//App.vue   在created声明周期中监听事件created() &#123;      // fetch()      // 事件监听      eventBus.on(&quot;whyEvent&quot;, (name, age, height) =&gt; &#123;        console.log(&quot;whyEvent事件在app中监听&quot;, name, age, height)        this.message = `name:$&#123;name&#125;, age:$&#123;age&#125;, height:$&#123;height&#125;`      &#125;)    &#125;\n\n//在Category.vue中 created中监听，在unmounted中移出事件import eventBus from &#x27;./utils/event-bus&#x27;export default &#123;  methods: &#123;    whyEventHandler() &#123;      console.log(&quot;whyEvent在category中监听&quot;)    &#125;  &#125;,  created() &#123;    eventBus.on(&quot;whyEvent&quot;, this.whyEventHandler)  &#125;,  unmounted() &#123;    console.log(&quot;category unmounted&quot;)    eventBus.off(&quot;whyEvent&quot;, this.whyEventHandler)  &#125;&#125;\n\n//HomeBanner.vue  emit事件import eventBus from &#x27;./utils/event-bus&#x27; export default &#123;   methods: &#123;     bannerBtnClick() &#123;       console.log(&quot;bannerBtnClick&quot;)       eventBus.emit(&quot;whyEvent&quot;, &quot;why&quot;, 18, 1.88)     &#125;   &#125; &#125;\n\n2.Provide&#x2F;inject\nprovide和inject可以用于跨组件的通信\n//App.vue// provide一般都是写成函数 也可以写成对象，如果需要使用data中的属性，必须使用函数形式   provide() &#123;     return &#123;       name: &quot;why&quot;,       age: 18,       //默认不是响应式的，如果需要变成响应式的，要使用computed，computed的返回值是一个ref对象，需要使用.value来获取       message: computed(() =&gt; this.message)//要写箭头函数，箭头函数的this是由上层作用域来决定的     &#125;   &#125; &#125;\n\n&lt;template&gt;  &lt;div class=&quot;banner&quot;&gt;    &lt;h2&gt;HomeBanner: &#123;&#123; name &#125;&#125; - &#123;&#123; age &#125;&#125; - &#123;&#123;message.value&#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    inject: [&quot;name&quot;, &quot;age&quot;, &quot;message&quot;]  &#125;&lt;/script&gt;\n\n60.组件的生命周期\n父子组件的挂载过程\n父组件beforeCreate -&gt;父组件created-&gt;父组件beforemount-&gt;子组件beforeCreate-&gt;子组件created-&gt; 子组件beforeMount-&gt;子组件mounted-&gt;父组件mounted\n61.$refs的使用通过$refs可以获取到子元素或者子组件\n通过this.$refs.refName可以获取到子组件实例，子组件实例是一个Proxy代理，vue组件是一个对象类似于一个class，根据class创建一个组件实例，通过this.$refs.refname.$el可以获取到组件DOM元素。，this.$parent获取到父组件元素，this.$root获取到根组件元素，$ref还可以调用子组件的属性和方法在Vue3中已经移除了$children的属性\n如果template中由多个根，拿到的是第一个node节点\n\n62.动态组件is中的组件只能是局部已注册的组件和全局组件\n&lt;component name=&quot;why&quot;                  :age=&quot;18&quot;                 @homeClick=&quot;homeClick&quot;                 :is=&quot;currentTab&quot;&gt;&lt;/component&gt;\n\n63.组件缓存keep-alive如果组件频繁的切换会造成性能消耗增加，如果需要保存组件切换之前的状态，可以使用keep-alive，他通常和Component动态组件一起使用\n&lt;div class=&quot;view&quot;&gt;      &lt;!-- include: 组件的名称来自于组件内部定义时name选项  --&gt;      &lt;keep-alive include=&quot;home,about&quot;&gt;        &lt;component :is=&quot;currentTab&quot;&gt;&lt;/component&gt;      &lt;/keep-alive&gt;    &lt;/div&gt;\n\ninclude&#x2F;exclude&lt;KeepAlive&gt; 默认会缓存内部的所有组件实例，但我们可以通过 include 和 exclude prop 来定制该行为。这两个 prop 的值都可以是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两种类型的一个数组：\n&lt;!-- 以英文逗号分隔的字符串 --&gt;&lt;KeepAlive include=&quot;a,b&quot;&gt;  &lt;component :is=&quot;view&quot; /&gt;&lt;/KeepAlive&gt;&lt;!-- 正则表达式 (需使用 `v-bind`) --&gt;&lt;KeepAlive :include=&quot;/a|b/&quot;&gt;  &lt;component :is=&quot;view&quot; /&gt;&lt;/KeepAlive&gt;&lt;!-- 数组 (需使用 `v-bind`) --&gt;&lt;KeepAlive :include=&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&gt;  &lt;component :is=&quot;view&quot; /&gt;&lt;/KeepAlive&gt;\n\n它会根据组件的 name 选项进行匹配，所以组件如果想要条件性地被 KeepAlive 缓存，就必须显式声明一个 name 选项\nTIP\n在 3.2.34 或以上的版本中，使用 &lt;script setup&gt; 的单文件组件会自动根据文件名生成对应的 name 选项，无需再手动声明。\n最大缓存实例数[#](https://cn.vuejs.org/guide/built-ins/keep-alive.html#max-cached-instances我们可以通过传入 max prop 来限制可被缓存的最大组件实例数。&lt;KeepAlive&gt; 的行为在指定了 max 后类似一个 LRU 缓存：如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。\n&lt;KeepAlive :max=&quot;10&quot;&gt;  &lt;component :is=&quot;activeComponent&quot; /&gt;&lt;/KeepAlive&gt;\n\n缓存实例的生命周期\nexport default &#123;  activated() &#123;    // 在首次挂载、    // 以及每次从缓存中被重新插入的时候调用  &#125;,  deactivated() &#123;    // 在从 DOM 上移除、进入缓存    // 以及组件卸载时调用  &#125;&#125;\n\n","categories":["vue","note"]},{"title":"Vue3笔记(二)","url":"/2022/08/18/Vue3%E7%AC%94%E8%AE%B0-%E4%BA%8C/","content":"64.异步组件vue2中的异步组件是使用import().then()来实现的\nvue3中提供了函数defineAsyncComponent来实现异步组件，这这样可以对组件进行分包处理，不会打包到一个文件中，而是单独打到一个包中\n//方法一 因为这种方式也会返回一个promiseconst AsyncCategory = defineAsyncComponent(() =&gt; import(&quot;./views/Category.vue&quot;))\n\n//方法二import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    // ...从服务器获取组件    resolve(/* 获取到的组件 */)  &#125;)&#125;)// ... 像使用其他一般组件一样使用 `AsyncComp`\n\ndefineAsyncComponent 方法接收一个返回 Promise 的加载函数。这个 Promise 的 resolve 回调方法应该在从服务器获得组件定义时调用。你也可以调用 reject(reason) 表明加载失败。\n全局注册方式\napp.component(&#x27;MyComponent&#x27;, defineAsyncComponent(() =&gt;  import(&#x27;./components/MyComponent.vue&#x27;)))\n\ndefineAsyncComponent的高级选项\nconst AsyncComp = defineAsyncComponent(&#123;  // 加载函数  loader: () =&gt; import(&#x27;./Foo.vue&#x27;),  // 加载异步组件时使用的组件  loadingComponent: LoadingComponent,  // 展示加载组件前的延迟时间，默认为 200ms  delay: 200,  // 加载失败后展示的组件  errorComponent: ErrorComponent,  // 如果提供了一个 timeout 时间限制，并超时了  // 也会显示这里配置的报错组件，默认值是：Infinity  timeout: 3000&#125;)\n\n65.组件中的v-model可以对组件进行双向数据绑定\n\n将内部原生 input 元素的 value attribute 绑定到 modelValue prop\n输入新的值时在 input 元素上触发 update:modelValue 事件\n\n//App.js&lt;CustomInput  :modelValue=&quot;searchText&quot;  @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;/&gt;\n\n&lt;!-- CustomInput.vue --&gt;&lt;script&gt;export default &#123;  props: [&#x27;modelValue&#x27;],  emits: [&#x27;update:modelValue&#x27;]&#125;&lt;/script&gt;&lt;template&gt;  &lt;input    :value=&quot;modelValue&quot;    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;  /&gt;&lt;/template&gt;\n\n&lt;CustomInput v-model=&quot;searchText&quot; /&gt;//这是上面的简写 v-model就可以使用了\n\n方式二。使用computed来实现v-model\n&lt;!-- CustomInput.vue --&gt;&lt;script&gt;export default &#123;  props: [&#x27;modelValue&#x27;],  emits: [&#x27;update:modelValue&#x27;],  computed: &#123;    value: &#123;      get() &#123;        return this.modelValue      &#125;,      set(value) &#123;        this.$emit(&#x27;update:modelValue&#x27;, value)      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;value&quot; /&gt;&lt;/template&gt;\n\nv-model的参数是可以修改的\n&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;  //在组件中修改props的值还有emits的值为title和update:title\n\n多个 v-model 绑定&lt;UserName  v-model:first-name=&quot;first&quot;  v-model:last-name=&quot;last&quot;/&gt;\n\n&lt;script&gt;export default &#123;  props: &#123;    firstName: String,    lastName: String  &#125;,  emits: [&#x27;update:firstName&#x27;, &#x27;update:lastName&#x27;]&#125;&lt;/script&gt;&lt;template&gt;  &lt;input    type=&quot;text&quot;    :value=&quot;firstName&quot;    @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;  /&gt;  &lt;input    type=&quot;text&quot;    :value=&quot;lastName&quot;    @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;  /&gt;&lt;/template&gt;\n\n处理 v-model 修饰符我们来创建一个自定义的修饰符 capitalize，它会自动将 v-model 绑定输入的字符串值第一个字母转为大写：\n&lt;MyComponent v-model.capitalize=&quot;myText&quot; /&gt;\n\n组件的 v-model 上所添加的修饰符，可以通过 modelModifiers prop 在组件内访问到。在下面的组件中，我们声明了 modelModifiers 这个 prop，它的默认值是一个空对象\n&lt;script&gt;export default &#123;  props: &#123;    modelValue: String,    modelModifiers: &#123;      default: () =&gt; (&#123;&#125;)    &#125;  &#125;,  emits: [&#x27;update:modelValue&#x27;],  created() &#123;    console.log(this.modelModifiers) // &#123; capitalize: true &#125;  &#125;&#125;&lt;/script&gt;&lt;template&gt;  &lt;input    type=&quot;text&quot;    :value=&quot;modelValue&quot;    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;  /&gt;&lt;/template&gt;\n\n注意这里组件的 modelModifiers prop 包含了 capitalize 且其值为 true，因为它在模板中的 v-model 绑定上被使用了。\n有了 modelModifiers 这个 prop，我们就可以在原生事件侦听函数中检查它的值，然后决定触发的自定义事件中要向父组件传递什么值。在下面的代码里，我们就是在每次 &lt;input&gt; 元素触发 input 事件时将值的首字母大写：\n&lt;script&gt;export default &#123;  props: &#123;    modelValue: String,    modelModifiers: &#123;      default: () =&gt; (&#123;&#125;)    &#125;  &#125;,  emits: [&#x27;update:modelValue&#x27;],  methods: &#123;    emitValue(e) &#123;      let value = e.target.value      if (this.modelModifiers.capitalize) &#123;        value = value.charAt(0).toUpperCase() + value.slice(1)      &#125;      this.$emit(&#x27;update:modelValue&#x27;, value)    &#125;  &#125;&#125;&lt;/script&gt;&lt;template&gt;  &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot; /&gt;&lt;/template&gt;\n\n对于又有参数又有修饰符的 v-model 绑定，生成的 prop 名将是 arg + &quot;Modifiers&quot;。举例来说：\n&lt;MyComponent v-model:title.capitalize=&quot;myText&quot;&gt;\n\nexport default &#123;  props: [&#x27;title&#x27;, &#x27;titleModifiers&#x27;],  emits: [&#x27;update:title&#x27;],  created() &#123;    console.log(this.titleModifiers) // &#123; capitalize: true &#125;  &#125;&#125;\n\n66.mixins局部混入的写法\nconst mixin = &#123;  created() &#123;    console.log(1)  &#125;&#125;createApp(&#123;  created() &#123;    console.log(2)  &#125;,  mixins: [mixin]&#125;)// =&gt; 1// =&gt; 2\n\nMixin 钩子的调用顺序与提供它们的选项顺序相同，且会在组件自身的钩子前被调用\n在 Vue 2 中，mixins 是创建可重用组件逻辑的主要方式。尽管在 Vue 3 中保留了 mixins 支持，但对于组件间的逻辑复用，Composition API 是现在更推荐的方式。\napp.mixin()全局的混入 但是vue3不推荐使用\n67.setup()函数setup函数有两个参数：props,context,在setup函数里面不能使用this\ncontext参数包含3个属性：\nattrs：所有非props的attribute\nslots:父组件传递过来的插槽\nemit\nexport default &#123;  setup(props, context) &#123;    // 透传 Attributes（非响应式的对象，等价于 $attrs）    console.log(context.attrs)    // 插槽（非响应式的对象，等价于 $slots）    console.log(context.slots)    // 触发事件（函数，等价于 $emit）    console.log(context.emit)    // 暴露公共属性（函数）    console.log(context.expose)  &#125;&#125;\n\ncontext是非响应性的，可以进行解构\nexport default &#123;  setup(props, &#123; attrs, slots, emit, expose &#125;) &#123;    ...  &#125;&#125;\n\nattrs 和 slots 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性。此外还需注意，和 props 不同，attrs 和 slots 的属性都不是响应式的。如果你想要基于 attrs 或 slots 的改变来执行副作用，那么你应该在 onBeforeUpdate 生命周期钩子中编写相关逻辑。\nsetup可以有返回值，可以在template中使用\nsetup 函数的第一个参数是组件的 props。和标准的组件一致，一个 setup 函数的 props 是响应式的，并且会在传入新的 props 时同步更新。\nexport default &#123;  props: &#123;    title: String  &#125;,  setup(props) &#123;    console.log(props.title)  &#125;&#125;\n\n如果解构props会使数据失去响应性，如果需要结构请使用toRef()&#x2F;toRefs()\nimport &#123; toRefs, toRef &#125; from &#x27;vue&#x27;export default &#123;  setup(props) &#123;    // 将 `props` 转为一个其中全是 ref 的对象，然后解构    const &#123; title &#125; = toRefs(props)    // `title` 是一个追踪着 `props.title` 的 ref    console.log(title.value)    // 或者，将 `props` 的单个属性转为一个 ref    const title = toRef(props, &#x27;title&#x27;)  &#125;&#125;\n\n请注意在模板中访问从 setup 返回的 ref 时，它会自动浅层解包，因此你无须再在模板中为它写 .value。当通过 this 访问时也会同样如此解包。\nTIP\nsetup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。\n暴露公共属性expose 函数用于显式地限制该组件暴露出的属性，当父组件通过模板引用访问该组件的实例时，将仅能访问 expose 函数暴露出的内容：\nexport default &#123;  setup(props, &#123; expose &#125;) &#123;    // 让组件实例处于 “关闭状态”    // 即不向父组件暴露任何东西    expose()    const publicCount = ref(0)    const privateCount = ref(0)    // 有选择地暴露局部状态    expose(&#123; count: publicCount &#125;)  &#125;&#125;\n\n与渲染函数一起使用#setup 也可以返回一个渲染函数，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：\nimport &#123; h, ref &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    const count = ref(0)    return () =&gt; h(&#x27;div&#x27;, count.value)  &#125;&#125;\n\nimport &#123; h, ref &#125; from &#x27;vue&#x27;export default &#123;  setup(props, &#123; expose &#125;) &#123;    const count = ref(0)    const increment = () =&gt; ++count.value    expose(&#123;      increment    &#125;)    return () =&gt; h(&#x27;div&#x27;, count.value)  &#125;&#125;\n\n68. reactive apireactive可以将对象变成响应式对象  ，返回一个对象的响应式代理\nconst account = reactive(&#123;      username: &quot;coderwhy&quot;,      password: &quot;1234567&quot;    &#125;)\n\nreactive转换是深层的，他会影响所有的嵌套属性，reactive也会深层的解包所有ref属性，同时保持响应性\n值得注意的是，当访问到某个响应式数组或 Map 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包。意思是\n若要避免深层响应式转换，只想保留对这个对象顶层次访问的响应性，请使用 shallowReactive() 作替代\n返回的对象以及其中嵌套的对象都会通过 ES Proxy 包裹，因此不等于源对象，建议只使用响应式代理，避免使用原始对象。\nref 的解包：\nconst count = ref(1)const obj = reactive(&#123; count &#125;)// ref 会被解包console.log(obj.count === count.value) // true// 会更新 `obj.count`count.value++console.log(count.value) // 2console.log(obj.count) // 2// 也会更新 `count` refobj.count++console.log(obj.count) // 3console.log(count.value) // 3\n\n注意当访问到某个响应式数组或 Map 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包：\nconst books = reactive([ref(&#x27;Vue 3 Guide&#x27;)])// 这里需要 .valueconsole.log(books[0].value)const map = reactive(new Map([[&#x27;count&#x27;, ref(0)]]))// 这里需要 .valueconsole.log(map.get(&#x27;count&#x27;).value)\n\n将一个 ref 赋值给为一个 reactive 属性时，该 ref 会被自动解包：\nconst count = ref(1)const obj = reactive(&#123;&#125;)obj.count = countconsole.log(obj.count) // 1console.log(obj.count === count.value) // true\n\n69.ref apiref 可以定义任何数据类型\nref会返回一个可变的响应式对象，该对象作为一个响应式的引用维护它内部的值,\nconst info = ref(&#123;&#125;)console.log(info.value)\n\n在模板中使用ref的值，vue会自动帮助我们进行解包不需要使用.value,但是在setup函数内部，还是一个ref引用，必须使用.value的方式。在模板中的解包是浅层的解包\n// 2.定义从网络中获取的数据也是使用ref      // const musics = reactive([])      const musics = ref([])      onMounted(() =&gt; &#123;        const serverMusics = [&quot;海阔天空&quot;, &quot;小苹果&quot;, &quot;野狼&quot;]        musics.value = serverMusics      &#125;)\n\n70.readonly()传入一个对象，无论是响应式还是普通对象，还是ref对象，会返回一个对象的只读代理\n可以用于给子组件传递数据的时候，不允许修改父组件传递的值，，readonly他会劫持proxy中的set方法，不允许修改\n只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 reactive() 相同，但解包得到的值是只读的。\nconst original = reactive(&#123; count: 0 &#125;)const copy = readonly(original)watchEffect(() =&gt; &#123;  // 用来做响应性追踪  console.log(copy.count)&#125;)// 更改源属性会触发其依赖的侦听器original.count++// 更改该只读副本将会失败，并会得到一个警告copy.count++ // warning!\n\n其实本质上就是readonly返回的对象的setter方法被劫持了而已\n71.reactive判断的apiisProxy​\t检查对象是否是由reactive或者readonly创建的proxy\nisReactive检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理\n如果该代理是readonly创建的，但是包裹了由reactive创建的另外一个代理，他也会返回true\nisReadonly检查一个对象是否是由 readonly() 或 shallowReadonly() 创建的代理。\ntoRow 返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）。\nshallowReactive创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)。\nshallowReadonly创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）\n72 toRefs如果使用es6的解构语法对reactive返回的对象进行解构，解构后获得的变量不是响应式的，可以使用toRefs将解构后的值变成响应式的\nconst info = reactive(&#123;         name: &quot;why&quot;,         age: 18,         height: 1.88       &#125;)       // reactive被解构后会变成普通的值, 失去响应式       const &#123; name, age &#125; = toRefs(info)\n\ntoRefs 在调用时只会为源对象上可以枚举的属性创建 ref。如果要为可能还不存在的属性创建 ref，请改用 toRef。\n73.toRef将一个reactive对象的属性变成响应式的\nconst state = reactive(&#123;  foo: 1,  bar: 2&#125;)const fooRef = toRef(state, &#x27;foo&#x27;)// 更改该 ref 会更新源属性fooRef.value++console.log(state.foo) // 2// 更改源属性也会更新该 refstate.foo++console.log(fooRef.value) // 3\n\n请注意，这不同于：\nconst fooRef = ref(state.foo)\n\n上面这个 ref 不会和 state.foo 保持同步，因为这个 ref() 接收到的是一个纯数值。\n74. ref其他apiunref如果我们想要获取一个ref引用中的value，那么也可以通过unref方法：  如果参数是一个 ref，则返回内部值，否则返回参数本身；  这是 val &#x3D; isRef(val) ? val.value : val 的语法糖函数\nisRef判断值是否是一个ref对象。\nshallowRef创建一个浅层的ref对象\ntriggerRef手动触发和 shallowRef 相关联的副作用：\n75.computed()接受一个 getter 函数，返回一个只读的响应式 ref 对象。该 ref 通过 .value 暴露 getter 函数的返回值。它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。\nconst count = ref(1)const plusOne = computed(() =&gt; count.value + 1)console.log(plusOne.value) // 2plusOne.value++ // 错误\n\nconst count = ref(1)const plusOne = computed(&#123;  get: () =&gt; count.value + 1,  set: (val) =&gt; &#123;    count.value = val - 1  &#125;&#125;)plusOne.value = 1console.log(count.value) // 0\n\n76.在setup中获取组件实例&lt;show-info ref=&quot;showInfoRef&quot;&gt;&lt;/show-info&gt;setup()&#123;\tconst showInfoRef=ref()\treturn &#123;\t\tshowInfoRef\t&#125;&#125;\n\n77.在setup中使用生命周期钩子函数onBeforeMount\nonMounted\nonBeforeUpdate\nonUpdated\nonBeforeUnmounted\nonUnounted\nonActivited\nonDeactivited\n78.provide\n与注册生命周期钩子的 API 类似，provide() 必须在组件的 setup() 阶段同步调用。\n&lt;script setup&gt;import &#123; ref, provide &#125; from &#x27;vue&#x27;import &#123; fooSymbol &#125; from &#x27;./injectionSymbols&#x27;// 提供静态值provide(&#x27;foo&#x27;, &#x27;bar&#x27;)// 提供响应式的值const count = ref(0)provide(&#x27;count&#x27;, count)// 提供时将 Symbol 作为 keyprovide(fooSymbol, count)&lt;/script&gt;\n\n79.inject()第一个参数是注入的 key。Vue 会遍历父组件链，通过匹配 key 来确定所提供的值。如果父组件链上多个组件对同一个 key 提供了值，那么离得更近的组件将会“覆盖”链上更远的组件所提供的值。如果没有能通过 key 匹配到值，inject() 将返回 undefined，除非提供了一个默认值。\n第二个参数是可选的，即在没有匹配到 key 时使用的默认值。它也可以是一个工厂函数，用来返回某些创建起来比较复杂的值。如果默认值本身就是一个函数，那么你必须将 false 作为第三个参数传入，表明这个函数就是默认值，而不是一个工厂函数。\n与注册生命周期钩子的 API 类似，inject() 必须在组件的 setup() 阶段同步调用。\n&lt;script setup&gt;import &#123; inject &#125; from &#x27;vue&#x27;import &#123; fooSymbol &#125; from &#x27;./injectionSymbols&#x27;// 注入值的默认方式const foo = inject(&#x27;foo&#x27;)// 注入响应式的值const count = inject(&#x27;count&#x27;)// 通过 Symbol 类型的 key 注入const foo2 = inject(fooSymbol)// 注入一个值，若为空则使用提供的默认值const bar = inject(&#x27;foo&#x27;, &#x27;default value&#x27;)// 注入一个值，若为空则使用提供的工厂函数const baz = inject(&#x27;foo&#x27;, () =&gt; new Map())// 注入时为了表明提供的默认值是个函数，需要传入第三个参数const fn = inject(&#x27;function&#x27;, () =&gt; &#123;&#125;, false)&lt;/script&gt;\n\n80.watch()watch的api和option API中的watch类似\nwatch需要监听特定的数据源，并且执行其回调函数，默认情况下，他是惰性的，在初始化情况下不执行，只有在数据变化时才执行\nwatch() 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。\n第一个参数是侦听器的源。这个来源可以是以下几种：\n\n一个函数，返回一个值\n一个 ref\n一个响应式对象\n…或是由以上类型的值组成的数组\n\n第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。\n当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。\n第三个可选的参数是一个对象，支持以下这些选项：\n\n**immediate**：在侦听器创建时立即触发回调。第一次调用时旧值是 undefined。\n\n**deep**：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。参考深层侦听器一节。\n\n**flush**：调整回调函数的刷新时机。参考回调的刷新时机一节。\n\n**onTrack / onTrigger**：调试侦听器的依赖,参考调试侦听器一节。\n\n\n与 watchEffect() 相比，watch() 使我们可以：\n\n懒执行副作用；\n更加明确是应该由哪个状态触发侦听器重新执行；\n可以访问所侦听状态的前一个值和当前值。\n\n侦听一个 getter 函数：\nconst state = reactive(&#123; count: 0 &#125;)watch(  () =&gt; state.count,  (count, prevCount) =&gt; &#123;    /* ... */  &#125;)\n\n侦听一个 ref：\nconst count = ref(0)watch(count, (count, prevCount) =&gt; &#123;  /* ... */&#125;)\n\n当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值：\nwatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; &#123;  /* ... */&#125;)\n\n当使用 getter 函数作为源时，回调只在此函数的返回值变化时才会触发。如果你想让回调在深层级变更时也能触发，你需要使用 &#123; deep: true &#125; 强制侦听器进入深层级模式。在深层级模式时，如果回调函数由于深层级的变更而被触发，那么新值和旧值将是同一个对象。\nconst state = reactive(&#123; count: 0 &#125;)watch(  () =&gt; state,  (newValue, oldValue) =&gt; &#123;    // newValue === oldValue  &#125;,  &#123; deep: true,immediate:true//在创建的时候执行一次 &#125;)\n\n当直接侦听一个响应式对象时，侦听器会自动启用深层模式：\nconst state = reactive(&#123; count: 0 &#125;)watch(state, () =&gt; &#123;  /* 深层级变更状态所触发的回调 */&#125;)\n\nwatch() 和 watchEffect() 享有相同的刷新时机和调试选项：\nwatch(source, callback, &#123;  flush: &#x27;post&#x27;,  onTrack(e) &#123;    debugger  &#125;&#125;)\n\n81.watchEffect()立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。\n\n第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。\n第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。\n返回值是一个用来停止该副作用的函数。\n\n示例\nconst count = ref(0)watchEffect(() =&gt; console.log(count.value))// -&gt; 输出 0count.value++// -&gt; 输出 1\n\n副作用清除：\nwatchEffect(async (onCleanup) =&gt; &#123;  const &#123; response, cancel &#125; = doAsyncWork(id.value)  // `cancel` 会在 `id` 更改时调用  // 以便取消之前  // 未完成的请求  onCleanup(cancel)  data.value = await response&#125;)\n\n停止侦听器：\nconst stop = watchEffect(() =&gt; &#123;&#125;)// 当不再需要此侦听器时:stop()\n\n选项：\nwatchEffect(() =&gt; &#123;&#125;, &#123;  flush: &#x27;post&#x27;,  onTrack(e) &#123;    debugger  &#125;,  onTrigger(e) &#123;    debugger  &#125;&#125;)\n\n82.hooks的封装封装usetitle\n//useTitle.jsimport &#123; ref, watch &#125; from &quot;vue&quot;;//这是闭包函数export default function useTitle(titleValue) &#123;  // document.title = title  // 定义ref的引入数据  const title = ref(titleValue)  // 监听title的改变  watch(title, (newValue) =&gt; &#123;    document.title = newValue  &#125;, &#123;    immediate: true  &#125;)  // 返回ref值  return &#123;    title  &#125;&#125;\n\n //App.vue// 2.修改标题      const &#123; title &#125; = useTitle(&quot;首页&quot;)      // 3.监听按钮的点击  这样修改的是同一个值，不需要重复的调用usetitle(&quot;首页-流行&quot;)      function popularClick() &#123;        title.value = &quot;首页-流行&quot;      &#125;      function hotClick() &#123;        title.value = &quot;首页-热门&quot;      &#125;      function songClick() &#123;        title.value = &quot;首页-歌单&quot;      &#125;\n\n84.单文件组件 &lt;script setup&gt; 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。\n\n- 更少的样板内容，更简洁的代码。\n- 能够使用纯 TypeScript 声明 props 和自定义事件。\n- 更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。\n- 更好的 IDE 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。\n\n&lt;script setup&gt;console.log(&#x27;hello script setup&#x27;)&lt;/script&gt;\n\n与普通的 `` 只在组件被首次引入的时候执行一次不同，`` 中的代码会在**每次组件实例被创建的时候执行**。响应式数据需要使用ref或者reactive来实现\n\n##### 顶层的绑定会被暴露给模板[#](https://cn.vuejs.org/api/sfc-script-setup.html#top-level-bindings-are-exposed-to-template)\n\n当使用 `` 的时候，任何在 `` 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用：\n\n&lt;script setup&gt;// 变量const msg = &#x27;Hello!&#x27;// 函数function log() &#123;  console.log(msg)&#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;log&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/button&gt;&lt;/template&gt;\n\nimport 导入的内容也会以同样的方式暴露。这意味着我们可以在模板表达式中直接使用导入的 helper 函数，而不需要通过 `methods` 选项来暴露它：\n\n&lt;script setup&gt;import &#123; capitalize &#125; from &#x27;./helpers&#x27;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; capitalize(&#x27;hello&#x27;) &#125;&#125;&lt;/div&gt;&lt;/template&gt;\n\n##### 组件的使用\n\n组件直接导入即可，不需要注册\n\n&lt;script setup&gt;import MyComponent from &#x27;./MyComponent.vue&#x27;&lt;/script&gt;&lt;template&gt;  &lt;MyComponent /&gt;&lt;/template&gt;\n\n##### **`defineProps()`**，`defineEmits（）`\n\n用于在``中定义props和emits\n\n&lt;script setup&gt;// 定义propsconst props = defineProps(&#123;  name: &#123;    type: String,    default: &quot;默认值&quot;  &#125;,  age: &#123;    type: Number,    default: 0  &#125;&#125;)// 绑定函数, 并且发出事件const emits = defineEmits([&quot;infoBtnClick&quot;])function showInfoBtnClick() &#123;  emits(&quot;infoBtnClick&quot;, &quot;showInfo内部发生了点击&quot;)&#125;// 定义foo的函数function foo() &#123;  console.log(&quot;foo function&quot;)&#125;defineExpose(&#123;  foo&#125;)&lt;/script&gt;\n\n##### `defineExpose`\n\n使用 `` 的组件是**默认关闭**的——即通过模板引用或者 `$parent` 链获取到的组件的公开实例，**不会**暴露任何在 `` 中声明的绑定。\n\n可以通过 `defineExpose` 编译器宏来显式指定在 `` 组件中要暴露出去的属性：\n\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const a = 1const b = ref(2)defineExpose(&#123;  a,  b&#125;)&lt;/script&gt;\n","categories":["vue","note"]},{"title":"ajax笔记","url":"/2022/09/08/ajax%E7%AC%94%E8%AE%B0/","content":"##ajax的封装function ajax(&#123;  url,  method = &quot;get&quot;,  data = &#123;&#125;,  headers = &#123;&#125;,  success,  failure,&#125; = &#123;&#125;) &#123;  // 1.创建对象  const xhr = new XMLHttpRequest();  // 2.监听数据  xhr.onload = function () &#123;    if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123;      // xhr.responseXML/xhr.responseText      success &amp;&amp; success(xhr.response);    &#125; else &#123;      failure &amp;&amp; failure(&#123; status: xhr.status, message: xhr.statusText &#125;);    &#125;  &#125;;  // 现在返回的数据类型一般都是json,如果设置为空字符串则会使用text作为默认值  // 3.设置类型  xhr.responseType = &quot;json&quot;;  // xhr.responseType=&quot;xml&quot;/blob/text/arraybuffer等  // 4.设置过期超时事件  xhr.timeout = timeout;  // 5.open方法  if (method.toUpperCase() === &quot;GET&quot;) &#123;    const queryString = [];    for (const key in data) &#123;      if (Object.hasOwnProperty.call(data, key)) &#123;        const item = data[key];        queryString.push(`$&#123;key&#125;=$&#123;item&#125;`);      &#125;    &#125;    url = url + &quot;?&quot; + queryString.join(&quot;&amp;&quot;);    xhr.open(method, url);  &#125; else &#123;    // post    xhr.open(method, url);    xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/json&quot;);  &#125;  // 6设置headers  if (Object.keys(headers).length &gt; 0) &#123;    Object.keys(headers).forEach((key) =&gt; &#123;      xhr.setRequestHeader(key, headers[key]);    &#125;);  &#125;  if (method.toUpperCase === &quot;POST&quot;) &#123;    xhr.send(JSON.stringify(data));  &#125; else if (method.toUpperCase === &quot;GET&quot;) &#123;    xhr.send();  &#125;  // return xhr可以用于调用abort()方法进行终止请求  return xhr;&#125;\n\najax的promise的封装function ajax(&#123; url, method = &quot;get&quot;, data = &#123;&#125;, headers = &#123;&#125; &#125; = &#123;&#125;) &#123;  // 1.创建对象  const xhr = new XMLHttpRequest();  const promise = new Promise((resolve, reject) =&gt; &#123;    // 2.监听数据    xhr.onload = function () &#123;      if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123;        // xhr.responseXML/xhr.responseText        resolve(xhr.response);      &#125; else &#123;        reject(&#123; status: xhr.status, message: xhr.statusText &#125;);      &#125;    &#125;;    // 现在返回的数据类型一般都是json,如果设置为空字符串则会使用text作为默认值    // 3.设置类型    xhr.responseType = &quot;json&quot;;    // xhr.responseType=&quot;xml&quot;/blob/text/arraybuffer等    // 4.设置过期超时事件    xhr.timeout = timeout;    // 5.open方法    if (method.toUpperCase() === &quot;GET&quot;) &#123;      const queryString = [];      for (const key in data) &#123;        if (Object.hasOwnProperty.call(data, key)) &#123;          const item = data[key];          queryString.push(`$&#123;key&#125;=$&#123;item&#125;`);        &#125;      &#125;      url = url + &quot;?&quot; + queryString.join(&quot;&amp;&quot;);      xhr.open(method, url);    &#125; else &#123;      // post      xhr.open(method, url);      xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/json&quot;);    &#125;    // 6设置headers    if (Object.keys(headers).length &gt; 0) &#123;      Object.keys(headers).forEach((key) =&gt; &#123;        xhr.setRequestHeader(key, headers[key]);      &#125;);    &#125;    if (method.toUpperCase === &quot;POST&quot;) &#123;      xhr.send(JSON.stringify(data));    &#125; else if (method.toUpperCase === &quot;GET&quot;) &#123;      xhr.send();    &#125;  &#125;);  // return xhr可以用于调用abort()方法进行终止请求  promise.xhr = xhr;  return promise;&#125;\n\n","categories":["计算机网络","Ajax"]},{"title":"call函数的实现","url":"/2022/09/07/call%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"Function.prototype.MyCall = function (thisArg, ...args) &#123;  const fn = this;  thisArg = thisArg != null ? Object(thisArg) : globalThis; //Object(thisArg)如果是基本类型将会将换成包装类，globalThis分别对应window/node的环境  args = args || [];  thisArg.fn = fn;  const result = thisArg.fn(...args);  delete thisArg.fn;  return result;&#125;;function foo() &#123;  console.log(&quot;foo函数被执行&quot;, this);&#125;function sum(num1, num2) &#123;  console.log(&quot;sum函数被执行&quot;, this, num1, num2);  return num1 + num2;&#125;foo.call(undefined);var result = sum.call(&#123;&#125;, 20, 30);// console.log(&quot;系统调用的结果:&quot;, result)// 自己实现的函数的hycall方法// 默认进行隐式绑定// foo.hycall(&#123;name: &quot;why&quot;&#125;)foo.MyCall(undefined);var result = sum.MyCall(&quot;abc&quot;, 20, 30);console.log(&quot;hycall的调用:&quot;, result);\n\n","categories":["javascript","原理"]},{"title":"canvas笔记","url":"/2022/10/12/canvas%E7%AC%94%E8%AE%B0/","content":""},{"title":"electron 安装问题","url":"/2022/09/11/electron-%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/","content":"$ npm install electron --save-devnpm ERR! code 1npm ERR! path C:\\Users\\10152\\Desktop\\study\\代码碎屑\\electron练习\\my-electron-app\\node_modules\\electronnpm ERR! command failednpm ERR! command C:\\WINDOWS\\system32\\cmd.exe /d /s /c node install.jsnpm ERR! RequestError: read ECONNRESETnpm ERR!     at ClientRequest.&lt;anonymous&gt; (C:\\Users\\10152\\Desktop\\study\\代码碎屑\\electron练习\\my-electron-app\\node_modules\\got\\source\\request-as-event-emitter.js:178:14)npm ERR!     at Object.onceWrapper (node:events:642:26)npm ERR!     at ClientRequest.emit (node:events:539:35)npm ERR!     at ClientRequest.origin.emit (C:\\Users\\10152\\Desktop\\study\\代码碎屑\\electron练习\\my-electron-app\\node_modules\\@szmarczak\\http-timer\\source\\index.js:37:11)npm ERR!     at TLSSocket.socketErrorListener (node:_http_client:454:9)npm ERR!     at TLSSocket.emit (node:events:527:28)npm ERR!     at emitErrorNT (node:internal/streams/destroy:157:8)npm ERR!     at emitErrorCloseNT (node:internal/streams/destroy:122:3)npm ERR!     at processTicksAndRejections (node:internal/process/task_queues:83:21)npm ERR! A complete log of this run can be found in:npm ERR!     D:\\nodejs\\node_cache\\_logs\\2022-09-10T16_55_35_246Z-debug-0.log\n\neletron安装不成功可以设置下源\nnpm config set ELECTRON_MIRROR https://npmmirror.com/mirrors/electron/\n\n\n\nelectron 控制台中文乱码问题&quot;scripts&quot;: &#123;   &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,   &quot;start&quot;: &quot;chcp 65001 &amp;&amp; electron .&quot; &#125;,\n\n","categories":["Electron","note"]},{"title":"fetch笔记","url":"/2022/09/08/fetch%E7%AC%94%E8%AE%B0/","content":"","categories":["计算机网络","fetch"]},{"title":"gulp学习","url":"/2022/09/08/gulp%E5%AD%A6%E4%B9%A0/","content":"","categories":["常用构建工具","glup"]},{"title":"Hello World","url":"/2022/10/13/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"http2了解","url":"/2022/09/08/http2%E4%BA%86%E8%A7%A3/","content":"","categories":["计算机网络","HTTP"]},{"title":"http3了解","url":"/2022/09/09/http3%E4%BA%86%E8%A7%A3/","content":"","categories":["计算机网络","HTTP"]},{"title":"https了解","url":"/2022/09/09/https%E4%BA%86%E8%A7%A3/","content":""},{"title":"牛客网收集面试题答案","url":"/2022/08/04/interview01/","content":"1.说一说cookie sessionStorage localStorage 区别？我的回答：cookie的大小只有4k,cookie是在浏览器中存储的，分为两种，内存cookie和硬盘cookie,默认的cookie就是内存cookie,没有设置过期时间，默认情况下就是浏览器关闭，cookie就会被浏览器删除，硬盘cookie是有设置过期时间，在过期时间之前，浏览器关闭，cookie不会被删除。把过期时间设置为负数或者0，可以删除cookie。\nsessionStorage和localStorage不会自动存储，需要手动的存储数据，存储的数据量会比cookie大。sessionStorage只会在本次会话中存储，不会在新的页面中被获取。localStorage在页面关闭并且重新打开时不会被清除，sessionStorage会被清除。在页面内发生跳转不打开新的页面的时候，sessionStorage和localstorage不会被删除，在页面中跳转打开新的页面的时候，sessionStorage不保存，localstorage会保存\n参考答案：得分点 数据存储位置，生命周期，存储大小，写入方式，数据共享，发送请求是否携带，应用场景。相同点Cookie,SessionStorage，LocalStorage都是存储在浏览器本地的，不同点，cookie默认是浏览器关闭时候会被删除，可以设置过期时间，在过期时间内浏览器关闭，cookie不会删除。cookie一般是由服务端写入的，SessionStorage和LocalStorage是在客户端写入的，cookie的生命周期是由服务端设置好的，而LocalStorage是永远存在的，如果没有手动删除。SessionStorage页面关闭会被清除。sessionStorage只会在本次会话中存储，不会在新的页面中被获取，页面内发生跳转不打开新的页面时候，sessionStorage不会被清除，cookie的存储大小为4k,sessionStorage和localStorage存储大小为5M。cookie，sessionStorage,localStorage数据共享都是遵循同源策略原则，SessionStorage还必须限制在同一个页面。前端向后端发送数据的时候，cookie会自动携带，而localStorage和sessionStorage中的数据必须手动添加。应用场景：cookie可以存储登录的验证信息SessionId和token,localStorage通常存储不易变动的数据来减轻服务器的压力，SessionStorage可以用来检测用户是否刷新进入页面，像音乐播放器恢复播放进度条的功能\n2.说一说JS数据类型有哪些,区别是什么？数据类型有Null,undefined,Boolean,Number.String,Symbol,Bigint,Object8种数据类型\n基本数据类型有null,undefined,boolean,number,string,symbol,bigint,引用数据类型包括普通的object，数组，正则，Date对象，Math内置对象，Function对象，包括ES6新增的Map和Set对象\n基本数据类型是存储在栈中，引用数据类型存储在堆中的，引用数据类型在栈中存储了指针，该指针指向存储数据所在的堆内存的起始地址。\nSymbol是ES6中新增的基本数据类型，可以产生一个独一无二的值，作为Object的key。Symbol创建的值具有唯一性，Symbol(key)!&#x3D;&#x3D;Symbol(key),要获取对象中用symbol作为key的属性，必须通过Object.getOwnPropertySymbols(obj)\nBigint也是ES6新增的基本数据类型，来代表超出最大或者最小Number可以表示的值，不可以和Number混用\n判断基本数据类型可以使用typeof 来判断，但是typeof null &#x3D;&#x3D;&#x3D;object typeof function&#x3D;&#x3D;&#x3D;’function’\n无法判断其他引用数据类型，必须使用instanceof来判断\n3.说一说你对闭包的理解？闭包就是内部函数访问外部环境的自由变量，外部变量可以引用另一个函数的内部函数，通过这个内部函数的引用来访问他的上层作用域，如果这个外部变量依然引用着这个函数，所以不会被垃圾回收器回收，而导致内存泄露。闭包可以模仿块级作用域，能够实现函数柯里化，在构造函数中使用特权方法，Vue中数据响应式Observer使用了闭包\n4.说一说promise是什么与使用方法？Promise是异步微任务，new Promise是同步执行，new Promise().then()是异步的，promise解决了异步多层嵌套回调，造成回调地狱的问题，让代码的可读性增加，更加容易维护。\npromise的使用：通过new Promise()创建一个实例，传入一个包含resolve,reject作为参数的函调函数，执行成功是使用resolve(),执行失败是使用reject,promsie有三种状态，padding ,rejected,fulfilled,当状态发生改变的时候，就不会再更改，所以fulfilled状态执行resolve，rejected状态执行reject,然后会调用实例方法then(),then是异步调用，有两个回调函数，第一个是成功的回调，另外一个是失败的回调，失败的回调也可以链式调用使用catch传入失败的回调，promise.finally()不管成功还是失败都会执行，promsie中的类方法，Promsie.resolve()转换成fulfilled状态，并将参数传给then,Promise.reject()转换从rejected状态，并将给定的失败的信息传递给catch,any()方法会传入一个promise数组，只要有一个promise为fulfilled状态，则any也是fulfilled,只有全部为rejected则为rejected,allSettled()状态只有fulfilled状态，race()谁先改变状态就是使用谁的状态,all()只有全部为fulfilled才是fulfilled，有一个为reject则为reject\n5.说一说跨域是什么？如何解决跨域问题？由于同源策略，当出现请求页面的地址和当前页面地址协议，域名，端口号有一个不一致就会出现跨域。\n解决跨域的方法\n使用jsonp进行请求数据，并且通过回调函数来携带返回的数据\ncors：目前最常用的一种解决办法，通过设置后端允许跨域实现。res.setHeader(‘Access-Control-Allow-Origin’, ‘*’);res.setHeader(“Access-Control-Allow-Methods”, “GET, PUT, OPTIONS, POST”);\nnode中间件、nginx反向代理：跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制\nJSONP：利用的原理是script标签可以跨域请求资源，将回调函数作为参数拼接在url中。后端收到请求，调用该回调函数，并将数据作为参数返回去，注意设置响应头返回文档类型，应该设置成javascript。\npostmessage：H5新增API，通过发送和接收API实现跨域通信。\nwebpack中配置devServer中的proxy实现跨域\n6.说一说BFCBFC就是块级格式化上下文。他会形成一块独立的区域，不会影响边界以外的元素\nBFC产生的条件\n\n根元素\n浮动元素（float:left&#x2F;float:right）\n绝对定位元素(position:absolute,fixed)\n行内块元素 display:inline-block\n表格单元格 display:table-cell 表格的单元格默认就是\n匿名表格单元格元素\noverflow计算值不是visible的块元素\ndisplay:flex&#x2F;inline-flex的直接子元素\ndisplay:grid或者inline-grid的直接子元素\ndisplay:flow-root元素\n\n作用\n​\t解决同一个BFC相邻两个box的margin会折叠的问题\n​\t解决浮动高度塌陷的问题，可以实现清除浮动的效果。通常是overflow:hidden\n​\t\t解决高度塌陷要满足以下条件\n​\t\t\t浮动元素的父元素触发BFC，形成BFC\n​\t\t\t浮动元素的父元素的高度是auto\n​\tBFC的高度是auto的情况下，高度的计算\n​\t\t\t如果只有inline-level 是行高的顶部和底部的距离\n​\t\t\t如果是block-level,是由最顶层块的上边缘到最底层块的下边缘之间距离\n​\t\t\t如果有绝对定位元素，将忽略\n​\t\t\t如果有浮动元素，则会增加高度包含浮动元素的下边缘\n7.说一说Vuex是什么，每个属性是干嘛的，如何使用 ？VueX是全局状态管理的工具。vuex的属性有state,getter,mutations,action,module，state属性用来存储公共管理的数据，mutations属性定义可以修改state中的数据，是同步修改的，所以不要在mutation中书写ajax代码，这样数据不可追踪，getters属性可以认为是定义store的计算属性。getter的返回值会根据他的依赖被缓存起来，且只有当他的依赖发生了改变才会被重新计算，action中进行异步操作，可以操作mutation来修改数据，mutation是修改数据的唯一方法。module可以将store分为多个模块，每个模块都有自己的mutation，state,getter,action,module。通过store.state可以获取state,可以用计算属性中的mapState,store.commit来提交mutation,可以使用mapMutation来映射多个mutation,store,dispatch来分发action,可以使用mapAction来映射多个action  ,获取getter可以使用store,getter,可以使用maGetter来映射多个getter\n8.说一说JavaScript有几种方法判断变量的类型？typeof 可以用来判断基本数据类型  还可以判断Function ,其他引用数据类型都是返回Object,null也是返回object\nconstructor可以判断引用数据类型 就是判断instance.proto.constructor&#x3D;Function\ninstanceOf也可以判断引用数据类型 单数不能判断基本数据类型，就是运用原型链，判断右边的原型是否在左边的原型链上\nObject.prototype.toString.call也可以用来判断引用数据类型\n9.说一说样式优先级的规则是什么？样式的优先级应该分为4大类\n第一类 !important的优先级最高，无论是什么引用方式，什么选择器\n第二类是引用方式  行内样式优先级高于嵌入样式和外部样式，如果嵌入样式和外部样式使用相同的选择器，则看他们谁后引入，被覆盖\n第三类是选择器\nid选择器&gt;类选择器，属性选择器，伪类选择器&gt;元素选择器，伪元素选择器&gt;通配符选择器\n第四类是默认样式\n important 10000 内联选择器 1000 id选择器 100 类选择器，属性选择器，伪类 10 元素选择器，伪元素 1 通配选择器  0\n10.说一说JS实现异步的方法？得分点 回调函数、事件监听、setTimeout、Promise、生成器Generators&#x2F;yield、async&#x2F;await,\n所有的异步代码都会在同步代码执行完后，从异步队列中取出依次执行。回调函数是最基本的异步函数，例如ajax请求，回调函数的有点是简单，容易理解和实现，缺点是不利于代码的阅读和理解，各个部分耦合度高，使得程序结构混乱，流程难以追踪(尤其是多个回调函数嵌套的情况，容易出现回调地狱)，而且每个任务只能指定一个回调函数，回调函数不能使用try..catch来捕获错误，不能直接·return  ,Promise包装了一个异步调用并且生成了一个promise实例，promise不经可以捕获错误，而且可以很好的解决回调地狱的问题，缺点是没办法取消promise,错误需要使用回调函数来捕获。generator函数是ES6提供的异步编程的解决方案，generator是一个状态机，封装了多个内部状态，可以暂停函数，yield可以暂停执行，next可以继续执行,每次返回都是yield的结果。优点是语义清晰，但是需要手动调用。async&#x2F;await是基于Promises实现的，await会阻塞后面的代码的执行。如果多个异步代码没有依赖性却使用了await会降低性能\n11.说一说Vue2.0 双向绑定的原理与缺陷？Vue的响应式原理：采用数据劫持和发布者-订阅者模式相结合的方式，遍历对象中的属性使用Object.defineProperty劫持各个属性的getter和setter方法，在数据发生变化的时候，触发setter,进而调用对应的notify方法执行依赖该属性的函数，进而更新页面的DOM。读取该属性的时候会触发getter，使用Object.defineProperty不能够监听对象的新增属性和删除属性。不可以监听通过数组索引来修改数据，不能够修改length,而监听到变化\n12.说一说数组去重都有哪些方法？方式一：使用new Set(arr)进行去重，然后再使用Array.from()或者扩展运算符转成数组\n方式二:\t使用filter+indexOf来去重\n方式三:   使用双重for循环+splice来进行去重\n方式四:   使用[]+indexOf来去重\n方式五:   使用sort去重，先进行排序，然后再进行当前索引和下一个索引值进行比较，push进新的数组\n方式六:   使用对象属性不能相同的特点去重，以数组每一个item作为object的key,通过for循环判断obj[arr[i]]是否存在，如果不存在则push,并且obj[arr[i]]&#x3D;1,否则就是obj[arr[i]]++\n方式七：使用includes来去重，可以区别Nan,可以判断新的数组中是否包含这个值，不包含就push\n方式八：使用hasOwnProperty来去重\n方式九：先进行排序，然后在进行递归，splices删除重复数据\n方式十：使用Map数据结构来去重，通过has判断，如果为false就push，并且set值，\n方式十一：使用reduce+includes来去重，判断pre中是否存在\n13.说一说null 和 undefined 的区别，如何让一个属性变为null得分点 操作的变量没有被赋值、全局对象的一个属性、函数没有return返回值、值 null 特指对象的值未设置 undefined &#x3D;&#x3D; null、undefined !&#x3D;&#x3D; null \n一个变量定义了，但是没有进行初始化，那他的值就是undefined。函数没有指定return的值，默认就是undefined。对象中某个属性不存在就是undefined，函数定义了形参，但是没有定义默认参数，实参就是undefined,undefined可以通过typeof 来判断是否undefined,undefined&#x3D;&#x3D;undefined,undefined&#x3D;&#x3D;&#x3D;undefined。null就是对象的值未设置，一个对象没有设置指针地址就是null,null通过typeof判断类型是object,null&#x3D;&#x3D;null,null&#x3D;&#x3D;&#x3D;null,null&#x3D;&#x3D;undefined,null!&#x3D;&#x3D;undeined,undefined表示未设置值的默认状态，null表示手动设置为空对象，儿不是默认状态，在实际使用过程中，变量不需要手动的赋值undefined,如果需要手动的释放对象，可以赋值null,typeof会判断为object,是因为js数据类型在底层都是以二进制的形式表示的，二进制的前三位为0会被typeof判断为objet,而null的二进制全是0，当对象被赋值为0以后就会被垃圾回收器择机回收并且释放内存\n14.说一下浮动float属性可以指定一个元素向左或者向右浮动，浮动元素会脱离标准流\n浮动规则一\n​\t元素一旦浮动后，脱离标准流\n​\t\t\t朝着向左或者向右方向移动，直到自己的边界紧贴者包含块(一般是父元素)或者其他浮动元素的边界为止\n​\t\t\t定位元素会层叠在浮动元素上面\n浮动规则二\n​\t如果元素是向左或者向右浮动，浮动的元素的左右边界不能超过包含快的左右边界\n浮动规则三\n​\t浮动元素之间不能够层叠，如果一个元素浮动，后面的元素会紧挨着前面的浮动元素排列，如果剩下的空间不够放下一个浮动元素则会向下移动，找到可以放下的空间\n浮动规则四\n​\t浮动元素不能与行内级内容层叠，行内级内容会被推出去\n浮动规则五\n​\t行内级元素，inline-block元素浮动后，其顶部将与所在行的顶部对齐\n浮动的问题\n​\t由于浮动的元素脱离了标准流·，变成了脱标元素，所以不在向父元素汇报高度，父元素计算高度的时候不计算浮动元素的高度，所以会造成内容塌陷\n解决高度塌陷的方法\n​\t方法一，给父元素设置固定高度。扩展性不好\n​\t方法二，给父元素最后添加一个空的块级元素，并且设置为clear:both。这样会增加无意义的空标签，维护麻烦，违反了结构与样式分离的原则\n​\t方式三，给父元素添加一个伪元素，::after,设置content:””,display:block，overflow:hidden,clear:both,visibility:hidden,height:0,   为了兼容IE6&#x2F;7还要加上*zoom:1\n15.说一说es6中箭头函数？箭头函数中没有this,箭头函数中的this指向是由上层作用域的中非箭头函数this决定的，箭头函数中没有arguments,如果箭头函数中出现arguments，则由上层作用域非箭头函数的arguments决定，箭头函数中arguments可以使用rest参数替代，箭头函数不可以作为构造函数，没有super()和原型,箭头函数不可以使用call,apply,bind显示绑定来改变this的指向，箭头函数不可以作为generator函数。箭头函数不能作为事件绑定的回调函数，如果使用了this，该this不会指向触发事件的元素，而是指向window。箭头函数适用于需要引用上层作用域的this,可以替代var _this&#x3D;this,或者没有使用到this的函数\n16.说一说call apply bind的作用和区别？call,apply,bind可以显示进行this的绑定，call可以传多个参数，并且立即执行函数，apply第二个参数传的是函数，也是会立即执行，bind可以传多个参数，并且会返回新的函数，call,apply还可以用于函数的执行。call,apply可以用于对象的继承，将伪数组转成真数组，进行原型链方法的借调，等等，bind可以用于react中this的绑定\n17.说一说this指向（普通函数、箭头函数）？默认绑定this是指向全局window，普通函数的调用\n隐式绑定this是指向调用的对象，对象调用方法时\n显示绑定this指向绑定的值\nnew绑定this指向新创建的对象\n箭头函数中没有this,this是由上层作用域中非箭头函数决定的\n在严格模式下，this默认是undefined\n默认绑定的优先级最低\n显示绑定的优先级高于隐式绑定\nnew绑定的优先级高于bind\nnew绑定优先级高于隐式绑定\nbind的优先级高于call&#x2F;apply\nnew不可以和call&#x2F;apply一起使用\nsetTimeout中this默认指向window\n事件绑定中this指向绑定的元素\n18.说一说CSS尺寸设置的单位px是绝对长度单位，em,rem,vw&#x2F;vh是相对长度单位\nem是在font-size中默认使用相对于父元素的字体大小,如果自己定义了font-size,则根据自身的font-size进行定义，其他属性也是相对于自身的font-size,\n19.说一说HTML语义化？20.说几个未知宽高元素水平垂直居中方法21.说一说JS变量提升？函数和var 声明的变量在代码编译阶段会提升到最前面，但此时var声明的变量还没有赋值，所以此时访问是undefined,而函数可以在函数定义之前被调用，因为函数是一等公民，函数声明的提升优先级会比变量提升高，let,const不会出现变量提升，let const在定义以前访问会出现暂时性死区\n22.说一说 HashRouter 和 HistoryRouter的区别和原理？HashRouter  和 HistoryRouter都是利用浏览器的两种特性来实现前端路由的，根据这两种特性，可以实现不需要刷新页面的去修改内容。HashRouter就是利用通过监听window.onhashchange根据location.hash的变化来修改Dom,url中hashRouter和historyRouter的不同是，hash会在url中有#这样的hash值，而history没有。historyRouter是根据h5新增的历史调用栈API来实现的，他有六种模式来改变url而不会重新刷新页面\nhistory.replaceState():替换原来的路径\nhistory.pushState() 使用新的路径\nhistory.popState()  路径的回退\nhistory.back() 向后改变路径\nhistory.go() 跳转至那个路径\n通过window.onpopState来监听浏览器的前进和后退，pushState和replaceState都是可以携带参数，hash可以兼容低版本的浏览器，如果想传递任意类型的数据到记录栈可以使用history,history需要后端配合，如果后端不配合，就会出现404，而hash不需要\n23.说一说map 和 forEach 的区别？得分点 map创建新数组、map返回处理后的值、forEach()不修改原数组、forEach()方法返回undefined\nmap会返回新的数组，forEach不会修改原来的数组，map需要return foreach不需要return,foreach中return是无效的，map中this默认指向undefined,foreach中this默认指向window,forEach不能终端执行，只能够抛出异常来终止执行。forEach没有返回值新的数组所以不能够进行链式调用，map的处理数组比foreach快\n24.说一说事件循环Event loop，宏任务与微任务？js代码执行过程中，同步代码先执行，要到定时器，就会先将定时器先挂起，继续向下执行，执行到异步代码，就会将异步代码进入事件队列，宏任务就会进入宏任务队列，微任务就是进入微任务事件队列，同步代码执行完后，就会从事件队列中取出异步代码，进入执行上下文调用栈，微任务先执行，执行完后在执行宏任务，等定时器到期之后也会加入到事件队列，就这样不断的循环往复执行，就是事件循环，事件循环包括浏览器的事件循环和Node的事件循环，浏览器的事件循环中宏任务包括定时器，ajax请求，window.postmessage,setImmediate,UI render,Dom监听，微任务包括promise的then回调，async&#x2F;await,Mutation Obderver，queueMicrotask。Node的事件循环中微任务为process.nexttick,promise的then回调，queueMicrotask,宏任务队列包括，定时器，ID事件，setImmediate,close事件\n25.说一说Vue3.0 实现数据双向绑定的方法 ？vue3中实现数据双向绑定采用new Proxy来替代Object.defineProperty实现，proxy可以监听整个对象，使用new proxy()将需要监听的对象作为参数传递，并且有13中拦截器，可以对对象以及函数进行监听，例如监听对象属性的getter,setter,delete操作,in操作，defineProperty操作等，可以解决object.defineproperty不可以监听对象属性的新增和删除操作，不可以监听数组通过索引赋值，和手动给length赋值等操作\n26.说一下Diff算法？得分点 patch、patchVnode、updateChildren、vue优化时间复杂度为O(n) \ndiff算法中的比较过程，第一步：patch函数首先会对新旧节点进行比较，如果旧的节点存在且和新的节点类型不同，则会销毁旧的节点。如果旧节点存在，如果新旧节点类型相同时，然后对新的节点的类型进行判断，如果是文本节点，则直接替换成文本节点，如果是注释节点也是直接的插入。处理静态节点，处理fragment组件节点等，然后就是处理普通的Dom元素和组件节点等等，在处理普通元素的时候，他会先判断旧节点是否存在，不存在则直接挂在。否则调用patchElement函数。在执行patchElement的时候首先处理props的情况，先将新的节点的props全部挂载到el上，判断旧节点的props是否不需要在新的节点上，如果不需要，那么删除对应的属性。然后通过调用patchChildren来对比子元素，如果新的节点是一个字符串类型，则直接调用el.textContent&#x3D;newChildren,如果新节点不是字符串类型，旧节点是字符串类型，那么直接遍历新的节点，挂载到el上，如果新旧节点都是数组，则会分为有key和没有key两种，有key则调用patchKeyedChildren方法，没有key则调用patchUnkeyedChildren方法。调用patchUnkeyedChildren方法时，会获取到长度最小的那个节点，for循环依次进行patch，patch完之后，剩下的节点，如果旧的长度大于新的，则移除这些节点，如果新的长度大于旧的长度则创建新的节点，如果有key则会调用patchKeyedChildren方法，首先节点会从头部开始比较，如果两个节点相同则会调用patch,并且i++,如果节点不同则会跳出循环，然后再从尾部进行比较，重复相同的步骤，并且e1–,e2–,如果i&gt;e1而且i&lt;e2,就是旧的节点遍历完了，依然有新的节点，则进行挂载，如果新的节点遍历完，旧的节点还有则移除旧的节点。对于剩下的未知的序列，就是无须的序列，首先会根据key建立map索引图， 遍历剩下的旧节点, 新旧对比, 移除不使用的旧节点，oldIndex &#x3D; 0 是一个特殊值，表示新节点没有对应的旧节点。用于确定最长稳定子序列，建立新的vnode的key的位置在旧的vnode的映射，然后for遍历旧节点中还没有被对比的节点，如果该节点已经被patch过，则卸载掉，如果在旧的vnode中key存在，在获取相同的key在新vnode的位置，如果存在，则新节点在旧节点的映射中设置所以旧节点的索引位置，然后进行新旧节点的patch,如果在旧node中key不存在，试图定位一个相同类型的没有key的节点的位置，准备用这个替换成新的值，从新结点中找到类型相同，且在旧节点没有对应映射的节点，设置进去，如果在新的vnode中没有对应的映射，就是在新的vnode中不存在这个key了，就卸载掉\n27.说一说三栏布局的实现方案圣杯布局，双飞翼布局\n28.说一下浏览器垃圾回收机制？29.说一说 vue 的 keep-alive ？30.CSRF攻击是什么？31.XSS攻击是什么？32.说一说js继承的方法和优缺点？33.说一说defer和async区别？默认情况下浏览器下载完js代码会立即执行，如果js需要操作dom,则会阻塞页面的渲染，async属性可以使加载js文档和dom树的构建同时进行，当js加载完成，js代码执行，会阻塞html的渲染，defer会等到dom构建完成以后再加载js代码。\ndefer是js的下载和执行不阻塞DOM tree的构建，defer中的js代码执行的时候Dom构建完成，defer会在DomcontenLoad之后执行，多个设置defer的script会按顺序加载，defer仅适用于外部脚本，对script的内容会忽略。而async不能保证顺序执行，不会阻塞DOM渲染，不能保证DOMContentLoaded之前或者之后执行，async用于独立脚本执行，就是那些不需要依赖外部文件的脚本\n加分项：阻塞的原因：由于js是可以操作dom的，如果在修改这些元素的时候同时渲染界面即js线程和ui线程同时运行，那么渲染线程前后获得的数据可能不一致，因此为了防止渲染出现不可以预测的效果，所以浏览器设置GUI渲染线程和js引擎为互斥的关系当浏览器执行js代码的时候渲染线程就会被保存在一个队列中，直到js程序执行完成才会接着执行。如果js执行事件过长，就会造成渲染界面过程不连贯，导致页面渲染加载阻塞的感觉\n34.说一下浏览器如何渲染页面的浏览器首先会解析页面，把html构建成DOM树，css构建成cssom树，css的加载不会阻塞dom树的构建，然后将dom树和cssom树整合成render树，如果加载到script标签，会阻塞页面的渲染进程，所以需要把script放在底部，然后执行js代码，经过布局和绘制，最终渲染到屏幕上\n35.说一说vue computed和watch的区别？当需要依赖其他状态来产生新的状态的时候，可以使用computed,computed适用于计算比较多的场景。computed依赖于其他状态，computed是同步的，而且有缓存，如果依赖的状态没有发生变化，他不会重新计算，computed默认是调用getter方法，也可以修改数据调用setter方法，watch是作为侦听器，可以监听data，props,emit等属性的变化，也是有惰性的，watch在数据初始化的时候不会执行，只有在数据变化的时候才会执行，可以设置immediate:true来让watch立即执行一次，watch默认不能够监听对象的属性的变化，可以设置deep:true,对对象进行深度监听\n36.说一说 Vue 中 $nextTick 作用与原理？得分点 异步渲染、获取DOM、Promise \n将回调延迟到下一次DOM更新循环之后执行，在修改数据之后立即执行它，然后等待DOM更新\nue更新DOM是异步执行的，在修改数据后，视图不会立刻更新，而是等待同一事件循环中所有数据变化之后，同意更新视图，所以修改完数据，立刻获得的是未修改的dom,nextTrick就可以在DOM更新之后执行回调函数，解决异步渲染不可以获取到更新之后的DOM的问题，nextTick会返回一个promise,所以可以使用async&#x2F;await\n应用场景：在钩子函数created()里面想要获取操作Dom，把操作DOM的方法放在$nextTick中\n37.说一说new会发生什么？\n创建一个空对象\n让这个空对象的[[prototype]]属性指向构造函数的prototype\n让构造函数中的this指向新创建的对象\n执行该构造函数\n如果构造函数没有返回对象则返回新创建的对象\n\n38.说一下token 能放在cookie中吗？得分点 能、不设置cookie有效期、重新登录重写cookie覆盖原来的cookie \ntoken一般用来判断用户是否登录，它内部包含的信息包括uid(用户唯一的身份标识)，time(当前的时间戳)，sign(签名，token的前几位是以哈希算法压缩成的一定长度地十六进制字符串)，token可以存放在cookie，token是否过期由后端决定，所以token存储在cookie中只要不设置cookie的过期时间就可以，如果token失效，只要返回固定状态表示token失效，需要重新登录，重新设置cookie中的token就可以了，\n39.说一下浏览器输入URL发生了什么？40.说一说组件通信的方式？41.说一说 v-if 和 v-show区别？v-if是条件渲染，是惰性的，只有在条件判断为true的时候才会渲染到页面中去，v-show相当于设置display来进行切换，所有v-if有更高的切换开销，v-show有更高的切换开销，如果需要频繁切换，需要使用v-show，v-else和template不可以用于v-show，v-show无论如何它的DOM实际上都是存在的，只是通过CSS来切换display属性，当v-if当条件为false时，其对应的元素不会渲染到DOM中\n42.React生命周期的各个阶段是什么？43.React组件间传值的方法有哪些？父组件向子组件传值是使用props进行传递，\n子组件向父组件传值，可以使用回调函数，父组件向子组件传递回调函数，子组件执行回调函数并传递参数\n子孙组件之间的传递可以使用createContext()\n兄弟组件间的数据传递可以使用事件总线来传递\n还可以使用redux进行全局状态管理\n44.说一说盒模型？盒模型分为IE的盒模型和W3C的盒模型，W3C的盒模型指的是content的宽高，IE的盒模型是将content,padding,margin包含在宽度和高度之内，可以使用css ,box-sizing:border-box来将W3C的盒模型转换成IE盒模型，默认是content-box\n45.说一说伪数组和数组的区别？得分点 类型是object、不能使用数组方法、可以获取长度、可以使用for in遍历\n数组的类型是Array,类数组的类型是object,类数组可以使用length查看长度，可以使用索引来获得值，但是不可以修改length,不能使用array的方法，可以使用forin进行遍历，类数组常用的场景：函数参数argumenrs,NodeList等，类数组转成数组方法，Array.from(arr),Array.prototype.slice.call(arr),索引不连续时会自动补位\n46.说一说如何实现可过期的localstorage数据？47.说一说axios的拦截器原理及应用？48.说一说创建ajax过程？49.说一下fetch 请求方式？50.说一下有什么方法可以保持前后端实时通信？51.说一下重绘、回流区别如何避免？对节点的大小，位置的修改重新计算被称为回流，例如DOM结构的改变(添加新的节点或者删除节点)\n改变布局，例如修改了width,height,padding,font-size等值\n窗口resize、(修改了窗口的尺寸)\n调用getComputedStyle方法获取尺寸，位置信息等\n修改背景色，字体颜色，边框颜色，边框样式等，\n回流一定会引起重绘，重绘不一定会引起回流，所以应该减少回流\n1.修改样式尽量一次性修改，例如通过cssText,classList,class来修改\n2.避免频繁的操作DOM，可以是用document.documentFragment批量修改片段\n3.避免使用getComputedStyle频繁获取计算值，如果需要，可以将计算值存储起来\n4.修改DOM可以先设置diaplay:none，是他不存在render树，再进行修改，修改完成后再加入render树中\n5.对某些元素使用position:absolute,fixed使其脱离标准流，这样开销会比较小\n6.默认情况下，标准流中的内容都会被绘制在同一个图层上，利用一些属性创建一个新的合成图层，这些layer可以使用GPU加速绘制，因为这些图层都是单独渲染，减少了回流和重绘，例如3d transform,vedio,canvas,iframe,opacity动画转换，position:fixed,animation或者transition设置了opacity,transorm.分层确实可以提高性能，但是不要过度使用，她是以内存为代价的\n52.说一说 Vue 列表为什么加 key？得分点 性能优化、diff算法节点比对、key不能是index\nkey属性主要时用在Vue的虚拟DOM算法，在新旧Vnode对比时辨识vnodes,如果不使用key,vue会使用一种最大限度减少动态元素并且尽可能减少的尝试就地修改&#x2F;复用相同类型元素的算法，而使用key，他会基于key的变化重新排列元素顺序，并且移除或者销毁不需要的元素\n相同的父元素的子元素的key必须唯一，如果有重复的可以会渲染错误\n如果使用index作为key,没有优化效果，因为index会改变\n它也可以用于强制替换元素或者组件而不是重复使用它时。当你遇到如下场景时它可能会很有用：\n\n完整地触发组件的生命周期钩子\n\n触发过渡\n\n\n53.说一说vue-router 实现懒加载的方法？vue实现懒加载的两种方法component：resolve=&gt;require([&quot;./app.vue&quot;],resolve)component:()i=&gt;import(/*webpackChunkName:app*/&quot;./app.vue&quot;)webpackChunkName可以不写不要在路由中使用异步组件。异步组件仍然可以在路由组件中使用，但路由组件本身就是动态导入的。webpack会进行代码分隔，进行独立打包，当使用道德时候才会加载，vue-router只会第一次加载时获取，以后都会使用缓存\n\n55.ReactRouter基本用法是什么？56.setState是同步还是异步的？setState在组件生命周期或者react合成事件中，setState是异步的\n在原生的dom事件中，setTimeout中，setState是同步的\nsetState设计为异步，可以显著提升性能，如果每次调用setState都进行更新，那么意味着render函数会被频繁的调用，页面会重新渲染，这样效率很低，最好的办法因该是活得多个更新，然后进行批量更新，\n如果同步进行更新state,但是还没有执行render函数，那么state,props不能保持同步，state和props不一致，在开发中会产生很多问题\n57.React事件绑定原理得分点 非原生事件、SyntheticBaseEvent \nReact中的事件不是原生的事件，而是对原生的event进行封装的新类SyntheticBaseEvent，模拟处DOM事件的所有功能,通过event.nativeEvent可以获得原生事件，react将所有的事件都绑定在root根组件上，之前都是绑定在document上的，react中的事件和DOM事件不一样，和vue也不一样，react并不是将click事件绑定在该div的真实DOM上，而是在root处监听所有支持的事件，当事件发生并冒泡到root处时，react将事件内容封装并交给真正的处理函数运行，这样的方式不仅减少了内存的消耗，还能再组件挂载销毁时统一订阅和移除事件，另外冒泡到root上的事件也不是原生浏览器事件，而是React自己实现的合成事件(SyntheticBaseEvent),因此我们如果不想要事件冒泡的话，调用event.stopPropagation是无效的，应该调用event.preventDefault\n58.React中hooks的优缺点是什么？59.说一说前端性能优化手段？60.说一说性能优化有哪些性能指标，如何量化？61.说一说服务端渲染？62.事件扩展符用过吗(…)，什么场景下？1.在数组调用时可以替代数组的apply方法\n2.用于合并数组\n3.与解构赋值相结合，生成新的数组\n4.将字符串转成数组\n5.任何iterator对象，都可以通过展开运算符转成数组\n6.用于数组的浅拷贝\n7.构造字面量对象可以使用展开语法\n8.在 new 表达式中应用，使用 new 关键字来调用构造函数时，不能直接使用数组 + apply 的方式（apply 执行的是调用 [[Call]] , 而不是构造 [[Construct]]），可以使用展开语法替代\n63.说一说vue钩子函数？组件从创建，挂载，更新，销毁的全过程就是vue的声明周期，包括beforeCreate,created,beforemount,mounted,beforeUpdate,updated,beforeumount,umouted,\nbeforeCreate钩子函数会在实例初始化之后，进行数据侦听和事件&#x2F;侦听器的配置之前同步调用，\ncreated钩子函数会在组件实例被创完成后被立即同步调用，此时$watch,computed,method,data等属性可以被调用，但是挂载阶段还没开始，所以$el属性还不可以使用，\nbeforeMount钩子函数被调用时，该钩子函数会在挂载前调用，render函数首次被调用，在服务器端渲染期间不会被调用\nmounted钩子函数被调用时，在实例挂载完成后调用，这时候传给app.mount的元素已经被新创建的vm.$el替换，mounted不会保证所有子组件都被挂载完成。如果想执行在这个视图渲染完毕后执行代码，可以在mounted内部使用vm.$nextTick\nmounted() &#123;  this.$nextTick(function () &#123;    // 仅在整个视图都被渲染之后才会运行的代码  &#125;)&#125;\n\n该钩子函数不会再服务端渲染时调用\nbeforeUpdate钩子函数是在数据发生变化之后DOM更新之前调用，适合在DOM更新之前访问它，例如移除手动添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。\nupdated钩子函数会在数据更新之后虚拟DOM重新渲染完毕之后被调用，此时DOM已经更新完毕可以进行DOM操作，但是不建议下该狗子中进行状态的改变，通常使用watch或者computed来进行状态监听，updated不能保证子组件已经挂载完成，如果想要在组件完全渲染以后操作可以使用vm.$nextTick.该钩子函数不能用于服务端。\nactivited钩子函数\n该钩子会被keep-alive缓存的组件激活时调用，该钩子在服务器管渲染期间不被调用\ndeactivated钩子函数会在被keep-alive缓存的组件失活时调用，在服务端不可用\nbeforeMount钩子函数会在组件卸载之前调用，在这个时候1可以解除对事件的监听，该钩子在服务器端渲染期间不被调用。\nmounted钩子函数调用时，组件已经卸载完成，指令和监听器都卸载完成，该钩子在服务器端渲染期间不被调用。\n父子组件的声明周期\n挂载阶段\n父beforeCreate-&gt;父created-&gt;父beforMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted\n更新阶段\n父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated\n销毁阶段\n父beforeDestory-&gt;子deforeDestory-&gt;子destoryed-&gt;父destoryed\n64.vue生命周期的源码实现65.nexttick源码66.v8垃圾回收68.计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？69.进程与线程的区别？（暂定）\n一个线程属于一个进程，而一个进程可以有多个线程，但至少有一个线程，线程依赖进程的存在\n进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存\n进程是资源分配的最小单位，线程是CPU调度的最小单位\n进程的切换开销远大于线程的切换开销\n进程间的通信IPC，线程间可以直接写进数据段(如全局变量)来进行通信–需要进程同步和互斥手段的辅助，以保证数据的一致性\n进程编程调试简单可靠性高，但是创建销毁开销大，线程正好相反，开销小，切换速度快，但是编程调试相对复杂\n进程间不会相互影响，一个线程挂掉会导致整个进程挂掉\n进程适合多核，多机分布，线程适用于多核\n\n进程：我们可以认为，启动一个应用程序，就会默认启动一个进程(也可能是多个进程)\n线程：每一个进程中，都会启动至少一个线程用来执行程序中的代码，这就主线程，所以说进程是线程的容器\n操作系统类似于一个大工厂，工厂中有很多车间，这个车间就是进程，每个车间有可能有一盒以上的工人在工厂，这个工人就是线程\njs是单线程的，js线程有自己的容器进程，浏览器或者node\n70.基本数据类型之间的转换1.console.log(null&#x3D;&#x3D;undefined)&#x2F;&#x2F;true2.非空字符串通过Boolean()转成true,空字符串转成false，对于Number类型，非0数字都会转成true,0,NaN会转成false,对象都会被转成true,undefined会被转成false，if条件判断会自动转成boolean进行判断，使用!!也可以进行隐式转换3.数值类型的转换，可以通过Number(),parseInt(),parseFloat()三个函数显示的进行转换，Number()可以用于任何数据类型，parseInt和parseFloat主要用于字符串，Number()进行类型转换时，boolean值false会转成0，true会转成1，null会转成0，undefined会返回NaN,对于字符串的转换，如果字符串中只包含数字则会转换成十进制的数字，如果字符串中包含浮点数，则会转成浮点数，如果包含十六进制的字符串则会转成十进制的数字，如果是空字符串则会转成0，如果字符串中包含其字符，则会转成NaN。对象会先调用valueOf按照上述方式进行转换，如果是NaN则会再调用toString再进行上述的转换。使用parseInt进行类型转换时，他会从第一个非空格的字符进行转换，如果第一个字符不是加减，数字字符，则会转成NaN,空字符串也会转成NaN,如果第一个字符时加减，数字则会一直到非数字字符位置，parseInt会进行截断字符，如果是浮点数字符串，则会遇到.就会截断parseFloat只能解析十进制，会忽略第二个.他会忽略字符转以0开头的值4.转成字符串，+””就可以变成字符串，也可以调用toString来转换，除了null和undefined都可以toString，使用String()也可以转成字符转，有toString则会调用这个方法，null则会装成”null”,undefined&#x3D;&gt;’undefined’\n71.webpack 的 plugin 和 loader 的区别和原理72.静态资源一般采取什么缓存策略？强缓存和协商缓存\n73.移动端300ms的延迟问题，问什么会有这个问题74.vue模版编译都有哪些阶段75.vue虚拟dom怎么生成的76.Vue2 3区别77.手写防抖节流78.手写dom树转js对象79.给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端80.如果一个页面打开很慢，可能是哪些原因，怎么进行优化81.TCP的三次握手，以及每次的作用82.TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理83.Vue的响应式原理84.Vue中computed和data里的值的联系，computed的特点以及响应式变化85.Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy 和 defineProperty 的比较详情请看vue3和vue2区别\nvue2中重写数组中的方法，主要分为这几步\n\n获取到Array原型链上的方法，因为拦截后还需要调用原生的方法进行操作\n使用object.defineproperty拦截数组的操作\n再把array的实例原型指向修改后的实例原型\n\nproxy和defineproperty的区别\ndefineproperty的作用主要不是用来监听对象属性的变化，defineproperty不可以监听数组的变化，必须重写数组的方法，会对对象进行修改，不能够监听对象属性的修改和删除，不可以监听数组手动修改length和通过数组下标修改值，proxy代理，可以代理对象，不需要修改元素组，而且有十三中捕获器，还可以配合reflect来使用\n86.webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等87.window.onload和DOMContentLoaded的区别88.了解http289.网页布局的方式有哪些90.使用promise封装ajax91.写一个vue的自定义指令92.vuex的原理，数据存储在哪里93.说一下href和src的区别94.说一下你知道的webpack打包构建的优化95.说一下你了解的plugin和loader,以及如何去写一个plugin和loader96.说一下transform的原理(先平移再旋转和先旋转再平移有什么区别)97.函数和对象及其上下文存储在哪里98.手写虚拟dom转换成真实的dom99.为什么一个网站的资源会存储在多个域名中100.如何实现前端的权限控制101.说一下vue3相对于vue2的优化102.说一下vite相对于webpack的优化103.实现vue中template生成虚拟dom104.知道http499是什么表示客户端主动关闭连接，即HTTP 499 Client Closed Request,HTTP 499 表示nginx使用非标准状态码。表明当nginx正在处理请求时，客户端关闭了连接\n105.说一说mata标签的作用meta元素用来定义元数据的，meta标签用于定义不能用其他元数据元素定义的元数据信息，header中定义元数据的标签有style,link,title等，不能用这些标签定义的数据，就写在meta中。\nmeta元素定义的元数据的类型包括以下几类\n如果设置了charset meta元素就是一个字符集声明，告诉文档使用那种字符编码\n如果设置了http-equiv属性，meta元素则是编译指令  主要是做兼容性处理，告诉IE浏览器去模仿那个浏览器的行为，IE模仿edge的行为，chrome使用1\n&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n\n如果设置了name属性，meta元素提供的是文档级别的元数据，应用于整个页面\n106.说一下css的优先级，important的缺点css的优先级是按照css的权重来叠加的，\n！important  10000\n内联样式 1000\nid选择器 100\n类选择器，属性选择权，伪类  10\n元素选择器，伪元素 1\n通配符 0\n通过各项叠加来计算css的优先级\nimportant的优先级最高，在全局和组件中要谨慎使用，在对一些继承属性使用important，在修改这个属性的时候需要再次添加important，可能会造成混乱\n107.说一下响应式布局108.写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名109.说一下js的事件循环和node事件循环的区别js的事件循环是运行在浏览器环境中的，node事件循环是运行在node环境中的\n浏览器的事件循环是一个我们编写的javascript代码和浏览器api调用(setTimeout&#x2F;ajax&#x2F;事件监听)的桥梁，桥梁之间他们用回调函数进行沟通\nnode事件循环是一个我们编写的javascript代码和系统调用(file syatem network)之间的桥梁，桥梁之间通过回调函数进行沟通\n浏览器的事件循环：\n​\t首先会在函数执行调用栈中执行同步代码，如果执行到定时器会先将定时器挂起，继续向下执行执行到微任务代码，则先进入微任务队列，执行到宏任务，则进入宏任务队列，同步代码执行完成后，则会开始执行异步队列中的代码，先执行微任务队列，微任务队列之星完后在执行宏任务队列，等定时器执行完后，则进入宏任务队列执行，如此往复直到执行完成\n宏任务队列：ajax，setTimeout ，setInterval，DOM监听，UIrendering等\n微任务队列：Promise的then回调，Mutation observer api queueMicrotask() async&#x2F;await等\nnode的事件循环是由libuv来实现的，libuv采用的就是非阻塞异步IO的调用方式\nnode事件循环分成很多个阶段\n定时器(Timer):setTimeOut ，setIterval\n待定回调（pending callback） 对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到 ECONNREFUSED\nidle,prepare:进内部使用\n轮询：检索新的I&#x2F;O事件，执行与IO有关的回调\n检测：setImmediate()回调函数在这里执行\n关闭回调函数:一些关闭的回调函数，如socket.on(‘close’,)\nnode的事件的循环更加复杂，他也分为微任务和宏任务\n宏任务：setTimeout,setInterval,IO事件，setImmediate,close事件\n微任务：promise.then,async&#x2F;awiat,process.nextTick,queueMicrotask\nNode中的事件循环不只是 微任务队列和 宏任务队列：\n​    微任务队列： \n​\t\tnext tick queue：process.nextTick； \n​\t\tother queue：Promise的then回调、queueMicrotask；\n​    宏任务队列： \n​\t\t timer queue：setTimeout、setInterval； \n​\t\tpoll queue：IO事件；\n​\t\tcheck queue：setImmediate； ü close queue：close事件\n执行宏任务的时候都必须先判断微任务队列是否有值\n110.实现一个柯里化函数（写代码）111.实现函数的链式调用（写代码，compose函数）112.如何配置less文件的loadertest:/\\.less$/,use:[style-loader,css-loader,postcss-loader,less-loader]\n\n\n\n113.webpack是如何做到一步步处理loader文件的114.为什么webpack是自上而下执行的115.实现防抖和节流函数（写代码）116.如何用css实现两栏布局117.说一下css的position定位运用position进行定位，常取得5个值是：\tstatic relative absolute fixed  sticky\nposition的默认值就是static\n使用其他属性值可以让position变成定位元素\nrelative:会按照标准文档流进行布局，可以通过left right top bottom 来进行定位，参照对象是元素原来的位置\nfixed：元素会脱离标准流，可以通过left，right，top，bottom进行定位，参照对象是视口。例如画布滚动时，元素不动\nabsolute：元素会脱离文档流，可以通过left，right，top，bottom进行定位，参照对象是最近定位（position不为static的元素）的祖先元素，否则就会相对于视口进行定位\n118.说一下js的作用域js的作用域有全局作用域，函数作用域，eval作用域，块级作用域\n全局作用域就是最顶层的作用域，所有变量都可以访问到，函数作用域就是每个函数内部的作用域，eval作用域就是eval函数内部的作用域，es6新增了块级作用域，块级作用域是函数作用域的子集\n119.说一下js的import和node的require的区别120.说一下你了解的js的数组的常用方法数组常用的方法有\nArray.prototype.join()\nArray.prototype.concat()\nArray.prototype.slice()\nArray.prototype.splice()\nArray.prototype.push()\nArray.prototype.shift()\nArray.prototype.unshift()\nArray.isArray()\nArray.prototype.pop()\nArray.prototype.map()\nArray.prototype.forEach()\nArray.prototype.reduce()\nArray.prototype.sort()\nArray.prototype.some()\nArray.prototype.every()\nArray.prototype.entry()\nArray.prototype.find()\nArray.prototype.findIndex()\nArray.prototype.flat()&#x2F;flatMap()\nArray.prototype.indexOf()\nArray.prototype.includes()\nArray.from()\nArray.of()\nArray.prototype.toString()\nArray.prototype.values()\n121.说一下GET和POST的区别\nGET在浏览器回退时是无害的，而POST会再次提交请求\nGET请求会被浏览器主动缓存，而POST不会，除非手动设置\nGET请求参数会被完整保留在浏览器的历史记录里，而POST中的参数不会被保留\nGET请求在URL中传送的参数是有长度限制的，而POST没有限制\nGET参数通过URL传递，POST放在Request body中\nGET请求只能进行 url 编码，而POST支持多种编码方式\nGET产生的URL地址可以被收藏，而POST不可以\n对参数的数据类型，GET只接受ASCII字符，而POST没有限制\nGET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息\n\n123.说一下px，rem，em的区别和联系px是绝对长度单位，rem，em是相对长度单位，em是相对于元素本身的font-size来进行定位的，如果本身没有font-size则会继承自父元素的font-size，rem是根据根元素的font-size\n124.说一下instanceof的原理通过判断instance的[[prototype]]是否和原型链上的原型是否匹配\n125.说一下this的指向有几种方式1.默认绑定  this默认是指向全局，浏览器中this指向window,node中this指向global  在由于兼容性考虑可以使用globalThis  在函数声明中，this就是默认绑定\n2.隐式绑定  在对象中this是指向调用的变量\n3.显示绑定   可以使用call ,apply ,bind来指定this的指向\n4.new绑定   使用new创建的对象，构造函数中的this会指向新创建的对象\n126.说一下v-model的原理v-model就是如下的语糖\n对于input，textarea元素\n&lt;input  :value=&quot;text&quot;  @input=&quot;event =&gt; text = event.target.value&quot;&gt;\n\n对于文本元素text，textarea会绑定value property监听input事件，checkbox和radio会绑定checked property 监听change事件，select属性会绑定value属性，监听change事件\n127.如何封装一个弹窗组件，需要考虑那些问题128.说一下keep-alive的原理，以及如果超出缓存长度，如何处理129.说一下你对jwt认证机制的理解，它的优缺点130.说一下new创建实例的时候都做了什么new创建实例的过程\n\n创建一个空对象\n新创建的对象的[[prototype]]指向构造函数的prototype\n构造函数的this指向新创建的对象\n执行构造函数\n如果构造函数没有返回值，则返回新创建的对象\n\n131.说一下你对闭包的理解132.说一下你对flex布局的理解，以及其中属性的默认值(未完待续)flex是用于按行或者按列布局元素的一维布局方法，元素可以通过膨胀以填充额外的空间以适应更小的空间。flex布局可以解决原来布局的一些痛点，例如垂直居中块元素，例如使容器的所有子项等分可用宽度，而不用管具体的宽高，在多列布局中所有列都采用相同的高度，即使他们包含的内容量不同。\n开启了flex布局的元素叫flex item\nflex container 里面的直接子元素叫做flex item\n当flex conteainer中的子元素变成flex item时，具备以下特点：\n​\tflex item的布局将受flex container属性的设置来来控制和布局\n​\tflex item不再严格区分块级元素和行内级元素\n​\tflex item 默认情况下是包裹内容的，但是可以设置宽度和高度\ndisplay：flex或者inline-flex可以变成 flex-container\nflex container的css属性有\n​\tflex-flow\n​\tflex-direction\n​\tflex-wrap\n​\tflex-flow\n​\tjustify-content\n​\talign-items\n​\talign-content\n应用在flex items上的c s s属性\n​\tflex-grow\n​\tflex-basis\n​\tflex-shrink\n​\torder\n​\talign-self\n​\tflex\n133.说一下ES6的块级作用域（待补充）let const function class声明都会形成块级作用域，块级作用域可以让变量必须先声明再访问，否则会出现暂时性死区。块级作用域不会出现变量提升。例如在setTimeOut中的通过递归获取dom节点，可以使用该特性来代替立即执行函数\n134.说一下async和await的原理，generator用来做什么async和await就是generator和promise.then的语法糖\n135.如何用ES5实现ES6的class的static和privatestatic:ES5中是直接在构造函数中添加\nprivate:默认使用_来替代，并且定义get set方法\n136.用promise封装实现readfile和writefile的同步请求（写代码）137.手写ES6的模板字符串（写代码","categories":["interview","daily"]},{"title":"面试问题记录","url":"/2022/08/04/interview02/","content":"从浏览器地址栏输入url到显示页面的步骤如何进行网站性能优化请描述一下 cookies，sessionStorage 和 localStorage 的区别WEB标准以及W3C标准是什么HTTP request报文结构是怎样的HTTP response报文结构是怎样的如何垂直居中一个浮动元素css中可以让文字在垂直和水平方向上重叠的两个属性是什么面试总结\ncss动画\n从左上角到右下角\njsonp如何实现跨域\ntcp三次握手四次挥手\n正则表达式\n首屏加载优化\npromise实现\npromise.all实现\n并发多条请求，等所有成功后在响应\n自己做过哪些缓存\neventBus\n如何实现跨域\n设计模式\n中英文切换：前端国际化\n自己webpack搭建项目\n哪些数据需要缓存\n前端数据可视化\nvue-cli搭建\nvue3了解\n数据请求接口拦截\n有没有做过重构\nv-for和v-show区别\nv-for为什么不可以和v-if一起用\n自定义命令v-**有没有用过，设置优先级\n用过哪些缓存\n$nexttrick使用场景\n用过哪些钩子函数\nvisual Dom\nvue中router实现原理\n如何减少回流重绘\n用过哪些设计模式，前端模块分层 ts中有进行模块的分层\nv-model和sync区别\n浏览器渲染线程是异步还是同步的\nvue中加载外部js文件和vue中js的执行顺序\nvue中如何进行跨多个组件传递信息\n移动端安卓和ios的兼容性问题，pc端兼容性问题\n页面嵌入到app中如何区分是是外部页面还是app页面\nhttp2&#x2F;http3的区别一百万条数据中查询一条数据如何根据电脑系统的亮度来调整background如果出现页面出现大面积空白解决方案scroll-behavior的值，及其作用DOCTYPE的作用JS如何上传多张png格式的图片","categories":["interview","daily"]},{"title":"jest学习笔记","url":"/2022/09/16/jest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"##Jest安装npm install --save-dev jest\n\n常见的匹配器test(&#x27;two plus two is four&#x27;, () =&gt; &#123;  expect(2 + 2).toBe(4);&#125;);\n\ntoBe使用 Object.is来进行精准匹配的测试。 如果您想要检查对象的值，请使用 toEqual 代替：\ntest(&#x27;对象赋值&#x27;, () =&gt; &#123;  const data = &#123;one: 1&#125;;  data[&#x27;two&#x27;] = 2;  expect(data).toEqual(&#123;one: 1, two: 2&#125;);&#125;);\n\ntoEqual 递归检查对象或数组的每个字段\n真值代码中的undefined, null, and false有不同含义，若你在测试时不想区分他们，可以用真值判断。 Jest提供helpers供你使用。\n\ntoBeNull 只匹配 null\ntoBeUndefined 只匹配 undefined\ntoBeDefined 与 toBeUndefined 相反\ntoBeTruthy 匹配任何 if 语句为真\ntoBeFalsy 匹配任何 if 语句为假\n\ntest(&#x27;null&#x27;, () =&gt; &#123;  const n = null;  expect(n).toBeNull();  expect(n).toBeDefined();  expect(n).not.toBeUndefined();  expect(n).not.toBeTruthy();  expect(n).toBeFalsy();&#125;);test(&#x27;zero&#x27;, () =&gt; &#123;  const z = 0;  expect(z).not.toBeNull();  expect(z).toBeDefined();  expect(z).not.toBeUndefined();  expect(z).not.toBeTruthy();  expect(z).toBeFalsy();&#125;);\n\n数字大多数的比较数字有等价的匹配器\ntest(&#x27;two plus two&#x27;, () =&gt; &#123;  const value = 2 + 2;  expect(value).toBeGreaterThan(3);//大于  expect(value).toBeGreaterThanOrEqual(3.5);//大于等于  expect(value).toBeLessThan(5);//小于  expect(value).toBeLessThanOrEqual(4.5);//小于等于  // toBe and toEqual are equivalent for numbers  expect(value).toBe(4);  expect(value).toEqual(4);&#125;);\n\n对于比较浮点数相等，使用 toBeCloseTo 而不是 toEqual，因为你不希望测试取决于一个小小的舍入误差。\ntest(&#x27;两个浮点数字相加&#x27;, () =&gt; &#123;  const value = 0.1 + 0.2;  //expect(value).toBe(0.3);           这句会报错，因为浮点数有舍入误差  expect(value).toBeCloseTo(0.3); // 这句可以运行&#125;);&#125;);\n\n字符串您可以检查对具有 toMatch 正则表达式的字符串︰\ntest(&#x27;there is no I in team&#x27;, () =&gt; &#123;  expect(&#x27;team&#x27;).not.toMatch(/I/);&#125;);test(&#x27;but there is a &quot;stop&quot; in Christoph&#x27;, () =&gt; &#123;  expect(&#x27;Christoph&#x27;).toMatch(/stop/);&#125;);\n\n数组和可迭代对象 toContain来检查一个数组或可迭代对象是否包含某个特定项\nconst shoppingList = [  &#x27;diapers&#x27;,  &#x27;kleenex&#x27;,  &#x27;trash bags&#x27;,  &#x27;paper towels&#x27;,  &#x27;milk&#x27;,];test(&#x27;shoppingList数组中包含milk&#x27;, () =&gt; &#123;  expect(shoppingList).toContain(&#x27;milk&#x27;);  expect(new Set(shoppingList)).toContain(&#x27;milk&#x27;);&#125;);\n\nthorw你想测试某函数在调用时是否抛出了错误，你需要使用 toThrow\nfunction compileAndroidCode() &#123;  throw new Error(&#x27;you are using the wrong JDK&#x27;);&#125;test(&#x27;compiling android goes as expected&#x27;, () =&gt; &#123;  expect(() =&gt; compileAndroidCode()).toThrow();  expect(() =&gt; compileAndroidCode()).toThrow(Error);  // 你可以自己定义确切的错误消息内容或者使用正则表达式  expect(() =&gt; compileAndroidCode()).toThrow(&#x27;you are using the wrong JDK&#x27;);  expect(() =&gt; compileAndroidCode()).toThrow(/JDK/);&#125;);\n\n测试异步代码Promise为你的测试返回一个Promise，则Jest会等待Promise的resove状态 如果 Promise 的状态变为 rejected, 测试将会失败\ntest(&#x27;the data is peanut butter&#x27;, () =&gt; &#123;  return fetchData().then(data =&gt; &#123;    expect(data).toBe(&#x27;peanut butter&#x27;);  &#125;);&#125;);\n\nAsync&#x2F;Awaittest(&#x27;the data is peanut butter&#x27;, async () =&gt; &#123;  const data = await fetchData();  expect(data).toBe(&#x27;peanut butter&#x27;);&#125;);test(&#x27;the fetch fails with an error&#x27;, async () =&gt; &#123;  expect.assertions(1);  try &#123;    await fetchData();  &#125; catch (e) &#123;    expect(e).toMatch(&#x27;error&#x27;);  &#125;&#125;);\n\n你也可以将 async and await和 .resolves or .rejects一起使用。\ntest(&#x27;the data is peanut butter&#x27;, async () =&gt; &#123;  await expect(fetchData()).resolves.toBe(&#x27;peanut butter&#x27;);&#125;);test(&#x27;the fetch fails with an error&#x27;, async () =&gt; &#123;  await expect(fetchData()).rejects.toMatch(&#x27;error&#x27;);&#125;);\n\n如果期望Promise被Reject，则需要使用 .catch 方法。 请确保添加 expect.assertions 来验证一定数量的断言被调用。 否则，一个fulfilled状态的Promise不会让测试用例失败。\ntest(&#x27;the fetch fails with an error&#x27;, () =&gt; &#123;  expect.assertions(1);  return fetchData().catch(e =&gt; expect(e).toMatch(&#x27;error&#x27;));&#125;);\n\n测试回调函数test(&#x27;the data is peanut butter&#x27;, done =&gt; &#123;  function callback(error, data) &#123;    if (error) &#123;      done(error);      return;    &#125;    try &#123;      expect(data).toBe(&#x27;peanut butter&#x27;);      done();    &#125; catch (error) &#123;      done(error);    &#125;  &#125;  fetchData(callback);&#125;);\n\n测试回调函数时，需要使用done方法，不能直接传入一个函数，否则没办法测试，需要使用上上面的格式\n.resolves &#x2F; .rejects您还可以使用 .resolves 匹配器在您期望的声明，Jest 会等待这一 Promise 来解决。 如果 Promise 被拒绝，则测试将自动失败。\ntest(&#x27;the data is peanut butter&#x27;, () =&gt; &#123;  return expect(fetchData()).resolves.toBe(&#x27;peanut butter&#x27;);&#125;);\n\n必须要使用return，在 fetchData 返回的这个 promise 变更为 resolved 状态、then() 有机会执行之前，测试就已经被视为已经完成了。\n如果你希望Promise返回rejected，你需要使用 .rejects 匹配器。 它和 .resolves 匹配器是一样的使用方式。 如果 Promise 被拒绝，则测试将自动失败。\ntest(&#x27;the fetch fails with an error&#x27;, () =&gt; &#123;  return expect(fetchData()).rejects.toMatch(&#x27;error&#x27;);&#125;);\n\n\n\nJest的钩子函数jest有4个钩子函数\n\nbeforeAll()钩子函数会在所有的测试用例之前执行  只会执行一次\nbeforeEach()钩子函数 会在每个测试用例执行之前执行一次，每个测试用例执行前都会执行一次\nafterEach() 钩子函数会在每个测试用里执行完之后执行执行一次\nalfterAll() 钩子函数会在所有用力执行完后执行\n\n生成jest配置文件jest.config.jsnpx jest --init\n\nmock函数Mock 函数允许你测试代码之间的连接——实现方式包括：擦除函数的实际实现、捕获对函数的调用 ( 以及在这些调用中传递的参数) 、在使用 new 实例化时捕获构造函数的实例、允许测试时配置返回值。\n有两种方法可以模拟函数：要么在测试代码中创建一个 mock 函数，要么编写一个手动 mock来覆盖模块依赖。\n使用 mock 函数假设我们要测试函数 forEach 的内部实现，这个函数为传入的数组中的每个元素调用一次回调函数。\nfunction forEach(items, callback) &#123;  for (let index = 0; index &lt; items.length; index++) &#123;    callback(items[index]);  &#125;&#125;\n\n为了测试此函数，我们可以使用一个 mock 函数，然后检查 mock 函数的状态来确保回调函数如期调用。\nconst mockCallback = jest.fn(x =&gt; 42 + x);forEach([0, 1], mockCallback);// 此 mock 函数被调用了两次expect(mockCallback.mock.calls.length).toBe(2);// 第一次调用函数时的第一个参数是 0expect(mockCallback.mock.calls[0][0]).toBe(0);// 第二次调用函数时的第一个参数是 1expect(mockCallback.mock.calls[1][0]).toBe(1);// 第一次函数调用的返回值是 42expect(mockCallback.mock.results[0].value).toBe(42);\n\n.mock 属性所有的 mock 函数都有这个特殊的 .mock属性，它保存了关于此函数如何被调用、调用时的返回值的信息。 .mock 属性还追踪每次调用时 this的值，所以我们同样可以也检视（inspect） this\nconst myMock1 = jest.fn();const a = new myMock1();console.log(myMock1.mock.instances);// &gt; [ &lt;a&gt; ]const myMock2 = jest.fn();const b = &#123;&#125;;const bound = myMock2.bind(b);bound();console.log(myMock2.mock.contexts);// &gt; [ &lt;b&gt; ]\n\n这些 mock 成员变量在测试中非常有用，用于说明这些 function 是如何被调用、实例化或返回的：\n// The function was called exactly onceexpect(someMockFunction.mock.calls.length).toBe(1);// The first arg of the first call to the function was &#x27;first arg&#x27;expect(someMockFunction.mock.calls[0][0]).toBe(&#x27;first arg&#x27;);// The second arg of the first call to the function was &#x27;second arg&#x27;expect(someMockFunction.mock.calls[0][1]).toBe(&#x27;second arg&#x27;);// The return value of the first call to the function was &#x27;return value&#x27;expect(someMockFunction.mock.results[0].value).toBe(&#x27;return value&#x27;);// The function was called with a certain `this` context: the `element` object.expect(someMockFunction.mock.contexts[0]).toBe(element);// This function was instantiated exactly twiceexpect(someMockFunction.mock.instances.length).toBe(2);// The object returned by the first instantiation of this function// had a `name` property whose value was set to &#x27;test&#x27;expect(someMockFunction.mock.instances[0].name).toBe(&#x27;test&#x27;);// The first argument of the last call to the function was &#x27;test&#x27;expect(someMockFunction.mock.lastCall[0]).toBe(&#x27;test&#x27;);\n\nMock 的返回值Mock 函数也可以用于在测试期间将测试值注入代码︰\nconst myMock = jest.fn();console.log(myMock());// &gt; undefinedmyMock.mockReturnValueOnce(10).mockReturnValueOnce(&#x27;x&#x27;).mockReturnValue(true);console.log(myMock(), myMock(), myMock(), myMock());// &gt; 10, &#x27;x&#x27;, true, true\n\n在函数连续传递风格（functional continuation-passing style）的代码中时，Mock 函数也非常有效。 以这种代码风格有助于避免复杂的中间操作，便于直观表现组件的真实意图，这有利于在它们被调用之前，将值直接注入到测试中。\nconst filterTestFn = jest.fn();// Make the mock return `true` for the first call,// and `false` for the second callfilterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);const result = [11, 12].filter(num =&gt; filterTestFn(num));console.log(result);// &gt; [11]console.log(filterTestFn.mock.calls[0][0]); // 11console.log(filterTestFn.mock.calls[1][0]); // 12\n\n大多数现实世界例子中，实际是在依赖的组件上配一个模拟函数并配置它，但手法是相同的。 在这些情况下，尽量避免在非真正想要进行测试的任何函数内实现逻辑。\n模拟模块假定有个从 API 获取用户的类。 该类用 axios 调用 API 然后返回 data，其中包含所有用户的属性：\nusers.js\nimport axios from &#x27;axios&#x27;;class Users &#123;  static all() &#123;    return axios.get(&#x27;/users.json&#x27;).then(resp =&gt; resp.data);  &#125;&#125;export default Users;\n\n现在，为测试该方法而不实际调用 API (使测试缓慢与脆弱)，我们可以用 jest.mock(...) 函数自动模拟 axios 模块。\n一旦模拟模块，我们可为 .get 提供一个 mockResolvedValue ，它会返回假数据用于测试。 实际上，我们想说的是我们想让axios.get(&#39;/users.json&#39;) 有个伪造的响应结果。\nusers.test.js\nimport axios from &#x27;axios&#x27;;import Users from &#x27;./users&#x27;;jest.mock(&#x27;axios&#x27;);test(&#x27;should fetch users&#x27;, () =&gt; &#123;  const users = [&#123;name: &#x27;Bob&#x27;&#125;];  const resp = &#123;data: users&#125;;  axios.get.mockResolvedValue(resp);  // or you could use the following depending on your use case:  // axios.get.mockImplementation(() =&gt; Promise.resolve(resp))  return Users.all().then(data =&gt; expect(data).toEqual(users));&#125;);\n\n模拟 部分模块模块的子集可以被模拟，模块的其他部分可以维持当前实现：\nfoo-bar-baz.js\nexport const foo = &#x27;foo&#x27;;export const bar = () =&gt; &#x27;bar&#x27;;export default () =&gt; &#x27;baz&#x27;;\n\n//test.jsimport defaultExport, &#123;bar, foo&#125; from &#x27;../foo-bar-baz&#x27;;jest.mock(&#x27;../foo-bar-baz&#x27;, () =&gt; &#123;  const originalModule = jest.requireActual(&#x27;../foo-bar-baz&#x27;);  //Mock the default export and named export &#x27;foo&#x27;  return &#123;    __esModule: true,    ...originalModule,    default: jest.fn(() =&gt; &#x27;mocked baz&#x27;),    foo: &#x27;mocked foo&#x27;,  &#125;;&#125;);test(&#x27;should do a partial mock&#x27;, () =&gt; &#123;  const defaultExportResult = defaultExport();  expect(defaultExportResult).toBe(&#x27;mocked baz&#x27;);  expect(defaultExport).toHaveBeenCalled();  expect(foo).toBe(&#x27;mocked foo&#x27;);  expect(bar()).toBe(&#x27;bar&#x27;);&#125;);\n\nMock 实现还有，在某些情况下用Mock函数替换指定返回值是非常有用的。 可以用 jest.fn 或 mockImplementationOnce方法来实现Mock函数。\nconst myMockFn = jest.fn(cb =&gt; cb(null, true));myMockFn((err, val) =&gt; console.log(val));// &gt; true\n\n\n\n当你需要根据别的模块定义默认的Mock函数实现时，mockImplementation 方法是非常有用的。\nfoo.js\nmodule.exports = function () &#123;  // some implementation;&#125;;\n\n\n\ntest.js\njest.mock(&#x27;../foo&#x27;); // this happens automatically with automockingconst foo = require(&#x27;../foo&#x27;);// foo is a mock functionfoo.mockImplementation(() =&gt; 42);foo();// &gt; 42\n\n\n\n当你需要模拟某个函数调用返回不同结果时，请使用 mockImplementationOnce 方法︰\nconst myMockFn = jest  .fn()  .mockImplementationOnce(cb =&gt; cb(null, true))  .mockImplementationOnce(cb =&gt; cb(null, false));myMockFn((err, val) =&gt; console.log(val));// &gt; truemyMockFn((err, val) =&gt; console.log(val));// &gt; false\n\n\n\n当 mockImplementationOne定义的实现逐个调用完毕时， 如果定义了jest.fn ，它将使用 jest.fn 。\nconst myMockFn = jest  .fn(() =&gt; &#x27;default&#x27;)  .mockImplementationOnce(() =&gt; &#x27;first call&#x27;)  .mockImplementationOnce(() =&gt; &#x27;second call&#x27;);console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());// &gt; &#x27;first call&#x27;, &#x27;second call&#x27;, &#x27;default&#x27;, &#x27;default&#x27;\n\n\n\n大多数情况下，我们的函数调用都是链式的，如果你希望创建的函数支持链式调用（因为返回了this），可以使用.mockReturnThis() 函数来支持。\nconst myObj = &#123;  myMethod: jest.fn().mockReturnThis(),&#125;;// is the same asconst otherObj = &#123;  myMethod: jest.fn(function () &#123;    return this;  &#125;),&#125;;\n\n自定义匹配器最后，测试Mock函数需要写大量的断言，为了减少代码量，我们提供了一些自定义匹配器。\n// The mock function was called at least onceexpect(mockFunc).toHaveBeenCalled();// The mock function was called at least once with the specified argsexpect(mockFunc).toHaveBeenCalledWith(arg1, arg2);// The last call to the mock function was called with the specified argsexpect(mockFunc).toHaveBeenLastCalledWith(arg1, arg2);// All calls and the name of the mock is written as a snapshotexpect(mockFunc).toMatchSnapshot();\n\n\n\n这些匹配器是断言Mock函数的语法糖。 你可以根据自己的需要自行选择匹配器。\n// The mock function was called at least onceexpect(mockFunc.mock.calls.length).toBeGreaterThan(0);// The mock function was called at least once with the specified argsexpect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);// The last call to the mock function was called with the specified argsexpect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([  arg1,  arg2,]);// The first arg of the last call to the mock function was `42`// (note that there is no sugar helper for this specific of an assertion)expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);// A snapshot will check that a mock was invoked the same number of times,// in the same order, with the same arguments. 它还会在名称上断言。 它还会在名称上断言。expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);expect(mockFunc.getMockName()).toBe(&#x27;a mock name&#x27;);\n","categories":["单元测试","jest"]},{"title":"jest常见问题解析","url":"/2022/09/19/jest%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/","content":"##jest ‘beforeEach’ is not defined .eslint no-undef\n需要在.eslintrc文件加上这一段\n&#123;  &quot;overrides&quot;: [    &#123;      &quot;files&quot;: [        &quot;**/*.spec.js&quot;,        &quot;**/*.spec.jsx&quot;      ],      &quot;env&quot;: &#123;        &quot;jest&quot;: true      &#125;    &#125;  ]&#125;\n\n","categories":["单元测试","jest"]},{"title":"mobx的使用","url":"/2022/09/20/mobx%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"入门任何可以从应用状态中派生出来的值都应该被自动派生出来。\nMobX 是一个身经百战的库，它通过运用透明的函数式响应编程（Transparent Functional Reactive Programming，TFRP）使状态管理变得简单和可扩展。\n😙\n简单直接编写无模板的极简代码来精准描述出你的意图。要更新一个记录字段？使用熟悉的 JavaScript 赋值就行。要在异步进程中更新数据？不需要特殊的工具，响应性系统会侦测到你所有的变更并把它们传送到其用武之地。\n🚅\n轻松实现最优渲染所有对数据的变更和使用都会在运行时被追踪到，并构成一个截取所有状态和输出之间关系的依赖树。这样保证了那些依赖于状态的计算只有在真正需要时才会运行，就像 React 组件一样。无需使用记忆化或选择器之类容易出错的次优技巧来对组件进行手动优化。\n🤹🏻‍♂️\n架构自由MobX 不会用它自己的规则来限制你，它可以让你在任意 UI 框架之外管理你的应用状态。这样会使你的代码低耦合、可移植和最重要的——容易测试。\nimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import &#123; makeAutoObservable &#125; from &quot;mobx&quot;import &#123; observer &#125; from &quot;mobx-react&quot;// 对应用状态进行建模。class Timer &#123;    secondsPassed = 0    constructor() &#123;        makeAutoObservable(this)    &#125;    increase() &#123;        this.secondsPassed += 1    &#125;    reset() &#123;        this.secondsPassed = 0    &#125;&#125;const myTimer = new Timer()// 构建一个使用 observable 状态的“用户界面”。const TimerView = observer((&#123; timer &#125;) =&gt; (    &lt;button onClick=&#123;() =&gt; timer.reset()&#125;&gt;已过秒数：&#123;timer.secondsPassed&#125;&lt;/button&gt;))ReactDOM.render(&lt;TimerView timer=&#123;myTimer&#125; /&gt;, document.body)// 每秒更新一次‘已过秒数：X’中的文本。setInterval(() =&gt; &#123;    myTimer.increase()&#125;, 1000)\n\n围绕 React 组件 TimerView 的 observer 包装会自动侦测到依赖于 observable timer.secondsPassed 的渲染——即使这种依赖关系没有被明确定义出来。 响应性系统会负责在未来恰好那个字段被更新的时候将组件重新渲染。\n每个事件（onClick 或 setInterval）都会调用一个用来更新 observable 状态 myTimer.secondsPassed 的 action（myTimer.increase 或 myTimer.reset）。Observable 状态的变更会被精确地传送到 TimerView 中所有依赖于它们的计算和副作用里。\n\nMobX 主旨Mobx区分了应用程序的三个概念\n\nState\nActions\nDerivations\n\nstateState(状态) 是驱动你的应用程序的数据。\nimport &#123; makeObservable, observable, action &#125; from &quot;mobx&quot;class Todo &#123;    id = Math.random()    title = &quot;&quot;    finished = false    constructor(title) &#123;        makeObservable(this, &#123;            title: observable,            finished: observable,            toggle: action        &#125;)        this.title = title    &#125;    toggle() &#123;        this.finished = !this.finished    &#125;&#125;\n\n将 State 存储在任何您喜欢的数据结构中：普通对象、数组、类、循环数据结构或引用。这与MobX的工作方式无关。\n只要确保所有响应式的属性都被标记为observable\nActionaction是用来改变state中的数据，比如用户事件处理、后端推送数据处理、调度器事件处理等等。\n创建 Derivations 以便自动对 State 变化进行响应任何 来源是State(状态) 并且不需要进一步交互的东西都是 Derivation(派生)\nDerivations 包括许多方式:\n\n用户界面\n派生数据 , 比如剩余未完成todos的数量\n后端集成 , 比如发送改变到服务器端\n\nMobx 区分了两种 Derivation :\n\nComputed values,总是可以通过纯函数从当前的可观测 State 中派生。\nReactions, 当 State 改变时需要自动运行的副作用 (命令式编程和响应式编程之间的桥梁)\n\n当最开始使用MobX时，人们容易过度使用 Reaction。\n黄金法则是，如果要基于当前 State 创建值，请始终使用 computed\n通过 computed 对派生值进行建模你可以通过定义 getter 方法并使用 makeObservable 将其标记为 computed 的方式创建一个 computed 值。\nimport &#123; makeObservable, observable, computed &#125; from &quot;mobx&quot;class TodoList &#123;    todos = []    get unfinishedTodoCount() &#123;        return this.todos.filter(todo =&gt; !todo.finished).length    &#125;    constructor(todos) &#123;        makeObservable(this, &#123;            todos: observable,            unfinishedTodoCount: computed        &#125;)        this.todos = todos    &#125;&#125;\n\nMobx 会确保 unfinishedTodoCount 会在todos数组发生变化中或者 todos中的一个对象中的 finished属性被修改时自动更新\nReaction会产生副作用作为用户，要想在屏幕上看到状态或计算值的变化，就需要一个重新绘制部分GUI的 reactions 。\nReaction 和 computed 类似，但并不产生信息，而是产生副作用，如打印到控制台、发出网络请求、增量更新 React 组件树以便更新DOM等。\n简而言之，reaction 是 响应式编程和指令式编程之间的桥梁。\n到目前为止，最常用的 reaction 形式是UI组件。 注意，action 和 reaction 都可能引起副作用。 副作用应有一个清晰的、显式的起源，例如在提交表单时发出网络请求，应该从相关的事件处理程序显式触发。\n原则Mobx 使用单向数据流，利用 action 改变 state ，进而更新所有受影响的 view\n\n\n所有的 derivations 将在 state 改变时自动且原子化地更新。因此不可能观察中间值。\n所有的 derivations 默认将会同步更新，这意味着 action 可以在 state 改变 之后安全的直接获得 computed 值。\ncomputed value 的更新是惰性的，任何 computed value 在需要他们的副作用发生之前都是不激活的。\n所有的 computed value 都应是纯函数,他们不应该修改 state。\n\nObservable state属性，完整的对象，数组，Maps 和 Sets 都可以被转化为可观察对象。 使得对象可观察的基本方法是使用 makeObservable 为每个属性指定一个注解。 最重要的注解如下：\n\nobservable 定义一个存储 state 的可追踪字段。\naction 将一个方法标记为可以修改 state 的 action。\ncomputed 标记一个可以由 state 派生出新的值并且缓存其输出的 getter。\n\n像数组，Maps 和 Sets 这样的集合都将被自动转化为可观察对象\nmakeObservable用法：\n\nmakeObservable(target, annotations?, options?)\n\n这个函数会将已存在的对象属性转换成可观察地对象，任何target对象包括class都可以作为target传递。一般情况下，makeObservable 是在类的构造函数中调用的，并且它的第一个参数是 this 。 annotations 参数将会为每一个成员映射 注解。需要注意的是，当使用 装饰器 时，annotations 参数将会被忽略。\nimport &#123; makeObservable, observable, computed, action, flow &#125; from &quot;mobx&quot;class Doubler &#123;    value    constructor(value) &#123;        makeObservable(this, &#123;            value: observable,            double: computed,            increment: action,            fetch: flow        &#125;)        this.value = value    &#125;    get double() &#123;        return this.value * 2    &#125;    increment() &#123;        this.value++    &#125;    *fetch() &#123;        const response = yield fetch(&quot;/api/value&quot;)        this.value = response.json()    &#125;&#125;所有带注解 的字段都是 不可配置的。所有的不可观察（无状态）的字段（action, flow）都是 不可写的。\n\nmakeAutoObservable使用：\n\nmakeAutoObservable(target, overrides?, options?)\n\n相当于是加强版的makeObservable函数，他会自动根据传入的对象属性自动转成可观察属性，\n与使用 makeObservable 相比，makeAutoObservable 函数更紧凑，也更容易维护，因为新成员不需要显式地提及。 然而，makeAutoObservable 不能被用于带有 super 的类或 子类\n推断规则：\n\n所有 自有 属性都成为 observable。\n所有 getters 都成为 computed。\n所有 setters 都成为 action。\n所有 prototype 中的 functions 都成为 autoAction。\n所有 prototype 中的 generator functions 都成为 flow。（需要注意，generators 函数在某些编译器配置中无法被检测到，如果 flow 没有正常运行，请务必明确地指定 flow 注解。）\n在 overrides 参数中标记为 false 的成员将不会被添加注解。例如，将其用于像标识符这样的只读字段。\n\nobservable用法：\n\nobservable(source, overrides?, options?)\n\nobservable 注解可以作为一个函数进行调用，从而一次性将整个对象变成可观察的。 source 对象将会被克隆并且所有的成员都将会成为可观察的，类似于 makeAutoObservable 做的那样。 同样，你可以传入一个 overrides 对象来为特定的成员提供特定的注解。 \n由 observable 返回的对象将会使用 Proxy 包装，这意味着之后被添加到这个对象中的属性也将被侦测并使其转化为可观察对象（除非禁用 proxy）。\nobservable 方法也可以被像 arrays，Maps 和 Sets 这样的集合调用。这些集合也将被克隆并转化为可观察对象。\nimport &#123; observable, autorun &#125; from &quot;mobx&quot;const todos = observable([    &#123; title: &quot;Spoil tea&quot;, completed: true &#125;,    &#123; title: &quot;Make coffee&quot;, completed: false &#125;])autorun(() =&gt; &#123;    console.log(        &quot;Remaining:&quot;,        todos            .filter(todo =&gt; !todo.completed)            .map(todo =&gt; todo.title)            .join(&quot;, &quot;)    )&#125;)// 打印: &#x27;Remaining: Make coffee&#x27;todos[0].completed = false// 打印: &#x27;Remaining: Spoil tea, Make coffee&#x27;todos[2] = &#123; title: &quot;Take a nap&quot;, completed: false &#125;// 打印: &#x27;Remaining: Spoil tea, Make coffee, Take a nap&#x27;todos.shift()// 打印: &#x27;Remaining: Make coffee, Take a nap&#x27;\n\n使用autorun可以在响应式的数据发生改变的时候，自动执行对应的回调函数\n可观察的数组还有一些特别好用的实用函数：\n\nclear() 从数组中清除所有元素。\nreplace(newItems) 将数组中现有的元素全部替换成 newItems。\nremove(value) 根据 value 从数组中删除一个元素。如果找到并删除了元素，返回 true。\n\n注意：基本数据类型和类的实例不能转换成可观察的对象\nmake(Auto)Observable 和 observable 之间最主要的区别在于，make(Auto)Observable 会修改你作为第一个参数传入的对象，而 observable 会创建一个可观察的 副本 对象\n第二个区别是，observable 会创建一个 Proxy 对象，以便能够在你将该对象当作动态查询映射使用时捕获将要添加的属性。 如果你想把一个对象转化为可观察对象，而这个对象具有一个常规结构，其中所有的成员都是事先已知的，那么我们建议使用 makeObservable，因为非代理对象的速度稍快一些，而且它们在调试器和 console.log 中更容易检查。\n因此，make(Auto)Observable 推荐在工厂函数中使用。 值得一提的是，可以将 &#123; proxy: false &#125; 作为 option 传入 observable 获取非代理副本\nActions使用 actions 更新 state用法：\n\naction （注解）\naction(fn)\naction(name, fn)\n\nactions就是用来修改state中的数据的，\n尽管 makeAutoObservable 可以自动帮你声明一部分 actions，但是 MobX 还是要求你声明你的 actions。Actions 可以帮助你更好的组织你的代码并提供以下性能优势：\n\n它们在 transactions 内部运行。任何可观察对象在最外层的 action 完成之前都不会被更新，这一点保证了在 action 完成之前，action 执行期间生成的中间值或不完整的值对应用程序的其余部分都是不可见的。\n默认情况下，不允许在 actions 之外改变 state。这有助于在代码中清楚地对状态更新发生的位置进行定位。\n\naction 注解应该仅用于会修改 state 的函数。派生其他信息（执行查询或者过滤数据）的函数不应该被标记为 actions，以便 MobX 可以对它们的调用进行跟踪。 带有 action 注解的成员是不可枚举的。\nmakeObservable\nimport &#123; makeObservable, observable, action &#125; from &quot;mobx&quot;class Doubler &#123;    value = 0    constructor(value) &#123;        makeObservable(this, &#123;            value: observable,            increment: action        &#125;)    &#125;    increment() &#123;        // 观察者不会看到中间状态.        this.value++        this.value++    &#125;&#125;\n\nmakeAutoObservable\nimport &#123; makeAutoObservable &#125; from &quot;mobx&quot;class Doubler &#123;    value = 0    constructor(value) &#123;        makeAutoObservable(this)    &#125;    increment() &#123;        this.value++        this.value++    &#125;&#125;\n\naction.bound\nimport &#123; makeObservable, observable, action &#125; from &quot;mobx&quot;class Doubler &#123;    value = 0    constructor(value) &#123;        makeObservable(this, &#123;            value: observable,            increment: action.bound        &#125;)    &#125;    increment() &#123;        this.value++        this.value++    &#125;&#125;const doubler = new Doubler()// 这样调用 increment 是安全的, 因为它已经被绑定了。setInterval(doubler.increment, 1000)\n\nAction(fn)\nimport &#123; observable, action &#125; from &quot;mobx&quot;const state = observable(&#123; value: 0 &#125;)const increment = action(state =&gt; &#123;    state.value++    state.value++&#125;)increment(state)\n\nrunInAction\nimport &#123; observable, runInAction &#125; from &quot;mobx&quot;const state = observable(&#123; value: 0 &#125;)runInAction(() =&gt; &#123;    state.value++    state.value++&#125;)\n\n使用 action 包装函数为了尽可能地利用 MobX 的事务性，actions 应该尽可能被传到外围。如果一个类方法会修改 state，可以将其标记为 action。把事件处理函数标记为 actions 就更好了，因为最外层的事务起着决定性作用。一个未被标记的、会接着调用两个 actions 的事件处理函数仍然将会生成两个事务。\n为了帮助创建基于 action 的事件处理函数，action 不仅仅是一个注解，更是一个高阶函数。可以使用函数将它作为一个参数来调用，在这种情况下它将会返回一个有着相同签名的使用 action 包装过的函数。\n例如在 React 中，可以按照下面的方式包装 onClick 事件处理函数\nconst ResetButton = (&#123; formState &#125;) =&gt; (    &lt;button        onClick=&#123;action(e =&gt; &#123;            formState.resetPendingUploads()            formState.resetValues()            e.stopPropagation()        &#125;)&#125;    &gt;        Reset form    &lt;/button&gt;)\n\n为了更好的调试体验，我们推荐为被包装的函数命名，或者将名称作为 action 的第一个参数进行传递\t\n注意：actions不会被跟踪，就是不能触发autorun\nactions 的另一个特征是它们是 不可追踪 的。当从副作用或者计算值（非常罕见）中调用 action 时，该 action 读取的可观察对象将不会算作该 derivation 的依赖项。\nmakeAutoObservable，extendObservable 和 observable 使用一种特殊的 action， 叫做 autoAction， 它会在运行时确定函数是 derivation 还是 action。\naction.bound用法：\n\naction.bound （注解）\n\naction.bound 注解可用于将方法自动绑定到正确的实例，这样 this 会始终被正确绑定在函数内部\n使用makeAutoObservable(o,{},{autoBind:true}) 自动绑定所有的actions和flow\nimport &#123; makeAutoObservable &#125; from &quot;mobx&quot;class Doubler &#123;    value = 0    constructor(value) &#123;        makeAutoObservable(this, &#123;&#125;, &#123; autoBind: true &#125;)    &#125;    increment() &#123;        this.value++        this.value++    &#125;        *flow() &#123;        const response = yield fetch(&quot;http://example.com/value&quot;)        this.value = yield response.json()    &#125;&#125;\n\nrunInAction用法：\n\nrunInAction(fn)\n\n使用这个工具函数来创建一个会被立即调用的临时 action。在异步进程中非常有用。 \nActions 和继承只有定义在原型上的函数可以被子类覆盖：\nclass Parent &#123;    // on instance class filed    arrowAction = () =&gt; &#123;&#125;    // on prototype    action() &#123;&#125;    boundAction() &#123;&#125;    constructor() &#123;        makeObservable(this, &#123;            arrowAction: action            action: action,            boundAction: action.bound,        &#125;)    &#125;&#125;class Child extends Parent &#123;    // THROWS: TypeError: Cannot redefine property: arrowAction    arrowAction = () =&gt; &#123;&#125;    // OK    action() &#123;&#125;    boundAction() &#123;&#125;    constructor() &#123;        super()        makeObservable(this, &#123;            arrowAction: override,            action: override,            boundAction: override,        &#125;)    &#125;&#125;\n\n想要将单个的 action 绑定 到 this，可以使用 action.bound 代替箭头函数\n异步 actions从本质上讲，异步进程在 MobX 中不需要任何特殊处理，因为不论是何时引发的所有 reactions 都将会自动更新。 而且因为可观察对象是可变的，因此在 action 执行过程中保持对它们的引用一般是安全的。 然而，在异步进程中更新可观察对象的每个步骤（tick）都应该被标识为 action。 我们可以通过利用上述的 API 以多种方式实现这一点，如下所示。\n例如，在处理 Promise 时，更新 state 的处理程序应该被 action 包装起来，或者被标记为 actions，如下所示。\nPromise 的决议处理程序是我们以内联的方式处理的，但是会在一开始的 action 执行完成之后运行，因此需要使用 action 对它们进行包装：import &#123; action, makeAutoObservable &#125; from &quot;mobx&quot;class Store &#123;    githubProjects = []    state = &quot;pending&quot; // &quot;pending&quot;, &quot;done&quot; or &quot;error&quot;    constructor() &#123;        makeAutoObservable(this)    &#125;    fetchProjects() &#123;        this.githubProjects = []        this.state = &quot;pending&quot;        fetchGithubProjectsSomehow().then(            action(&quot;fetchSuccess&quot;, projects =&gt; &#123;                const filteredProjects = somePreprocessing(projects)                this.githubProjects = filteredProjects                this.state = &quot;done&quot;            &#125;),            action(&quot;fetchError&quot;, error =&gt; &#123;                this.state = &quot;error&quot;            &#125;)        )    &#125;&#125;\n\n\n\n如果 Promise 的处理函数是类的字段，它们将由 makeAutoObservable 自动包装为 action：\nimport &#123; makeAutoObservable &#125; from &quot;mobx&quot;class Store &#123;    githubProjects = []    state = &quot;pending&quot; // &quot;pending&quot;, &quot;done&quot; or &quot;error&quot;    constructor() &#123;        makeAutoObservable(this)    &#125;    fetchProjects() &#123;        this.githubProjects = []        this.state = &quot;pending&quot;        fetchGithubProjectsSomehow().then(this.projectsFetchSuccess, this.projectsFetchFailure)    &#125;    projectsFetchSuccess = projects =&gt; &#123;        const filteredProjects = somePreprocessing(projects)        this.githubProjects = filteredProjects        this.state = &quot;done&quot;    &#125;    projectsFetchFailure = error =&gt; &#123;        this.state = &quot;error&quot;    &#125;&#125;\n\nawait 之后的任何操作都不与其同在一个 tick 中，因此它们需要使用 action 包装。 在这里，我们可以利用 runInAction：\nimport &#123; runInAction, makeAutoObservable &#125; from &quot;mobx&quot;class Store &#123;    githubProjects = []    state = &quot;pending&quot; // &quot;pending&quot;, &quot;done&quot; or &quot;error&quot;    constructor() &#123;        makeAutoObservable(this)    &#125;    async fetchProjects() &#123;        this.githubProjects = []        this.state = &quot;pending&quot;        try &#123;            const projects = await fetchGithubProjectsSomehow()            const filteredProjects = somePreprocessing(projects)            runInAction(() =&gt; &#123;                this.githubProjects = filteredProjects                this.state = &quot;done&quot;            &#125;)        &#125; catch (e) &#123;            runInAction(() =&gt; &#123;                this.state = &quot;error&quot;            &#125;)        &#125;    &#125;&#125;\n\n使用flow+generator\nimport &#123; flow, makeAutoObservable, flowResult &#125; from &quot;mobx&quot;class Store &#123;    githubProjects = []    state = &quot;pending&quot;    constructor() &#123;        makeAutoObservable(this, &#123;            fetchProjects: flow        &#125;)    &#125;    // 注意星号, 这是一个 generator 函数!    *fetchProjects() &#123;        this.githubProjects = []        this.state = &quot;pending&quot;        try &#123;            // Yield 代替 await.            const projects = yield fetchGithubProjectsSomehow()            const filteredProjects = somePreprocessing(projects)            this.state = &quot;done&quot;            this.githubProjects = filteredProjects        &#125; catch (error) &#123;            this.state = &quot;error&quot;        &#125;    &#125;&#125;const store = new Store()const projects = await flowResult(store.fetchProjects())\n\nComputers使用：\n\ncomputed （注解）\ncomputed(options) （注解）\ncomputed(fn, options?)\n\n计算值可以用来从其他可观察对象中派生信息。 计算值采用惰性求值，会缓存其输出，并且只有当其依赖的可观察对象被改变时才会重新计算。 它们在不被任何值观察时会被暂时停用。\n计算值可以通过在 JavaScript getters 上添加 computed 注解来创建。 使用 makeObservable 将 getter 声明为 computed。或者如果你希望所有的 getters 被自动声明为 computed，可以使用 makeAutoObservable，observable 或者 extendObservable\nimport &#123; makeObservable, observable, computed, autorun &#125; from &quot;mobx&quot;class OrderLine &#123;    price = 0    amount = 1    constructor(price) &#123;        makeObservable(this, &#123;            price: observable,            amount: observable,            total: computed        &#125;)        this.price = price    &#125;    get total() &#123;        console.log(&quot;Computing...&quot;)        return this.price * this.amount    &#125;&#125;const order = new OrderLine(0)const stop = autorun(() =&gt; &#123;    console.log(&quot;Total: &quot; + order.total)&#125;)// Computing...// Total: 0console.log(order.total)// (不会重新计算!)// 0order.amount = 5// Computing...// (无需 autorun)order.price = 2// Computing...// Total: 10stop()order.price = 3// 计算值和 autorun 都不会被重新计算.\n\n相比之下，如果 total 没有被注解，那么 autorun 会把副作用运行 3 次， 因为它将直接依赖于 total 和 amount\n\n上图是为以上示例创建的依赖图。\n规则使用计算值时，请遵循下面的最佳实践：\n\n它们不应该有副作用或者更新其他可观察对象。\n避免创建和返回新的可观察对象。\n它们不应该依赖非可观察对象的值\n\n使用 reactions 处理副作用 {🚀}为了理解 MobX，让我们看一下如何创建 reactions。 最简单的方式是使用 autorun 工具函数。 除此之外，还有 reaction 和 when\nAutorun用法：\n\nautorun(effect: (reaction) =&gt; void)\n\nautorun 函数接受一个函数作为参数，每当该函数所观察的值发生变化时，它都应该运行。 当你自己创建 autorun 时，它也会运行一次。它仅仅对可观察状态的变化做出响应，比如那些你用 observable 或者 computed 注释的。\ntracking 如何工作Autorun 通过在响应式上下文运行 effect 来工作。在给定的函数执行期间，MobX 会持续跟踪被 effect 直接或间接读取过的所有可观察对象和计算值。 一旦函数执行完毕，MobX 将收集并订阅所有被读取过的可观察对象，并等待其中任意一个再次发生改变。 一旦有改变发生，autorun 将会再次触发，重复整个过程。\n\n这就是下面的示例的工作方式。\nimport &#123; makeAutoObservable, autorun &#125; from &quot;mobx&quot;class Animal &#123;    name    energyLevel    constructor(name) &#123;        this.name = name        this.energyLevel = 100        makeAutoObservable(this)    &#125;    reduceEnergy() &#123;        this.energyLevel -= 10    &#125;    get isHungry() &#123;        return this.energyLevel &lt; 50    &#125;&#125;const giraffe = new Animal(&quot;Gary&quot;)autorun(() =&gt; &#123;    console.log(&quot;Energy level:&quot;, giraffe.energyLevel)&#125;)autorun(() =&gt; &#123;    if (giraffe.isHungry) &#123;        console.log(&quot;Now I&#x27;m hungry!&quot;)    &#125; else &#123;        console.log(&quot;I&#x27;m not hungry!&quot;)    &#125;&#125;)console.log(&quot;Now let&#x27;s change state!&quot;)for (let i = 0; i &lt; 10; i++) &#123;    giraffe.reduceEnergy()&#125;\n\n运行上面的代码，你将会看到下面的输出：\nEnergy level: 100I&#x27;m not hungry!Now let&#x27;s change state!Energy level: 90Energy level: 80Energy level: 70Energy level: 60Energy level: 50Energy level: 40Now I&#x27;m hungry!Energy level: 30Energy level: 20Energy level: 10Energy level: 0\n\nautorun会比较前后值是否发生了改变，如果没有发生改变，就不会执行，当值发生变化的时候，才会重新执行\nReaction用法：\n\nreaction(() =&gt; value, (value, previousValue, reaction) =&gt; &#123; sideEffect &#125;, options?).\n\n第一个参数，是指需要监听那个state的变化，第二个参数是当数据变化的时候需要执行的函数，reaction\n和autorun比较，autorun是针对所有的state，reaction是针对特定的state，而且reaction在初始化，不会执行，只有在state\n发生变化时才会执行\n在下面的例子中，reaction 只会在 isHungry 发生改变时被触发一次。 在 effect 函数中使用的 giraffe.energyLevel 的更改，并不会触发 effect 函数。如果你想要 reaction 也对这个值的变化做出反应， 你需要在 data 函数中访问并返回它。\nimport &#123; makeAutoObservable, reaction &#125; from &quot;mobx&quot;class Animal &#123;    name    energyLevel    constructor(name) &#123;        this.name = name        this.energyLevel = 100        makeAutoObservable(this)    &#125;    reduceEnergy() &#123;        this.energyLevel -= 10    &#125;    get isHungry() &#123;        return this.energyLevel &lt; 50    &#125;&#125;const giraffe = new Animal(&quot;Gary&quot;)reaction(    () =&gt; giraffe.isHungry,    isHungry =&gt; &#123;        if (isHungry) &#123;            console.log(&quot;Now I&#x27;m hungry!&quot;)        &#125; else &#123;            console.log(&quot;I&#x27;m not hungry!&quot;)        &#125;        console.log(&quot;Energy level:&quot;, giraffe.energyLevel)    &#125;)console.log(&quot;Now let&#x27;s change state!&quot;)for (let i = 0; i &lt; 10; i++) &#123;    giraffe.reduceEnergy()&#125;\n\n输出：\nNow let&#x27;s change state!Now I&#x27;m hungry!Energy level: 40\n\nWhen使用：\n\nwhen(predicate: () =&gt; boolean, effect?: () =&gt; void, options?)\nwhen(predicate: () =&gt; boolean, options?): Promise\n\nwhen 会观察并运行给定的 predicate 函数，直到其返回 true。 一旦 predicate 返回了 true，给定的 effect 函数就会执行并且自动执行器函数将会被清理掉。\n如果你没有传入 effect 函数，when 函数返回一个 Promise 类型的 disposer，并允许你手动取消\nwhen 对于以响应式的方式将值清理或取消掉十分有用。 例如：\nimport &#123; when, makeAutoObservable &#125; from &quot;mobx&quot;class MyResource &#123;    constructor() &#123;        makeAutoObservable(this, &#123; dispose: false &#125;)        when(            // Once...            () =&gt; !this.isVisible,            // ... then.            () =&gt; this.dispose()        )    &#125;    get isVisible() &#123;        // 表示此项目是否可见.    &#125;    dispose() &#123;        // 清理一些资源.    &#125;&#125;\n\n一旦 isVisible 变成 false，dispose 方法将会被调用， 并对 MyResource 做一些清理操作\nawait when(...)如果你没有提供 effect 函数，when 将会返回一个 Promise。这样会跟 async / await 很好地结合在一起，让你可以等待可观察对象中的变化。\nasync function() &#123;    await when(() =&gt; that.isVisible)    // etc...&#125;\n\n如果要提前取消 when，可以对它返回的 Promise 调用 .cancel() 函数。\n规则这里是一些 reactive context 需要遵守的规则：\n\n默认情况下，如果可观察对象发生了改变，受其影响的 reactions 会立即（同步）运行。然而，它们直到当前最外层的 (trans)action 执行结束后才会运行。\nautorun 只会跟踪给定函数在同步执行过程中所读取的可观察对象，不会跟踪异步发生的变化。\nautorun 不会跟踪被其调用的 action 所读取的可观察对象，因为 action 始终不会被追踪。\n\nAlways dispose of reactions传递给 autorun，reaction 和 when 的函数只有在它们观察的所有对象都被 GC 之后才会被 GC。原则上，它们一直等待可观察对象发生新的变化。 为了阻止 reactions 永远地等待下去，它们总是会返回一个 disposer 函数，该函数可以用来停止执行并且取消订阅所使用的任何可观察对象\nconst counter = observable(&#123; count: 0 &#125;)// 初始化一个 autorun 并且打印 0.const disposer = autorun(() =&gt; &#123;    console.log(counter.count)&#125;)// 打印: 1counter.count++// 停止 autorun.disposer()// 不会打印消息.counter.count++\n\n我们强烈建议你，一旦不再需要这些方法中的副作用时，请务必调用它们所返回的 disposer 函数。 否则可能导致内存泄漏。\nreaction 和 autorun 中 effect 函数的第二个参数 reaction 也可以被用来提前把 reaction 清理掉（通过调用 reaction.dispose()）。\nclass Vat &#123;    value = 1.2    constructor() &#123;        makeAutoObservable(this)    &#125;&#125;const vat = new Vat()class OrderLine &#123;    price = 10    amount = 1    constructor() &#123;        makeAutoObservable(this)        // 这个 autorun 将会和本 OrderLine 实例一起进行 GC,        // 因为它只使用了来自 `this` 的可观察对象.        // 所以不一定非要在删除 OrderLine 实例后立刻把它清理掉。        this.disposer1 = autorun(() =&gt; &#123;            doSomethingWith(this.price * this.amount)        &#125;)        // 这个 autorun 将不会和本 OrderLine 实例一起进行 GC,        // 因为 vat 保存了对这个 autorun 的引用用于通知改变,        // 这样反过来又会把 &#x27;this&#x27; 保存在作用域中。        this.disposer2 = autorun(() =&gt; &#123;            doSomethingWith(this.price * this.amount * vat.value)        &#125;)    &#125;    dispose() &#123;        // 所以, 为了避免内存问题, 当不再需要 reactions 之后        // 务必要调用 disposers.        this.disposer1()        this.disposer2()    &#125;&#125;\n\n谨慎地使用 reactions！就像上面已经说过的那样，你不会经常创建 reactions。 很有可能你的应用程序不会直接使用这些 API 中的任何一个，而只会通过比如使用 mobx-react 绑定中的 observer 这样间接的方式创建出 reaction。\n在你创建 reaction 之前，最好检查一下它是否符合下面几条原则：\n\n只有在引起副作用的一方与副作用之间没有直接关系的情况下才使用 reaction： 如果一个副作用会为了响应很小的一组 events 或 actions 而执行，那么直接从那些特定的 action 中触发这个副作用通常会更容易理解。例如，如果按下表单提交按钮会导致一个 POST 网络请求的发送，那么为了响应 onclick 事件，直接触发这个副作用就会比通过 reaction 间接触发更容易理解。相比之下，如果你对表单状态的一切修改最后都会被自动存储到 localStorage，那么使用一个 reaction 可能就会很有帮助，这样你就不用在每个独立的 onChange 事件中触发这个副作用了。\nreactions 不应该更新其他可观察对象：这个 reaction 是否会修改其他可观察对象？如果答案是肯定的，那么你一般应该把你想要更新的可观察对象注解为 computed 值。例如，如果一个待办事项的集合 todos 发生了变化，那么请不要使用 reaction 来计算剩余待办 remainingTodos 的数量，而要把 remainingTodos 注解为计算值。这将使得代码更容易理解和调试。reaction 不应该计算生成新的数据，而只应该触发副作用。\nreactions 应该是独立的：你的代码是否依赖其他必须首先运行的 reaction？如果发生这种情况，你可能违反了第一条规则， 你可以选择将你需要创建的新 reaction 合并到它所依赖 reaction 中。MobX 并不能保证 reaction 的执行顺序。\n\n有些实践并不符合上述原则。这就是为什么它们是原则，而不是法则。 但是，例外情况很少见，只有在万不得已的情况下才违反它们。\n","categories":["react","mobx"]},{"title":"mobx的使用3⃣️","url":"/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%89/","content":"","categories":["react","mobx"]},{"title":"mobx的使用二","url":"/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C/","content":"集成React（react-integration）用法:\nimport &#123; observer &#125; from &quot;mobx-react-lite&quot; // Or &quot;mobx-react&quot;.const MyComponent = observer(props =&gt; ReactElement)\n\nMobX 可以独立于 React 运行, 但是他们通常是结合在一起使用, 在 Mobx的宗旨（The gist of MobX） 一文中你会经常看见集成React最重要的一部分：用于包裹React Component的 observer HOC方法。\nobserver 是你可以自主选择的，在安装时（during installation）独立提供的 React bindings 包。 在下面的例子中,我们将使用更加轻量的mobx-react-lite 包。\nimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import &#123; makeAutoObservable &#125; from &quot;mobx&quot;import &#123; observer &#125; from &quot;mobx-react-lite&quot;class Timer &#123;    secondsPassed = 0    constructor() &#123;        makeAutoObservable(this)    &#125;    increaseTimer() &#123;        this.secondsPassed += 1    &#125;&#125;const myTimer = new Timer()//被`observer`包裹的函数式组件会被监听在它每一次调用前发生的任何变化const TimerView = observer((&#123; timer &#125;) =&gt; &lt;span&gt;Seconds passed: &#123;timer.secondsPassed&#125;&lt;/span&gt;)ReactDOM.render(&lt;TimerView timer=&#123;myTimer&#125; /&gt;, document.body)setInterval(() =&gt; &#123;    myTimer.increaseTimer()&#125;, 1000)\n\nobserver HOC 将自动订阅 React components 中任何 在渲染期间 被使用的 可被观察的对象 。 因此, 当任何可被观察的对象 变化 发生时候 组件会自动进行重新渲染（re-render）。 它还会确保组件在 没有变化 发生的时候不会进行重新渲染（re-render）。 但是, 更改组件的可观察对象的不可读属性, 也不会触发重新渲染（re-render）。\n在实际项目中，这一特性使得MobX应用程序能够很好的进行开箱即用的优化，并且通常不需要任何额外的代码来防止过度渲染。\n要想让observer生效, 并不需要关心这些对象 如何传递到 组件的（它们只要能传递给组件即可 ·译者注）, 只需要关心他们是否是可读的。 深层嵌套的可观察对象也没有问题, 复杂的表达式类似 todos[0].author.displayName 也是可以使用的。 与其他必须显式声明或预先计算数据依赖关系的框架（例如 selectors）相比，这种发生的订阅机制就显得更加精确和高效。\nobserver 组件中使用外部状态 （Using external state in observer components）使用props的方式\n可被观察对象可以通过组件的props属性传入 (在下面的例子中):\nimport &#123; observer &#125; from &quot;mobx-react-lite&quot;const myTimer = new Timer() // See the Timer definition above.const TimerView = observer((&#123; timer &#125;) =&gt; &lt;span&gt;Seconds passed: &#123;timer.secondsPassed&#125;&lt;/span&gt;)// 通过props传递myTimer.ReactDOM.render(&lt;TimerView timer=&#123;myTimer&#125; /&gt;, document.body)\n\n使用全局变量的方式\n虽然我们不关心是 如何 引用（reference）的可观察对象,但是我们可以使用 （consume） 外部作用域（outer scopes directly）的可观察对象 (类似通过 import这样的方法, 等等)：\nconst myTimer = new Timer() //  Timer 定义在上面.// 没有props, `myTimer` 立刻变成了闭包。const TimerView = observer(() =&gt; &lt;span&gt;Seconds passed: &#123;myTimer.secondsPassed&#125;&lt;/span&gt;)ReactDOM.render(&lt;TimerView /&gt;, document.body)\n\n直接使用可观察对象效果很好，但是这通常会是通过模块引入，这种写法可能会使单元测试变得复杂。 因此，我们建议使用React Context。\n使用React Context共享整个可观察子树是一种很不错的选择：\nimport &#123;observer&#125; from &#x27;mobx-react-lite&#x27;import &#123;createContext, useContext&#125; from &quot;react&quot;const TimerContext = createContext&lt;Timer&gt;()const TimerView = observer(() =&gt; &#123;    // 从context中获取timer.    const timer = useContext(TimerContext) // 可以在上面查看 Timer的定义。    return (        &lt;span&gt;Seconds passed: &#123;timer.secondsPassed&#125;&lt;/span&gt;    )&#125;)ReactDOM.render(    &lt;TimerContext.Provider value=&#123;new Timer()&#125;&gt;        &lt;TimerView /&gt;    &lt;/TimerContext.Provider&gt;,    document.body)\n\n需要注意的是我们并不推荐每一个不同的 值（value） 都通过不同的 Provider来传递 . 在使用Mobx的过程中不需要这样做, 因为共享的可观察对象会更新他自己。\n在observer 组件中使用全局可观察对象（Using local observable state in observer components）因为使用 observer 的可观察对象可以来自任何地方, 他们也可以使用local state（全局的state·译者注）。 再次声明，不同操作方式对于我们而言都是有价值的。\n使用全局可观察对象的最简单的方式就是通过useState去存储一个全局可观察对象的引用。 需要注意的是, 因为我们不需要替换全局可观察对象的引用,所以我们其实可以完全不声明useState的更新方法:\nimport &#123; observer &#125; from &quot;mobx-react-lite&quot;import &#123; useState &#125; from &quot;react&quot;const TimerView = observer(() =&gt; &#123;    const [timer] = useState(() =&gt; new Timer()) // Timer的定义在上面（正如上面所说的那样这里我们忽略了更新方法的定义·译者注）。    return &lt;span&gt;Seconds passed: &#123;timer.secondsPassed&#125;&lt;/span&gt;&#125;)ReactDOM.render(&lt;TimerView /&gt;, document.body)\n\n如果你想要类似我们官方的例子那样自动更新 timer , 使用useEffect 可能是 React 中比较典型的写法：\nuseEffect(() =&gt; &#123;    const handle = setInterval(() =&gt; &#123;        timer.increaseTimer()    &#125;, 1000)    return () =&gt; &#123;        clearInterval(handle)    &#125;&#125;, [timer])\n\n如刚才说的那样, 直接创建一个可观察的对象，而不是使用classes（这里的类指的是全局定义的Mobx state，在它们是使用class声明的）。 我们可以参考 observable这篇文章：\nimport &#123; observer &#125; from &quot;mobx-react-lite&quot;import &#123; observable &#125; from &quot;mobx&quot;import &#123; useState &#125; from &quot;react&quot;const TimerView = observer(() =&gt; &#123;    const [timer] = useState(() =&gt;        observable(&#123;            secondsPassed: 0,            increaseTimer() &#123;                this.secondsPassed++            &#125;        &#125;)    )    return &lt;span&gt;Seconds passed: &#123;timer.secondsPassed&#125;&lt;/span&gt;&#125;)ReactDOM.render(&lt;TimerView /&gt;, document.body)\n\nconst [store] = useState(() =&gt; observable(&#123; /* something */&#125;)) 是非常通用的一套写法， 为了简化这个写法我们可以调用mobx-react-lite 包中的 useLocalObservable hook ,可以将上面的例子简化成：\nimport &#123; observer, useLocalObservable &#125; from &quot;mobx-react-lite&quot;import &#123; useState &#125; from &quot;react&quot;const TimerView = observer(() =&gt; &#123;    const timer = useLocalObservable(() =&gt; (&#123;        secondsPassed: 0,        increaseTimer() &#123;            this.secondsPassed++        &#125;    &#125;))    return &lt;span&gt;Seconds passed: &#123;timer.secondsPassed&#125;&lt;/span&gt;&#125;)ReactDOM.render(&lt;TimerView /&gt;, document.body)\n\n不要将可观察对象传递到 不是observer的组件中（Don’t pass observables into components that aren’t observer）通过observer包裹的组件 只可以 订阅到在 他们自己 渲染的期间的可观察对象. 如果要将可观察对象 objects &#x2F; arrays &#x2F; maps 传递到子组件中, 他们必须被 observer 包裹。 通过callback回调的组件也是一样。\n如果你非要传递可观察对象到未被observer包裹的组件中， 要么是因为它是第三方组件，要么你需要组件对Mobx无感知，那你必须在传递前 转换可观察对象为显式 （convert the observables to plain JavaScript values or structures） 。\n关于上述的详细描述, 可以看一下下面的使用 todo 对象的例子， 一个 TodoView (observer)组件和一个虚构的接收一组对象映射入参的不是observer的GridRow组件\nclass Todo &#123;    title = &quot;test&quot;    done = true    constructor() &#123;        makeAutoObservable(this)    &#125;&#125;const TodoView = observer((&#123; todo &#125;: &#123; todo: Todo &#125;) =&gt;   // 错误: GridRow 不能获取到 todo.title/ todo.done 的变更   //       因为他不是一个观察者（observer。   return &lt;GridRow data=&#123;todo&#125; /&gt;   // 正确:在 `TodoView` 中显式的声明相关的`todo` ，   //      到data中。   return &lt;GridRow data=&#123;&#123;       title: todo.title,       done: todo.done   &#125;&#125; /&gt;   // 正确: 使用 `toJS`也是可以的, 并且是更清晰直白的方式。   return &lt;GridRow data=&#123;toJS(todo)&#125; /&gt;)\n\n回调组件可能会需要&lt;Observer&gt;（ Callback components might require &lt;Observer&gt;）想象一下在同样的例子中, GridRow 携带一个 onRender回调函数。 onRender 是 GridRow渲染生命周期的一部分, 而不是 TodoView 的render (甚至在语法层面都能看出来)，我们不得不保证回调组件是一个 observer 组件。 或者，我们可以使用 &#96;&#96;创建一个匿名观察者：\nconst TodoView = observer((&#123; todo &#125;: &#123; todo: Todo &#125;) =&gt; &#123;    // 错误: GridRow.onRender 不能获得 todo.title / todo.done 中的改变    //        因为它不是一个观察者（observer） 。    return &lt;GridRow onRender=&#123;() =&gt; &lt;td&gt;&#123;todo.title&#125;&lt;/td&gt;&#125; /&gt;    // 正确: 将回调组件通过Observer包裹将会正确的获得变化。    return &lt;GridRow onRender=&#123;() =&gt; &lt;Observer&gt;&#123;() =&gt; &lt;td&gt;&#123;todo.title&#125;&lt;/td&gt;&#125;&lt;/Observer&gt;&#125; /&gt;&#125;)\n\nmobx-react vs. mobx-react-lite\n在本文中我们使用 mobx-react-lite 作为默认包。 mobx-react 是他的大兄弟，它里面也引用了 mobx-react-lite 包。 它提供了很多在新项目中不再需要的特性， mobx-react附加的特性有：\n\n对于React class components的支持。\nProvider 和inject. MobX的这些东西在有 React.createContext 替代后变得不必要了。\n特殊的观察对象 propTypes。\n\n要注意 mobx-react 是全量包，也会暴露 mobx-react-lite包中的任何方法,其中包含对函数组件的支持。 如果你使用 mobx-react，那就不要添加 mobx-react-lite 的依赖和引用了。\nobserver 🆚 React.memo\nobserver 会自动的使用 memo, 所以 observer 不需要再包裹 memo。 memo 会被 observer 组件安全的使用，因为任何在props中的改变(很深的) 都会被observer响应。\n应用observer 到基于class的组件\n如上所述，class 组件只在mobx-react包中得到支持， mobx-react-lite并不支持。 简而言之，你可以和函数式组件一样使用 observer包裹class 组件：\nimport React from &quot;React&quot;const TimerView = observer(    class TimerView extends React.Component &#123;        render() &#123;            const &#123; timer &#125; = this.props            return &lt;span&gt;Seconds passed: &#123;timer.secondsPassed&#125; &lt;/span&gt;        &#125;    &#125;)\n\n可以阅读 mobx-react 文档 获得更详细的信息。\n当你想要将observer 和其他高阶组件（HOC·译者注）一起使用, 需要首先调用 observer\n当 observer 需要和装饰器或者其他高阶组件（HOC）一起使用时，请确保 observer 是最内层的 (最先调用的) 装饰器，否则的话它可能不会工作\n从 props导出计算属性\n在某些情况下你的组件本地可观察对象（local observables）的计算属性可能依赖于一些你组件接受到的参数（props）。 但是,这一系列从React组件接收到的参数（props）本身并不是可观察对象，所以更改这些组件的属性（props）并不会使得计算属性响应。你可能需要手动的从最新的数据来更新全局可观察对象的状态来触发计算属性更新。\nimport &#123; observer, useLocalObservable &#125; from &quot;mobx-react-lite&quot;import &#123; useEffect &#125; from &quot;react&quot;const TimerView = observer((&#123; offset &#125;) =&gt; &#123;    const timer = useLocalObservable(() =&gt; (&#123;        offset, // 初始化offset        secondsPassed: 0,        increaseTimer() &#123;            this.secondsPassed++        &#125;,        get offsetTime() &#123;            return this.secondsPassed - this.offset // 这里的&#x27;offset&#x27;不是&#x27;props&#x27;传入的那个        &#125;    &#125;))    useEffect(() =&gt; &#123;        //同步来自 &#x27;props&#x27; 的偏差到可观察对象 &#x27;timer&#x27;        timer.offset = offset    &#125;, [offset])    //作为demo用途，初始化一个定时器.    useEffect(() =&gt; &#123;        const handle = setInterval(timer.increaseTimer, 1000)        return () =&gt; &#123;            clearInterval(handle)        &#125;    &#125;, [])    return &lt;span&gt;Seconds passed: &#123;timer.offsetTime&#125;&lt;/span&gt;&#125;)ReactDOM.render(&lt;TimerView /&gt;, document.body)\n\n在实际项目中你可能很少需要这种写法, 因为 return &lt;span&gt;Seconds passed: &#123;timer.secondsPassed - offset&#125;&lt;/span&gt; 更加简单, 虽然是稍微低效率的解决方案。\nuseEffect 与 可观察对象\nuseEffect 可以被用于触发需要发生的副作用, 它将会被约束在React 组建的生命周期中。 使用 useEffect需要指定详细的依赖。 对于 MobX 却不是必须的, 因为 MobX 拥有一种真正的能检查到依赖发发生的方法， autorun。 结合 autorun可以很轻松的在生命周期组件中使用useEffect：\nimport &#123; observer, useLocalObservable, useAsObservableSource &#125; from &quot;mobx-react-lite&quot;import &#123; useState &#125; from &quot;react&quot;const TimerView = observer(() =&gt; &#123;    const timer = useLocalObservable(() =&gt; (&#123;        secondsPassed: 0,        increaseTimer() &#123;            this.secondsPassed++        &#125;    &#125;))    // 在Effect方法之上触发可观察对象变化。    useEffect(        () =&gt;            autorun(() =&gt; &#123;                if (timer.secondsPassed &gt; 60) alert(&quot;Still there. It&#x27;s a minute already?!!&quot;)            &#125;),        []    )    // 作为demo用途在Effect里定义一个定时器。    useEffect(() =&gt; &#123;        const handle = setInterval(timer.increaseTimer, 1000)        return () =&gt; &#123;            clearInterval(handle)        &#125;    &#125;, [])    return &lt;span&gt;Seconds passed: &#123;timer.secondsPassed&#125;&lt;/span&gt;&#125;)ReactDOM.render(&lt;TimerView /&gt;, document.body)\n\n需要注意的是我们在effect方法返回了一个创建自autorun 的清除方法。 这一点是非常重要的, 因为他确保了 autorun 在组件卸载的时候被清除了！\n依赖数组可以保持为空，除非是一个不可观察对象的值需要触发autorun重新运行，你才需要将它添加到这里面。 请确保你的格式正确,你可以创建一个定时器（timer） (上面的例子中) 作为依赖。 这是安全并且无副作用的， 因为它引用的依赖根本不会改变。\n如果你不想显式的在Effect中定义可观察对象请使用reaction而不是autorun，他们的传参是完全相同的。\n优化React组件渲染 {🚀}","categories":["react","mobx"]},{"title":"node学习笔记","url":"/2022/09/09/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"1.node的输出\tconsole.log()\tconsole.clear()\tconsole.trace()2.常见的全局对象\t特殊的全局对象，是各个模块都有的，但不是属于全局的\t__dirname//获取当前文件所在的路径，不包括后面的文件名\t__filename//获取当前文件所在的路径名称包括文件名\texports\tmodule\trequire\t\t常见的全局对象\t\tprocess对象\t\tconsole对象\t\t定时器对象3.global和window的区别\tnode中每一个文件都是一个独立的模块4.模块化\t立即调用函数(IIFE)是解决模块化的一种方式\tCommonJS(CJS)\tESmodule\t每个模块都有exports,他会默认指向空对象,exports指向的一个对象并在另外一个模块中被引用时，他们是指向同一个对象\trequire是对exports的浅拷贝\t浅拷贝的本质就是引用赋值\texports中修改变量会使require发生变化\trequire中的修改不会对exports造成影响，因为require是对exports的拷贝5.module.exports\t每一个模块都有一个module实例\tcommomjs中没有module.export的概念，node中使用的是Moudle类，每一个模块都是Modlue的实例，也是module\t所以在Node中真正导出的其实不是export,而是module.exports\t为什么exports也可以导出\t\t因为module对象的exports属性是export对象的一个引用，也就是module.exports=exports\t\tmodule.export导出的值才是require的值，默认module.export==export,如果module.export指向另外一个值，则require会引用这个值，而不是export的值\tmodule.export的赋值是在顶层的\t\tmodule.exports=exports\t\texports=123//module.exports在顶层引用的，如果后面再次修改exports的指向，则会无效6.require()的查找规则\t1.如果x是核心模块，直接会返回核心模块，require(&quot;x&quot;)//会直接返回，停止查找\t2.x是以./或者../或者/开头的\t\t会先将x当作一个文件先查找，如果有后缀名，则按后缀名格式查找，如果没有后缀名则\t\t\t1.直接查找文件x\t\t\t2.查找x.js\t\t\t3.查找x.json\t\t\t4.查找x.node\t\t如果没有找到对应的文件，则会把他当成一个目录，查找里面的index文件\t\t\t1.x/index.js\t\t\t2.x/index.json\t\t\t3.x/index.node\t\t否则报错 not found\t3.如果直接是一个X(没有路径) 并且X不是一个核心模块\t则从最里面的node_module-&gt;最外面的node_module中去寻找7.require的加载过程是同步的 8.module.export=&#123;&#125; exports=module.export===export=&#123;&#125; module.export=exports9.在源码中exports=module.exports10.模块的加载过程\t模块在被第一次引入时，模块中的js代码会被运行一次\t模块被对此引入时，会被缓存，最终只会被加载一次\t如果有循环引入，他会按深度优先搜索遍历的方式进行加载11.ES modules中\texport &#123;&#125;//不是一个对象，里面放置要到处的变量的列表\timport默认必须放到顶部，import是异步加载，import加载模块不可以放到逻辑代码中\timport().then()//进行动态加载12.commonJS加载过程\tcommonjs加载js文件的过程是运行时加载，并且是同步的，就是js引擎在执行代码的过程中加载模块\t同步意味着一个文件在没有加载结束之前，后面的代码都不加在\tcommonjs通过module.exports的导出一个对象，导出的是一个对象意味者可以将这个对象的引用在其他模块中赋值给其他变量，但是最终他们会指向同一个变量，那么一个变量修改了对象的属性，所有地方都会修改\t注意：require进行解构的时候不会修改，因为解构会固定下当前的值13.ES module的加载过程   ES MODULE加载js是编译的时候加载的，并且是异步的   编译时加载意味着import不能和运行相关的内容放在一起使用   比如from后面的路径要动态获取   比如不能将import放到if语句的代码块里面，所以es module时静态解析   异步意味着js引擎遇到import时会获取到这个js文件，但是这个获取的过程是异步的，并不会阻塞进程的执行   type-=module相当于script上的async属性，如果后面还有js代码，他不会阻塞js代码的执行   ES Module通过export导出的是变量本身的引用：\t export在导出一个变量时，js引擎会解析这个语法，并且创建模块环境记录（module environment record）； 模块环境记录会和变量进行 绑定（binding），并且这个绑定是实时的； 而在导入的地方，我们是可以实时的获取到绑定的最新值的；  所以，如果在导出的模块中修改了变化，那么导入的地方可以实时获取最新的变量；  注意：在导入的地方不可以修改变量，因为它只是被绑定到了这个变量上（其实是一个常量）   14.在node中要使用es module \t方式一：package.json中配置type:module \t方式二:使用以.mjs结尾的文件 15.内置模块path \t\t从路径获取信息 \t\t\tdirname()//获取文件的父文件夹 \t\t\tbasename()//获取文件名 \t\t\textname()//获取文件扩展名 \t\t路径的拼接 \t\t\t如果我们希望将多个路径进行拼接，但是不同的操作系统可能是使用不同的分隔符 \t\t\t这个时候我们可以使用path.join函数 \t\t将文件和某个文件夹拼接 \t\t\t如果我们希望将某个文件和文件夹拼接，可以使用path.resolve \t\t\tresolve函数会判断我们拼接的路径前面是否有/或者../或者./ \t\t\t如果有表示是一个绝对路径，会返回对应的拼接路径 \t\t\t如果没有，那么会和当前执行文件所在的文件夹进行路径的拼接 \t\t\tpath.resolve() 方法将路径或路径片段的序列解析为绝对路径。 \t\t\t如果没有传入 path 片段，则 path.resolve() 将返回当前工作目录的绝对路径。 \t\t\t \t\t\tpath.resolve(&#x27;/foo/bar&#x27;, &#x27;./baz&#x27;);            // 返回: &#x27;/foo/bar/baz&#x27;            path.resolve(&#x27;/foo/bar&#x27;, &#x27;/tmp/file/&#x27;);            // 返回: &#x27;/tmp/file&#x27;            path.resolve(&#x27;wwwroot&#x27;, &#x27;static_files/png/&#x27;, &#x27;../gif/image.gif&#x27;);            // 如果当前工作目录是 /home/myself/node，            // 则返回 &#x27;/home/myself/node/wwwroot/static_files/gif/image.gif&#x27; 16.fs模块 \tfs操作文件的三种方式\n\n\n17.文件描述符\n​\t在POSIX系统上，对于每个进程，内核都维护者一张当前打开的资源和文件的表格\n​\t每个打开的文件都会分配一个称为文件秒师傅的简单数字标识符\n​\t在系统层，所有系统操作都是使用这些文件描述符来标识和跟踪每一个特定文件\n​\twindows系统有不同的机制\n​\tfs.open()用于分配新的文件描述符，一旦被分配，则文件描述符可用于文件的读取数据，向文件写入数据或者请求关于文件的信息\n\n18.文件的读写\n​\t\nfs.readFile(path,options?,callback)   //读取文件的内容fs.writeFile(file,data,options?,callback) //写入文件\n\n\noptions中的属性flag:写入的方式\tw:打开文件写入，默认值\tw+:打开文件进行读写，如果不存在则会创建文件\tr+:打开文件进行读写，如果不存在就会抛出异常\tr:打开文件读取，读取时的默认值\ta:打开要写入的文件，将流放在文件的末尾，如果不存在则会创建文件\ta+:打开文件进行读写，将流放到文件末尾，如果不存在则创建encoding:字符的编码\t现在基本上使用utf-8\t如果不填encoding则会返回buffer\n\n19.文件夹的操作\n20.events模块\n​\t Node中的核心API都是基于异步事件驱动的：\n​\t 发出事件和监听事件都是通过EventEmitter类来完成，他们都是属于events对象\n​\t  \nconst emitter=new EventEmitter()emitter.on(eventName.listener)//监听事件，也可以使用addListeneremitter.off(eventName.listener)//移出事件监听，也可以使用removeLiteneremitter.emit(eventName,...args?)//发出事件，可以携带参数\n\n\nemitter.once(eventName,listener)事件只监听一次emitter.prependListener()将监听事件添加到最前面emitter.prependOnceListener()将监听事件添加到最前面但只监听一次emitter.removeAllListeners(eventName?)移除所有事件\n\n21、npm包管理工具\n​\t\t\tnpm run start&#x3D;&gt;npm start\n​\t\t\tnpm run test&#x3D;&gt;npm test\n​\t\t\tnpm run stop&#x3D;&gt;npm stop\n​\t\t\tnpm run restart&#x3D;&gt;npm restart\n22.npm config get cache &#x2F;&#x2F;cmd中执行查看缓存所在目录\n23.Buffer类\n​\t使用Buffer来存储二进制\n​\tbuf&#x3D;Buffer.from()&#x2F;&#x2F;转换成buffer\n​\t中文会转换成unicode编码  3个unicode编码代表一个汉字 默认是utf8编码\n​\tbuf.toString([encoding[, start[, end]]])&#x2F;&#x2F;解码 encode默认是utf8\n​\tbuffer的另外一种创建方式\n​\tBuffer.alloc(size[, fill[, encoding]]) size表示创建的大小 默认是utf8\n​\tbuffer可以将图片转换成二进制流进行传输，也可以把二进制转换成图片存储\n24.读取文件返回的是一个二进制流\n25.读取图片并且写入到另外一个文件\n26.sharp插件进行设置图片\n27.Buffer的创建过程\n​\t事实上我们创建Buffer时，并不会频繁的向操作系统申请内存，它会默认先申请一个8 * 1024个字节大小的内存， 也就是8kb\n28.Buffer的源码\n29.进程和线程\n​\t进程:启动一个程序，既可以默认开启一个进程（也可以多进程）\n​\t线程：操作系统能够运行调度的最小单位\n30.Node事件循环的阶段\n​\t 一次完整的事件循环Tick分成很多个阶段\n​\t定时器(Timer):本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数\n​\t待定回调（Pending Callback）：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到 ECONNREFUSED\n​\tidle, prepare：仅系统内部使用\n​\t轮询（Poll）：检索新的 I&#x2F;O 事件；执行与 I&#x2F;O 相关的回调\n​\t检测：setImmediate() 回调函数在这里执行\n​\t关闭的回调函数：一些关闭的回调函数，如：socket.on(‘close’, …)\n31.Node的微任务和宏任务\n​\t微任务队列\n​\tnettick queue:process.nextTick\n​\tother queue:Promise的then回调，queueMicrotask\n​\t宏任务队列\n​\ttimer queue:setTimeout,setInterval\t\n​\tpoll queue :IO事件\n​\tcheck queue:setImmediate\n​\tclose queue:close事件\n32.Stream可以读取或者写入部分\n​\t4.中基本的流类型\n​\t\twritable:可以向其写人数据的流 fs.createWriteStream()\n​\t\tReadable:可以从中读取数据的流 fs.createReadStream()\n​\t\tDuplex：同时为Readable和wratable net.Socket\n​\t\tTransform:Duplex可以在写入和读取数据时修改或者转换数据的流  zlib.createDeflate()\n33.Readable\n34.writable\n35.pipe\n从读取到输出到另外一个文件也可以这么写\n36.http\n安装nodemon来热更新自动启动\n37.axios可以在浏览器用也可以在node中用，浏览器用的是xhr,node中使用的是http内置模块\n38.文件上传\n39.express\n​\t\texpress核心是中间件\n​\t\t安装express\n​\t\t1.创建一个文件夹 \n​\t\t2.npx express-generator\n​\t\t3.npm install\n​\t\t4.DEBUG&#x3D;express:* npm start\n​\t\t第二种安装方式\nnpm initnpm install express\n\n40.中间件\n41.文件上传\n​\t使用multer  npm install multer\n42.打印日志\n​\t使用morgan npm install morgan\n43express路由\n44.使用express部署静态资源，将express作为静态资源服务器\n45.错误处理\n46.调用express()到底创建的是什么\n47.app.listen()启动服务器\n​\t\t如何可以结合原生来启动服务器\n​\t\texpress-&gt;http.createServer.listen\n48.app.use(中间件)内部发生了什么\n49.用户发送了请求，中间件是如何被回调\n50.next的为什么会执行下一个中间件\n51.koa洋葱模型\n​\t\tkoa的同步和异步都是符合洋葱模型的\n​\t\texpress只有同步代码才会符合洋葱模型\n52.koa和express的区别\n​\t\n","categories":["node","note"]},{"title":"pinia笔记","url":"/2022/08/23/pinia%E7%AC%94%E8%AE%B0/","content":"Pinia和Vuex的区别Pinia主要是来替代Vuex的，pinia有更加简单的api，提供了composition api,和typesctript一起使用有更加可靠的类型推断支持\n和vuex相比，pinia有很多优势\n例如mutation不再存在\n更好的typescript支持，vuex之前对ts的支持很不友好\n不再有modules的嵌套解构，你可以灵活的使用每一个store，他们是通过扁平化的方式来进行相互使用\n不再有命名空间的概念，不需要记住他们的复杂关系\n安装yarn add pinia# or with npmnpm install pinia\n\n使用在vue3+vite中的使用\nstores&#x2F;index.js\nimport &#123; createPinia &#125; from &#x27;pinia&#x27;const pinia = createPinia()export default pinia\n\nmain.js\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import pinia from &#x27;./stores&#x27;createApp(App).use(pinia).mount(&#x27;#app&#x27;)\n\n认识Store什么是store一个store是一个实体，他会持有为绑定到组件树的状态和业务逻辑，换句话说，它托管全局状态。它有点像一个始终存在并且每个人都可以读取和写入的组件。你可以定义任意个store来管理你的状态。\nstore有三个核心概念state，actions，getters，对应者数组的data，computed，methods\n一旦store被实例化，你就可以直接在store上访问state，getters，actions中的任意属性\n定义Storeimport &#123; defineStore &#125; from &#x27;pinia&#x27;const useUser = defineStore(&quot;user&quot;, &#123;  state: () =&gt; (&#123;    name: &quot;why&quot;,    age: 18,    level: 100  &#125;)&#125;)export default useUser//使用defineStore来定义store\n\n与Vue的Option API 类型类似的写法\nexport const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;  state: () =&gt; (&#123; count: 0, name: &#x27;Eduardo&#x27; &#125;),  getters: &#123;    doubleCount: (state) =&gt; state.count * 2,  &#125;,  actions: &#123;    increment() &#123;      this.count++    &#125;,  &#125;,&#125;)\n\n还有一种和setup函数类似的方法。我们可以传入一个定义响应式属性和方法的函数，并返回一个包含我们想要公开的属性和方法的对象。\nexport const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123;  const count = ref(0)//state  const name = ref(&#x27;Eduardo&#x27;)  const doubleCount = computed(() =&gt; count.value * 2)//getters  function increment() &#123;    count.value++  &#125;//actions  return &#123; count, name, doubleCount, increment &#125;&#125;)\n\n在组件中的使用\n&lt;script setup&gt;  import &#123; toRefs &#125; from &#x27;vue&#x27;  import &#123; storeToRefs &#125; from &#x27;pinia&#x27;  import useCounter from &#x27;@/stores/counter&#x27;;  const counterStore = useCounter()//如果需要解构state并保持响应性，可以使用toRefs/storeToRefs// const &#123; count &#125; = toRefs(counterStore)  const &#123; count &#125; = storeToRefs(counterStore)  function incrementCount() &#123;    counterStore.count++  &#125;&lt;/script&gt;\n\nstate的使用const store = useStore()store.count++\n\n重置state\nconst store = useStore()store.$reset()\n\n // 1.一个个修改状态     userStore.name = &quot;kobe&quot;     userStore.age = 20     userStore.level = 200    // 2.一次性修改多个状态     userStore.$patch(&#123;       name: &quot;james&quot;,       age: 35     &#125;)  //$patch还可以传入一个函数  cartStore.$patch((state) =&gt; &#123;  state.items.push(&#123; name: &#x27;shoes&#x27;, quantity: 1 &#125;)  state.hasChanged = true&#125;)\n\n替换state\n你不能替换整个state,可以整合它\nstore.$patch(&#123; count: 24 &#125;)\n\nGettersgetters: &#123;    // 1.基本使用    doubleCount(state) &#123;      return state.count * 2    &#125;,    // 2.一个getter引入另外一个getter    doubleCountAddOne() &#123;      // this是store实例      return this.doubleCount + 1    &#125;,    // 3.getters也支持返回一个函数    getFriendById(state) &#123;      return function(id) &#123;        for (let i = 0; i &lt; state.friends.length; i++) &#123;          const friend = state.friends[i]          if (friend.id === id) &#123;            return friend          &#125;        &#125;      &#125;    &#125;,    // 4.getters中用到别的store中的数据    showMessage(state) &#123;      // 1.获取user信息      const userStore = useUser()      // 2.获取自己的信息      // 3.拼接信息      return `name:$&#123;userStore.name&#125;-count:$&#123;state.count&#125;`    &#125;  &#125;,\n\nActionsactions相当于是methods\nexport const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;  state: () =&gt; (&#123;    count: 0,  &#125;),  actions: &#123;    // since we rely on `this`, we cannot use an arrow function      //这里依赖this,所以不能使用箭头函数    increment() &#123;      this.count++    &#125;,    randomizeCounter() &#123;      this.count = Math.round(100 * Math.random())    &#125;,  &#125;,&#125;)\n\n在actions中可以定义异步函数\nimport &#123; mande &#125; from &#x27;mande&#x27;const api = mande(&#x27;/api/users&#x27;)export const useUsers = defineStore(&#x27;users&#x27;, &#123;  state: () =&gt; (&#123;    userData: null,    // ...  &#125;),  actions: &#123;    async registerUser(login, password) &#123;      try &#123;        this.userData = await api.post(&#123; login, password &#125;)        showTooltip(`Welcome back $&#123;this.userData.name&#125;!`)      &#125; catch (error) &#123;        showTooltip(error)        // let the form component display the error        return error      &#125;    &#125;,  &#125;,&#125;)\n","categories":["vue","note"]},{"title":"react-router-v6笔记","url":"/2022/09/08/react-router-v6%E7%AC%94%E8%AE%B0/","content":"1.前端路由的原理\t当url发生变化的时候，引起页面不刷新来修改页面的内容的两个方法\t\t1.通过修改url中的hash的变化来修改页面的内容\t\t\twindow.onhashchange=function()&#123;\t\t\t\tswitch(location.hash)&#123;\t\t\t\t\tcase &quot;#/a&quot;:\t\t\t\t\tdiv.innerHTML=&quot;&quot;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t//url的hash也就是锚点。本质上就是修改了window.location的href\t\t//可以通过直接赋值location.hash来改变href.但是页面不会刷新，\t\t//但是hash会带有#\t\t2.可以使用HTML5的history模式来修改url,他有六种模式来改变URL的变化而不刷新页面\t\t\thistory.replactState():替换原来的路径\t\t\thistory.pushState():使用新的路径\t\t\thistory.popState():路径的回退\t\t\thistory.go():向前或者向后改变路径\t\t\thistory.back():向后改变路径\t\t\t\n\n\n2.react-router有两部分组成\t1.react-router//这是核心代码\t2.react-router-dom//这是用于浏览器的\t3.react-router-native//这个适用于原生应用\t使用react-router需要使用npm install react-router-dom 他会自动安装react-router\t3.react-router的组件使用\t&lt;BrowserRouter&gt;是使用history模式\timport * as React from &quot;react&quot;;    import * as ReactDOM from &quot;react-dom&quot;;    import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;    ReactDOM.render(      &lt;BrowserRouter&gt;        &lt;App/&gt;      &lt;/BrowserRouter&gt;,      root    );//这就是目前比较普遍的用法，也是官方比较推荐的用法，将他包裹在App组件   3.1&lt;HashRouter&gt;是使用hash模式，官方不推荐使用   3.2&lt;link&gt;组件是跳转的组件，它最终会被渲染成a元素   3.3&lt;NavLink&gt;是在Link的基础上增加了一些样式   \t\t3.3.1 to属性是Link和NavLink组件中最重要的属性，用于设置跳转的路径   3.4.Route组件   \t\t3.4.1 Route组件主要适用于路由路径的匹配   \t\t3.4.2 path属性:用于设置匹配到的路径   \t\t3.4.3 component属性：设置匹配到的路径后渲染的组件，   \t\t3.4.4.exact:精准匹配   \t\t上述的属性属于v5的版本   \t\t在v6版本中所有&lt;Route&gt;组件将放在&lt;Routes&gt;中，component改成element,   \n\n\n\n\n&lt;NavLink&gt;的用法用于可以处于当前访问连接时修改连接的样式，处于active状态v5的写法可以添加如下属性activeStyle:活跃时的样式activeClassName：活跃时添加classexact精确匹配也可以使用自定义class\n\n\nv6的写法，不需要activeStyle和activeClassName，可以在普通的style和className中传入一个函数，更加灵活方便\n\nSwitch的作用 V5 在V6没有该组件\n\n组件中获取路由参数，params中存在对饮的路由参数\nconst params = useParams()\n\nNavigate导航Navigate用于路由的重定向\n&lt;Route path=&#x27;/home&#x27; element=&#123;&lt;Navigate to=&quot;/home/recommend&quot;/&gt;&#125;/&gt;\n\nNot Found页面配置&lt;Route path=&#x27;*&#x27; element=&#123;&lt;NotFound/&gt;&#125;/&gt;\n\nSearch Params\nuseNavigateimport &#123; useNavigate &#125; from &quot;react-router-dom&quot;;function SignupForm() &#123;  let navigate = useNavigate();  async function handleSubmit(event) &#123;    event.preventDefault();    await submitForm(event.target);    navigate(&quot;../success&quot;, &#123; replace: true &#125;);  &#125;  return &lt;form onSubmit=&#123;handleSubmit&#125;&gt;&#123;/* ... */&#125;&lt;/form&gt;;&#125;使用useNavigate可以实现手动进行路由跳转，let navigate = useNavigate();他会返回一个函数，参数有两个，一个是to, 另一个optional second &#123; replace, state &#125; arg，或者使用历史调用栈类似于go(-1)调用navigate(-1)\n\nuseLocationlet location = useLocation();//获取location\n\n\nwithRouter(component)import &#123;  useLocation,  useNavigate,  useParams,  useSearchParams&#125; from &quot;react-router-dom&quot;;function withRouter(Component) &#123;  function ComponentWithRouterProp(props) &#123;    const location = useLocation();    const navigate = useNavigate();    const params = useParams();    const [searchParams] = useSearchParams()    const query = Object.fromEntries(searchParams)    return (      &lt;Component        &#123;...props&#125;        router=&#123;&#123; location, navigate, params,query &#125;&#125;      /&gt;    );  &#125;  return ComponentWithRouterProp;&#125;//在v6中没有这个高阶组件，因为v6都是使用到的是函数式组件，所以不需要，如果想用可以这样封装，在v5中的主要目的是为了手动调用路由可以获取到history,组件可以通过this.props.history,push()来手动进行路由跳转，v6可以使用到useNavigate()\n\n路由的配置文件通过像vue-router来将路由定义在单独的文件中\n//router.jsimport Home from &#x27;../pages/Home&#x27;import HomeRecommend from &quot;../pages/HomeRecommend&quot;import HomeRanking from &quot;../pages/HomeRanking&quot;import HomeSongMenu from &#x27;../pages/HomeSongMenu&#x27;import Category from &quot;../pages/Category&quot;import Order from &quot;../pages/Order&quot;import NotFound from &#x27;../pages/NotFound&#x27;import Detail from &#x27;../pages/Detail&#x27;import User from &#x27;../pages/User&#x27;import &#123; Navigate &#125; from &#x27;react-router-dom&#x27;import React from &#x27;react&#x27;const About = React.lazy(() =&gt; import(&quot;../pages/About&quot;))const Login = React.lazy(() =&gt; import(&quot;../pages/Login&quot;))const routes = [  &#123;    path: &quot;/&quot;,    element: &lt;Navigate to=&quot;/home&quot;/&gt;  &#125;,  &#123;    path: &quot;/home&quot;,    element: &lt;Home/&gt;,    children: [      &#123;        path: &quot;/home&quot;,        element: &lt;Navigate to=&quot;/home/recommend&quot;/&gt;      &#125;,      &#123;        path: &quot;/home/recommend&quot;,        element: &lt;HomeRecommend/&gt;      &#125;,      &#123;        path: &quot;/home/ranking&quot;,        element: &lt;HomeRanking/&gt;      &#125;,      &#123;        path: &quot;/home/songmenu&quot;,        element: &lt;HomeSongMenu/&gt;      &#125;    ]  &#125;,  &#123;    path: &quot;/about&quot;,    element: &lt;About/&gt;  &#125;,  &#123;    path: &quot;/login&quot;,    element: &lt;Login/&gt;  &#125;,  &#123;    path: &quot;/category&quot;,    element: &lt;Category/&gt;  &#125;,  &#123;    path: &quot;/order&quot;,    element: &lt;Order/&gt;  &#125;,  &#123;    path: &quot;/detail/:id&quot;,    element: &lt;Detail/&gt;  &#125;,  &#123;    path: &quot;/user&quot;,    element: &lt;User/&gt;  &#125;,  &#123;    path: &quot;*&quot;,    element: &lt;NotFound/&gt;  &#125;]export default routes\n\n&#123;useRoutes(routes)&#125;\n\n","categories":["react","note"]},{"title":"react18 学习笔记","url":"/2022/08/30/react18-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"React开发依赖react开发必须依赖三个库：\n\nreact   包含react所有必须的核心代码\n\nreact-dom react渲染在不同平台所需要的核心代码\n\nbabel  将jsx转换成React代码的工具\nreact 包含react web和react-native所拥有的核心代码\nreact-dom针对web和native完成的事情不同\n​\tweb端react-dom会将jsx最终渲染成真实的DOM，显示在浏览器\n​\tnative端 react-dom会将jsx最终渲染成原生的控件\nbabel是将jsx代码转成react.createElement\n\n\nReact组件化开发​\treact中数据依赖来自两方面\n​\t\t参与界面更新的数据   当数据变量时，需要更新组件渲染的内容\n​\t\t不参与界面更新的数据  当数据变量时，不需要更新将组建渲染的内容，参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的state中，我们可以通过在构造函数中 this.state &#x3D; {定义的数据}\n 当我们的数据发生变化时，我们可以调用 this.setState 来更新数据，并且通知React进行update操作；在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面\n\n根据组件的定义方式，可以分为：函数组件(Functional Component )和类组件(Class Component)；\n\n根据组件内部是否有状态需要维护，可以分成：无状态组件(Stateless Component )和有状态组件(Stateful Component)；\n\n根据组件的不同职责，可以分成：展示型组件(Presentational Component)和容器型组件(Container Component)；\n\n函数组件、无状态组件、展示型组件主要关注UI的展示；\n\n类组件、有状态组件、容器型组件主要关注数据逻辑\n\n\nJSX的条件渲染​\t在react中，所有条件判断都和普通的js代码一致，而vue中会使用v-if&#x2F;v-show等来控制，react中没有这样封装好的指令\n​\treact常见的条件渲染方式\n\n条件判断语句\n\n三元运算符\n\n与运算符&amp;&amp;\n\ndisplay来控制\n&lt;script type=&quot;text/babel&quot;&gt;    // 1.定义App根组件    class App extends React.Component &#123;      constructor() &#123;        super()        this.state = &#123;          message: &quot;Hello World&quot;,          isReady: false,          friend: undefined        &#125;      &#125;      render() &#123;        const &#123; isReady, friend &#125; = this.state        // 1.条件判断方式一: 使用if进行条件判断        let showElement = null        if (isReady) &#123;          showElement = &lt;h2&gt;准备开始比赛吧&lt;/h2&gt;        &#125; else &#123;          showElement = &lt;h1&gt;请提前做好准备!&lt;/h1&gt;        &#125;        return (          &lt;div&gt;            &#123;/* 1.方式一: 根据条件给变量赋值不同的内容 */&#125;            &lt;div&gt;&#123;showElement&#125;&lt;/div&gt;            &#123;/* 2.方式二: 三元运算符 */&#125;            &lt;div&gt;&#123; isReady ? &lt;button&gt;开始战斗!&lt;/button&gt;: &lt;h3&gt;赶紧准备&lt;/h3&gt; &#125;&lt;/div&gt;            &#123;/* 3.方式三: &amp;&amp;逻辑与运算 */&#125;            &#123;/* 场景: 当某一个值, 有可能为undefined时, 使用&amp;&amp;进行条件判断 */&#125;            &lt;div&gt;&#123; friend &amp;&amp; &lt;div&gt;&#123;friend.name + &quot; &quot; + friend.desc&#125;&lt;/div&gt; &#125;&lt;/div&gt;          &lt;/div&gt;        )      &#125;    &#125;    // 2.创建root并且渲染App组件    const root = ReactDOM.createRoot(document.querySelector(&quot;#root&quot;))    root.render(&lt;App/&gt;)  &lt;/script&gt;\n\n1.react中，方法中this的默认是指向undefined的，\n  2.vscode创建用户代码片段3. jsx写注释&#123;/* */&#125; render()&#123;    return (      &lt;div&gt;        &#123;/*这是一段注释*/&#125;      &lt;/div&gt;    )  &#125;&#125;\n​    4.\n//这三个值无法在jsx中渲染出来   test1:undefined   test2:null   text3:false\n\n5.在jsx中对象类型不可以作为子元素,进行直接展示\n&lt;div&gt;&#123;this.state.obj&#125;&lt;/div&gt;\n\n6.jsx嵌入表达式    运算表达式    三元运算符    执行一个函数\n7.jsx中的class用className8.jsx中style的写法\n&lt;h1 style=&#123;&#123;color:&quot;red&quot;,fontSzie:&quot;24px&quot;&#125;&#125;&gt;hello world&lt;/h1&gt;\n\n9.react的事件绑定    react的事件绑定方法中this默认是undefined    this的绑定的三种方式\nclass App extends React.Component &#123;    // class fields    name = &quot;App&quot;    constructor() &#123;      //类组件继承一定要加super()并且必须写在最上面      super()      this.state = &#123;        message: &quot;Hello World&quot;,        counter: 100      &#125;      this.btn1Click = this.btn1Click.bind(this)    &#125;    btn1Click() &#123;      console.log(&quot;btn1Click&quot;, this);      this.setState(&#123; counter: this.state.counter + 1 &#125;)    &#125;    btn2Click = () =&gt; &#123;      console.log(&quot;btn2Click&quot;, this)      this.setState(&#123; counter: 1000 &#125;)    &#125;    btn3Click() &#123;      console.log(&quot;btn3Click&quot;, this);      this.setState(&#123; counter: 9999 &#125;)    &#125;    render() &#123;      const &#123; message &#125; = this.state      return (        &lt;div&gt;          &#123;/* 1.this绑定方式一: bind绑定 */&#125;          &lt;button onClick=&#123;this.btn1Click&#125;&gt;按钮1&lt;/button&gt;                    &#123;/* 2.this绑定方式二: ES6 class fields */&#125;          &lt;button onClick=&#123;this.btn2Click&#125;&gt;按钮2&lt;/button&gt;          &#123;/* 3.this绑定方式三: 直接传入一个箭头函数(重要) */&#125;          &lt;button onClick=&#123;() =&gt; console.log(&quot;btn3Click&quot;)&#125;&gt;按钮3&lt;/button&gt;          &lt;button onClick=&#123;() =&gt; this.btn3Click()&#125;&gt;按钮3&lt;/button&gt;          &lt;h2&gt;当前计数: &#123;this.state.counter&#125;&lt;/h2&gt;        &lt;/div&gt;      )    &#125;  &#125;  // 2.创建root并且渲染App组件  const root = ReactDOM.createRoot(document.querySelector(&quot;#root&quot;))  root.render(&lt;App/&gt;)\n\n 10.react事件的传参\n&lt;button onClick=&#123;(e)=&gt;&#123;         this.click3(e,item,name)       &#125;&#125;&gt;点击3&lt;/button&gt;\n\n​        可以用来传递event​ 在执行事件函数时，有可能我们需要获取一些参数信息：比如event对象、其他参数 情况一：获取event对象 很多时候我们需要拿到event对象来做一些事情（比如阻止默认行为） 假如我们用不到this，那么直接传入函数就可以获取到event对象； 情况二：获取更多参数 有更多参数时，我们最好的方式就是传入一个箭头函数，主动执行的事件函数，并且传入相关的其他参数\nrender() &#123;      const &#123; message &#125; = this.state      return (        &lt;div&gt;          &#123;/* 1.event参数的传递 */&#125;          &lt;button onClick=&#123;this.btnClick.bind(this)&#125;&gt;按钮1&lt;/button&gt;          &lt;button onClick=&#123;(event) =&gt; this.btnClick(event)&#125;&gt;按钮2&lt;/button&gt;                    &#123;/* 2.额外的参数传递 */&#125;          &lt;button onClick=&#123;this.btnClick.bind(this, &quot;kobe&quot;, 30)&#125;&gt;按钮3(不推荐)&lt;/button&gt;          &lt;button onClick=&#123;(event) =&gt; this.btnClick(event, &quot;why&quot;, 18)&#125;&gt;按钮4&lt;/button&gt;        &lt;/div&gt;      )    &#125;\n\n 11.react的列表渲染使用最多的是使用map     过滤filter     截取slice 12.React.createElement() jsx是他的语法糖\n​\tcreateElement需要传递三个参数\n\ntype      当前ReactElement的类型，如果是标签元素，那么就使用字符串表示div,如果是组件元素就用组件的名称\n\nconfig    所有jsx中的属性在config中都是对象的属性和值的形式存在，例如className作为class\n\nchildren  存放在标签中的内容都是以children数组的形式存储\n\n\n\n 13.render() 将virtual Dom&#x3D;&gt;Dom 14.频繁的操作DOM，会产生回流和重绘 15.React 组件名称首字母必须大写 html标签必须小写     类组件需要继承自 React.Component      类组件必须实现render函数 16.函数式组件      没有生命周期，也会被更新并挂载，但是没有生命周期函数；      没有this(组件实例）；     没有内部状态（state） 17.render函数、函数式组件的返回类型         组件，html元素         数组、fragments         Portals         字符串或者数值类型         Boolean，null 18.react的生命周期\n生命周期图谱\n\n\n\n\n 常用的生命周期函数 \t\n    1.contructor()&#123;\n    &#125;\n     如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。\n     constructor中通常只做两件事情：\n     通过给 this.state 赋值对象来初始化内部的state；\n     为事件绑定实例（this）；\n    2.componentDidMount()\n      componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用\t\n      可以进行网络请求，添加订阅，DOM操作\n    3.componentDidUpdate(prevProps, prevState, snapshot)\n      会在更行后立即调用，首次渲染不会执行，可以使用setState方法，但是必须用于条件语句，当组件更新后，可以在此处对 DOM 进行操作，如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求\n    4.componentWillUnmount()\n      可以用于清楚timer,取消网络请求，取消订阅\n    5.不常用的生命周期\n      getDerivedStateFromProps：state 的值在任何时候都依赖于 props时使用；该方法返回一个对象来更新state；\n      getSnapshotBeforeUpdate：在React更新DOM之前回调的一个函数，可以获取DOM更新前的一些信息（比如说滚动位置）\n      shouldComponentUpdate：当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。\n\n   19.组件通信         1.父组件向子组件传递数据 传递参数是常量非string的时候要将其当作变量用{}\n&lt;Children2 name=&quot;里斯&quot; age=&#123;55&#125;&gt;&lt;/Children2&gt;\n\n     2.子组件向父组件传递数据，定义回调函数传递给子组件调用\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import AddCounter from &#x27;./AddCounter&#x27;import SubCounter from &#x27;./SubCounter&#x27;export class App extends Component &#123;  constructor() &#123;    super()    this.state = &#123;      counter: 100    &#125;  &#125;  changeCounter(count) &#123;    this.setState(&#123; counter: this.state.counter + count &#125;)  &#125;  render() &#123;    const &#123; counter &#125; = this.state    return (      &lt;div&gt;        &lt;h2&gt;当前计数: &#123;counter&#125;&lt;/h2&gt;        &lt;AddCounter addClick=&#123;(count) =&gt; this.changeCounter(count)&#125;/&gt;        &lt;SubCounter subClick=&#123;(count) =&gt; this.changeCounter(count)&#125;/&gt;      &lt;/div&gt;    )  &#125;&#125;export default App\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;// import PropTypes from &quot;prop-types&quot;export class AddCounter extends Component &#123;  addCount(count) &#123;    this.props.addClick(count)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;e =&gt; this.addCount(1)&#125;&gt;+1&lt;/button&gt;        &lt;button onClick=&#123;e =&gt; this.addCount(5)&#125;&gt;+5&lt;/button&gt;        &lt;button onClick=&#123;e =&gt; this.addCount(10)&#125;&gt;+10&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;// AddCounter.propTypes = &#123;//   addClick: PropTypes.func// &#125;export default AddCounter\n\n    3.跨组件通信Context，可以使用组件的组合来替代Context\t\t\n\nimport React from &quot;react&quot;// 1.创建一个Context并且设置默认值const ThemeContext = React.createContext(&#123; color: &quot;blue&quot;, size: 10 &#125;)export default ThemeContext\n\nimport React from &quot;react&quot;// 1.创建一个Contextconst UserContext = React.createContext()export default UserContext\n\n//App.js//多个context传递数据的方式&lt;UserContext.Provider value=&#123;&#123;nickname: &quot;kobe&quot;, age: 30&#125;&#125;&gt;          &lt;ThemeContext.Provider value=&#123;&#123;color: &quot;red&quot;, size: &quot;30&quot;&#125;&#125;&gt;            &lt;Home &#123;...info&#125;/&gt;          &lt;/ThemeContext.Provider&gt; &lt;/UserContext.Provider&gt;\n\n//类组件的接受方式import React, &#123; Component &#125; from &#x27;react&#x27;import ThemeContext from &#x27;./context/theme-context&#x27;export class Profile extends Component &#123;  render() &#123;    console.log(this.context)    return (      &lt;div&gt;Profile&lt;/div&gt;    )  &#125;&#125;Profile.contextType = ThemeContextexport default Profile\n\n//函数式组件的接收方式import ThemeContext from &quot;./context/theme-context&quot;function HomeBanner() &#123;  return &lt;div&gt;    &#123;/* 函数式组件中使用Context共享的数据 */&#125;    &lt;ThemeContext.Consumer&gt;      &#123;        value =&gt; &#123;          return &lt;h2&gt; Banner theme:&#123;value.color&#125;&lt;/h2&gt;        &#125;      &#125;    &lt;/ThemeContext.Consumer&gt;  &lt;/div&gt;&#125;export default HomeBanner\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import ThemeContext from &#x27;./context/theme-context&#x27;import UserContext from &#x27;./context/user-context&#x27;export class HomeInfo extends Component &#123;  //static contextType=ThemeContext 这种写法也可以  render() &#123;    // 4.第四步操作: 获取数据, 并且使用数据    console.log(this.context)    return (      &lt;div&gt;        &lt;h2&gt;HomeInfo: &#123;this.context.color&#125;&lt;/h2&gt;        &lt;UserContext.Consumer&gt;          &#123;            value =&gt; &#123;              return &lt;h2&gt;Info User: &#123;value.nickname&#125;&lt;/h2&gt;            &#125;          &#125;        &lt;/UserContext.Consumer&gt;      &lt;/div&gt;    )  &#125;&#125;// 3.第三步操作: 设置组件的contextType为某一个ContextHomeInfo.contextType = ThemeContextHomeInfo.displayName = &#x27;MyDisplayName&#x27;;//设置在devtool的显示名字export default HomeInfo\n\n//多个context的使用// Theme context，默认的 theme 是 “light” 值const ThemeContext = React.createContext(&#x27;light&#x27;);// 用户登录 contextconst UserContext = React.createContext(&#123;  name: &#x27;Guest&#x27;,&#125;);class App extends React.Component &#123;  render() &#123;    const &#123;signedInUser, theme&#125; = this.props;    // 提供初始 context 值的 App 组件    return (      &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;        &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt;          &lt;Layout /&gt;        &lt;/UserContext.Provider&gt;      &lt;/ThemeContext.Provider&gt;    );  &#125;&#125;function Layout() &#123;  return (    &lt;div&gt;      &lt;Sidebar /&gt;      &lt;Content /&gt;    &lt;/div&gt;  );&#125;// 一个组件可能会消费多个 contextfunction Content() &#123;  return (    &lt;ThemeContext.Consumer&gt;      &#123;theme =&gt; (        &lt;UserContext.Consumer&gt;          &#123;user =&gt; (            &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt;          )&#125;        &lt;/UserContext.Consumer&gt;      )&#125;    &lt;/ThemeContext.Consumer&gt;  );&#125;\n\n**什么时候使用Context.Consumer呢？\n.当使用value的组件是一个函数式组件时；\n.当组件中需要使用多个Context时；\n 4.使用事件总线   20.对props进行类型检查 propTypes\nimport PropTypes from &quot;prop-types&quot;\tChildren2.propTypes = &#123;          // 必填属性          name: PropTypes.string.isRequired,          age: PropTypes.number,          time:PropTypes.array        &#125;;        // 可以定义默认·值Children2.defaultProps=&#123;          time:[&quot;2022/5/11&quot;,&quot;2022/5/6&quot;]        &#125;\n\n 21.props为什么不写也是可以的   \nconstructor()&#123;      super()      this.state=&#123;&#125;    &#125; 因为react内部会强制性给当前实例复制props this.instance=element.props\n\n22.组件插槽的实现\n //App.js&lt;div&gt;        &#123;/* 1.使用children实现插槽 */&#125;        &lt;NavBar&gt;          &lt;button&gt;按钮&lt;/button&gt;          &lt;h2&gt;哈哈哈&lt;/h2&gt;          &lt;i&gt;斜体文本&lt;/i&gt;        &lt;/NavBar&gt;        &#123;/* 2.使用props实现插槽 */&#125;        &lt;NavBarTwo           leftSlot=&#123;btn&#125;          centerSlot=&#123;&lt;h2&gt;呵呵呵&lt;/h2&gt;&#125;          rightSlot=&#123;&lt;i&gt;斜体2&lt;/i&gt;&#125;        /&gt;      &lt;/div&gt;\n\n//NavBar.jsexport class NavBar extends Component &#123;  render() &#123;    const &#123; children &#125; = this.props    console.log(children)    return (      &lt;div className=&#x27;nav-bar&#x27;&gt;        &lt;div className=&quot;left&quot;&gt;&#123;children[0]&#125;&lt;/div&gt;        &lt;div className=&quot;center&quot;&gt;&#123;children[1]&#125;&lt;/div&gt;        &lt;div className=&quot;right&quot;&gt;&#123;children[2]&#125;&lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n//NavBarTwo.jsimport React, &#123; Component &#125; from &#x27;react&#x27;export class NavBarTwo extends Component &#123;  render() &#123;    const &#123; leftSlot, centerSlot, rightSlot &#125; = this.props    return (      &lt;div className=&#x27;nav-bar&#x27;&gt;        &lt;div className=&quot;left&quot;&gt;&#123;leftSlot&#125;&lt;/div&gt;        &lt;div className=&quot;center&quot;&gt;&#123;centerSlot&#125;&lt;/div&gt;        &lt;div className=&quot;right&quot;&gt;&#123;rightSlot&#125;&lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;\n\n通过children实现的方案虽然可行，但是有一个弊端：通过索引值获取传入的元素很容易出错，不能精准的获取传入的原生\n23.setState   setState是异步更新，可以显著提升性能   如果每一次调用setState都进行一次更新，那么意味着render函数需要频繁的调用   最好的办法是获取多个更新，之后进行批量更新   如果同步更新了state,但是还没执行render函数，那么state和props不能保持同步   state和props不能保持一致性，会在开发中产生很多问题\n   为了拿到异步更新后的数据\n​\tsetState的三种写法\n​\t\nchangeText() &#123;   // 1.setState更多用法   // 1.基本使用   // this.setState(&#123;   //   message: &quot;你好啊, 李银河&quot;   // &#125;)   // 2.setState可以传入一个回调函数,回调 函数中接收的 state 和 props 都保证为最新。回调函数 的返回值会与 state 进行浅合并。   // 好处一: 可以在回调函数中编写新的state的逻辑   // 好处二: 当前的回调函数会将之前的state和props传递进来   // this.setState((state, props) =&gt; &#123;   //   // 1.编写一些对新的state处理逻辑   //   // 2.可以获取之前的state和props值   //   console.log(this.state.message, this.props)    //获得最新的state和props//   console.log(state, props)   //   return &#123;   //     message: &quot;你好啊, 李银河&quot;   //   &#125;   // &#125;)   // 3.setState在React的事件处理中是一个异步调用   // 如果希望在数据更新之后(数据合并), 获取到对应的结果执行一些逻辑代码   // 那么可以在setState中传入第二个参数: callback   this.setState(&#123; message: &quot;你好啊, 李银河&quot; &#125;, () =&gt; &#123;     console.log(&quot;++++++:&quot;, this.state.message)   &#125;)   console.log(&quot;------:&quot;, this.state.message) &#125;\n\nsetState都是异步的吗在React18以前，在组件的生命周期或者React合成事件中，setState是异步的，在setTimeout以及原生事件中是同步的，react18以后所有都是异步的，如果需要同步操作需要使用flushSync()\nsetTimeout(() =&gt; &#123;    // 在react18之前, setTimeout中setState操作, 是同步操作    // 在react18之后, setTimeout中setState异步操作(批处理)    flushSync(() =&gt; &#123;      this.setState(&#123; message: &quot;你好啊, 李银河&quot; &#125;)    &#125;)    console.log(this.state.message)  &#125;, 0);\n\n 24.组件创建的时候会被调用一次 25.render函数，组件更新时调用render函数会让所有子组件都会进行一次更新。使用shouldComponentUpdate这个生命周期函数可以控制state和props发生变化时是否重新调用render函数         \nshouldComponentUpdate(nextProps,nextState)&#123;    //next...是最新的数据       if(this.state.num!==nextState.num)&#123;         return true       &#125;       return false     &#125;\n\n​    在开发中每个组件都写shouldComponentUpdate比较麻烦，可以在使用PureComponent\nclass Man extends React.PureComponent\n\n 26.PureComponent不能用于函数式组件，需要用memo\n​\t PureComponent就是对组件进行优化，避免频繁的调用render函数进行渲染，这个方法中调用!shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)，进行浅层比较\n 27.state中的属性的不可变性 28.react不建议直接在操作dom，可以使用ref     使用ref的三种方式\nimport React,&#123;createRef&#125; from &quot;react&quot;;class RefDemo extends React.Component&#123;  constructor(props)&#123;    super(props)    this.state=&#123;&#125;    this.titleRef=createRef()    // 第三种使用函数    this.textInput = null;  &#125;  componentDidMount()&#123;     &#125;  componentWillUnmount()&#123;      &#125;  changeRef1()&#123;    // 方式一已经被淘汰了    this.refs.refTitle.innerHTML=&quot;hello ref&quot;  &#125;  changeRef2()&#123;    // 官方推荐以这种方式     this.titleRef.current.innerHTML=&quot;hello big&quot;    console.log(this.titleRef.current)  &#125;  focusTextInput()&#123;    this.textInput.focus()    console.log(this.textInput)  &#125;  render()&#123;    return (      &lt;div&gt;        &lt;h1 ref=&quot;refTitle&quot;&gt;hello react&lt;/h1&gt;        &lt;button onClick=&#123;()=&gt;this.changeRef1()&#125;&gt;按钮1&lt;/button&gt;        &lt;h1 ref=&#123;this.titleRef&#125;&gt;hello world&lt;/h1&gt;        &lt;button onClick=&#123;()=&gt;this.changeRef2()&#125;&gt;按钮2&lt;/button&gt;        &lt;button onClick=&#123;()=&gt;this.focusTextInput()&#125;&gt;focus&lt;/button&gt;        &lt;div&gt;&lt;input ref=&#123;element=&gt;this.textInput=element&#125; type=&quot;text&quot; /&gt;&lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;export default RefDemo\n\n函数式组件中没有ref属性，要使用const textInput &#x3D; useRef(null);可以通过ref访问子组件的方法和属性和vue一样\nkey的注意事项key必须唯一\nkey不能够使用随机数（因为随机数在下一次render时会重新生成一个数字）\n使用index作为key,对性能没有优化\n26.受控组件\n​\t受控组件就是通过setState来控制值，state成为唯一的数据源\n​\t\ninputChange(event) &#123;   console.log(&quot;inputChange:&quot;, event.target.value)   this.setState(&#123; username: event.target.value &#125;) &#125; render() &#123;   const &#123; username &#125; = this.state   return (     &lt;div&gt;       &#123;/* 受控组件 */&#125;       &lt;input type=&quot;checkbox&quot; value=&#123;username&#125; onChange=&#123;e =&gt; this.inputChange(e)&#125;/&gt;       &#123;/* 非受控组件 */&#125;       &lt;input type=&quot;text&quot; /&gt;       &lt;h2&gt;username: &#123;username&#125;&lt;/h2&gt;     &lt;/div&gt;   ) &#125;\n\n当type为text&#x2F;textarea&#x2F;select的时候绑定的是value,需要使用事件onChange\n当type为checkbox&#x2F;radio的时候，绑定的是checked，使用onChange事件\n&lt;input type=&quot;file&quot; /&gt;始终是非受控组件\n\n使用form进行表单提交\nclass FlavorForm extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;value: &#x27;coconut&#x27;&#125;;    this.handleChange = this.handleChange.bind(this);    this.handleSubmit = this.handleSubmit.bind(this);  &#125;  handleChange(event) &#123;    this.setState(&#123;value: event.target.value&#125;);  &#125;  handleSubmit(event) &#123;    alert(&#x27;你喜欢的风味是: &#x27; + this.state.value);    event.preventDefault();  &#125;  render() &#123;    return (      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;        &lt;label&gt;          选择你喜欢的风味:          &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt;            &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt;            &lt;option value=&quot;lime&quot;&gt;酸橙&lt;/option&gt;            &lt;option value=&quot;coconut&quot;&gt;椰子&lt;/option&gt;            &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt;          &lt;/select&gt;        &lt;/label&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;      &lt;/form&gt;    );  &#125;&#125;\n\n当针对多个输入的时候\n可以给每个input绑定唯一的name,然后利用计算属性名来进行赋值操作\nhandleSubmitClick(event) &#123;    // 1.阻止默认的行为    event.preventDefault()    // 2.获取到所有的表单数据, 对数据进行组件    console.log(&quot;获取所有的输入内容&quot;)    console.log(this.state.username, this.state.password)    // 3.以网络请求的方式, 将数据传递给服务器(ajax/fetch/axios)  &#125;  // handleUsernameChange(event) &#123;  //   this.setState(&#123; username: event.target.value &#125;)  // &#125;  // handlePasswordChange(event) &#123;  //   this.setState(&#123; password: event.target.value &#125;)  // &#125;  handleInputChange(event) &#123;    this.setState(&#123;      [event.target.name]: event.target.value    &#125;)  &#125;  render() &#123;    const &#123; username, password &#125; = this.state    return (      &lt;div&gt;        &lt;form onSubmit=&#123;e =&gt; this.handleSubmitClick(e)&#125;&gt;          &#123;/* 1.用户名和密码 */&#125;          &lt;label htmlFor=&quot;username&quot;&gt;            用户:             &lt;input               id=&#x27;username&#x27;               type=&quot;text&quot;               name=&#x27;username&#x27;               value=&#123;username&#125;               onChange=&#123;e =&gt; this.handleInputChange(e)&#125;            /&gt;          &lt;/label&gt;          &lt;label htmlFor=&quot;password&quot;&gt;            密码:             &lt;input               id=&#x27;password&#x27;               type=&quot;password&quot;               name=&#x27;password&#x27;               value=&#123;password&#125;               onChange=&#123;e =&gt; this.handleInputChange(e)&#125;            /&gt;          &lt;/label&gt;          &lt;button type=&#x27;submit&#x27;&gt;注册&lt;/button&gt;        &lt;/form&gt;      &lt;/div&gt;    )  &#125;\n\n27.非受控组件\n非受控组件就是将表单数据交给DOM节点来处理，\nclass NameForm extends React.Component &#123;  constructor(props) &#123;    super(props);    this.handleSubmit = this.handleSubmit.bind(this);    this.input = React.createRef();  &#125;  handleSubmit(event) &#123;    alert(&#x27;A name was submitted: &#x27; + this.input.current.value);    event.preventDefault();  &#125;  render() &#123;、  //defaultValue是默认值    return (      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;        &lt;label&gt;          Name:          &lt;input  defaultValue=&quot;Bob&quot; type=&quot;text&quot; ref=&#123;this.input&#125; /&gt;        &lt;/label&gt;        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;      &lt;/form&gt;    );  &#125;&#125;\n\n&lt;input type=&quot;checkbox&quot;&gt; 和 &lt;input type=&quot;radio&quot;&gt; 支持 defaultChecked，&lt;select&gt; 和 &lt;textarea&gt; 支持 defaultValue。\n\n28.高阶组件\n高阶组件是一个函数，高阶组件的参数是一个组件，返回值也是一个组件。高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。HOC 是纯函数，没有副作用，高阶组件适用于抽取公共的逻辑\nimport &#123; PureComponent &#125; from &#x27;react&#x27;//props增强// 定义组件: 给一些需要特殊数据的组件, 注入propsfunction enhancedUserInfo(OriginComponent) &#123;  class NewComponent extends PureComponent &#123;    constructor(props) &#123;      super(props)      this.state = &#123;        userInfo: &#123;          name: &quot;coderwhy&quot;,          level: 99        &#125;      &#125;    &#125;    render() &#123;      return &lt;OriginComponent &#123;...this.props&#125; &#123;...this.state.userInfo&#125;/&gt;    &#125;  &#125;  return NewComponent&#125;export default enhancedUserInfo\n\n//我们也可以利用高阶函数来劫持生命周期，在生命周期中完成自己的逻辑import &#123; PureComponent &#125; from &quot;react&quot;;function logRenderTime(OriginComponent) &#123;  return class extends PureComponent &#123;    UNSAFE_componentWillMount() &#123;      this.beginTime = new Date().getTime()      componentDidMount() &#123;      this.endTime = new Date().getTime()      const interval = this.endTime - this.beginTime      console.log(`当前$&#123;OriginComponent.name&#125;页面花费了$&#123;interval&#125;ms渲染完成!`)    &#125;    render() &#123;      return &lt;OriginComponent &#123;...this.props&#125;/&gt;    &#125;  &#125;&#125;export default logRenderTime\n\n//渲染鉴权，可以判断用户有没有登录，如果没有登录则渲染其他组件function loginAuth(OriginComponent) &#123;  return props =&gt; &#123;    // 从localStorage中获取token    const token = localStorage.getItem(&quot;token&quot;)    if (token) &#123;      return &lt;OriginComponent &#123;...props&#125;/&gt;    &#125; else &#123;      return &lt;h2&gt;请先登录, 再进行跳转到对应的页面中&lt;/h2&gt;    &#125;  &#125;&#125;export default loginAuth\n\nimport ThemeContext from &quot;../context/theme_context&quot;//和context结合function withTheme(OriginComponment) &#123;  return (props) =&gt; &#123;    return (      &lt;ThemeContext.Consumer&gt;        &#123;          value =&gt; &#123;            return &lt;OriginComponment &#123;...value&#125; &#123;...props&#125;/&gt;          &#125;        &#125;      &lt;/ThemeContext.Consumer&gt;    )  &#125;&#125;export default withTheme\n\n不要在 render 方法中使用 HOC\nHOC也有自己的一些缺陷：\n HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难； HOC可以劫持props，在不遵守约定的情况下也可能造成冲突；\nHooks的出现，是开创性的，它解决了很多React之前的存在的问题\n比如this指向问题、比如hoc的嵌套复杂度问题等等\n29.ref的转发，获取函数式组件内部的ref 可以使用forwardRef高阶函数30.Portals的使用，用于将渲染元素独立于父组件，渲染到其他元素之上。使用React.createPortal(child,container)31.fragment的使用，相当于vue的template在实际的dom中不渲染，带key的时候不能使用短语法    还可以使用短语发    \nclass Columns extends React.Component &#123;  render() &#123;    return (      &lt;&gt;        &lt;td&gt;Hello&lt;/td&gt;        &lt;td&gt;World&lt;/td&gt;      &lt;/&gt;    );  &#125;&#125;\n\n 32.StrictMode 开启react的严格模式，只有开发环境下起作用\n​\tStrictMode是用来突显应用程序中的潜在问题的工具\n​\t它为其后代元素触发额外的检查和警告\n 可以识别不安全的生命周期\n 使用过时的ref的API\n 检测意外的副作用。\n\n​\t\t\t组件的constructor会调用两次\n​\t\t\t生产环境终不悔调用两次\n​\tj检测使用废弃的findDOMNode方法\n 检测过时的context api \n\n​\t\t\t早期的Context是通过static属性声明Context对象属性，通过getChildContext返回Context对象等方式来使用Context的\n 33.react中的css     1.内联样式\n​\t\t\tstyle 接受一个采用小驼峰命名属性的 JavaScript 对象，，而不是 CSS 字符串\n​\t\t\t并且可以引用state中的状态来设置相关的样式\n​\t\t\t.内联样式, 样式之间不会有冲突\n​\t\t\t 可以动态获取当前state中的状态\n​\t\t\t 写法上都需要使用驼峰标识\n​\t\t\t某些样式没有提示\n​\t\t\t大量的样式, 代码混乱\n​\t\t\t某些样式无法编写(比如伪类&#x2F;伪元素\n 2.css modules\n     不是react特有的决绝方案，所有类似webpack配置环境都可以使用，在react中已经配置，在其他项目中使用需要在webpack.config.js中module:true\n  \t要创建xxx.moudle.css文件\n  \t不能使用连接符创建类名(.home-title)，js不支持，需要使用&#123;引入名字style.className&#125;来编写\n  \t不方便更改样式.不方便动态修改某些样式，依然需要使用内联样式\n  3.css in js\n  \t常用的 css in js库\n  \t\tstyled-components\n  \t\t\t在多人协作中，css必定会出现命名冲突，与vue的scoped解决方案不同，react用styled-\t\t\t\t\tcomponents的给类名加了随机字符的方式实现了css的私有化，它也是全局的\n  \t\tstyled-components其实是一个组件，可以传入props\n  \t\temotion\n  \t\tglamorous\n\n​\t\tstyled-components的本质是通过函数的调用，最终创建出一个组件，这个组件会自动添加上一个不重复的class\n​\t\tstyled-components会给该class添加相关的样式，它支持css预处理器一样嵌套，支持直接子代选择器或者后代选择器，并且编写样式，可以通过&amp;符号获取当前元素，直接伪类选择器，伪元素等\nimport styled from &quot;styled-components&quot;import &#123;  primaryColor,  largeSize&#125; from &quot;./style/variables&quot;// 1.基本使用export const AppWrapper = styled.div`  .footer &#123;    border: 1px solid orange;  &#125;// const obj = &#123;//   name: (props) =&gt; props.name || &quot;why&quot;// &#125;// 2.子元素单独抽取到一个样式组件// 3.可以接受外部传入的props// 4.可以通过attrs给标签模板字符串中提供的属性// 5.从一个单独的文件中引入变量export const SectionWrapper = styled.div.attrs(props =&gt; (&#123;  tColor: props.color || &quot;blue&quot;&#125;))`  border: 1px solid red;  .title &#123;    font-size: $&#123;props =&gt; props.size&#125;px;    color: $&#123;props =&gt; props.tColor&#125;;    &amp;:hover &#123;      background-color: purple;    &#125;  &#125;  .content &#123;    font-size: $&#123;largeSize&#125;px;    color: $&#123;primaryColor&#125;;  &#125;`\n\nimport styled from &quot;styled-components&quot;;const HYButton = styled.button`  border: 1px solid red;  border-radius: 5px;`// css样式的继承export const HYButtonWrapper = styled(HYButton)`  background-color: #0f0;  color: #fff;`export const HomeWrapper = styled.div`  .top &#123;    .banner &#123;      color: red;    &#125;  &#125;  .bottom &#123;    .header &#123;      color: $&#123;props =&gt; props.theme.color&#125;;      font-size: $&#123;props =&gt; props.theme.size&#125;;    &#125;    .product-list &#123;      .item &#123;        color: blue;      &#125;    &#125;  &#125;`\n\n 4.普通的csc会相互层叠，都会合并到全局的css中去，遭成影响到其他模块\n 5.less的编写方式  需要配置webpack\n   需要使用craco  目前针对creat-react-app 5 的配置 npm i @craco/craco@alpha\n\n&quot;scripts&quot;: &#123;   &quot;start&quot;: &quot;craco start&quot;,   &quot;build&quot;: &quot;craco build&quot;,   &quot;test&quot;: &quot;craco test&quot;,   &quot;eject&quot;: &quot;react-scripts eject&quot; &#125;,\n\n​\t\n//craco.config.jsconst CracoLessPlugin = require(&#x27;craco-less&#x27;);module.exports = &#123;  plugins: [    &#123;      plugin: CracoLessPlugin,      options: &#123;        lessLoaderOptions: &#123;          lessOptions: &#123;            modifyVars: &#123; &#x27;@primary-color&#x27;: &#x27;#1DA57A&#x27; &#125;,            javascriptEnabled: true,          &#125;,        &#125;,      &#125;,    &#125;,  ],&#125;;\n\nReact中添加class可以借助第三方库classnames\n 34.axios中，axios({})这样是使用他默认创建的实例，如果要自己创建一个实例要使用axios.create({})\nreact-transition-group  这个库可以帮助我们方便的实现组件的 入场 和 离场 动画，使用时需要进行额外的安装\nnpm install react-transition-group --saveyarn add react-transition-group\n\nreact-transition-group主要包括四个组件\nTansition\n​\t\t该组件是一个和平台无关的组件（不一定要结合CSS）\n​\t\t在前端开发中，我们一般是结合CSS来完成样式，所以比较常用的是CSSTransition\nCSSTransition\n​\t\t在前端开发中，通常使用CSSTransition来完成过渡动画\n​\t\tCSSTransition是基于Transition组件构建的\n​\t\tCSSTransition执行过程中，有三个状态：appear、enter、exit；\n​\t\t它们有三种状态，需要定义对应的CSS样式：\n​\t\t第一类，开始状态：对于的类是-appear、-enter、exit； \n​\t\t第二类：执行动画：对应的类是-appear-active、-enter-active、-exit-active； \n​        第三类：执行结束：对应的类是-appear-done、-enter-done、-exit-done；\n​\t\tCSSTransition常用属性\n​\t\tin\n​\t\tclassNames\n​\t\ttimeout\n​\t\tappear\n​\t\tunmountOnExit\n钩子函数:​\t\t\t\tonEnter\n​\t\t\t\tonEntering\n​\t\t\t\tonEntered\nimport React, &#123; createRef, PureComponent &#125; from &#x27;react&#x27;import &#123; CSSTransition &#125; from &quot;react-transition-group&quot;import &quot;./style.css&quot;export class App extends PureComponent &#123;  constructor(props) &#123;    super(props)    this.state = &#123;      isShow: true    &#125;    this.sectionRef = createRef()  &#125;  render() &#123;    const &#123; isShow &#125; = this.state    return (      &lt;div&gt;        &lt;button onClick=&#123;e =&gt; this.setState(&#123;isShow: !isShow&#125;)&#125;&gt;切换&lt;/button&gt;        &#123;/* &#123; isShow &amp;&amp; &lt;h2&gt;哈哈哈&lt;/h2&gt; &#125; */&#125;        &lt;CSSTransition           nodeRef=&#123;this.sectionRef&#125;          in=&#123;isShow&#125;           unmountOnExit=&#123;true&#125;           classNames=&quot;why&quot;           timeout=&#123;2000&#125;          appear          onEnter=&#123;e =&gt; console.log(&quot;开始进入动画&quot;)&#125;          onEntering=&#123;e =&gt; console.log(&quot;执行进入动画&quot;)&#125;          onEntered=&#123;e =&gt; console.log(&quot;执行进入结束&quot;)&#125;          onExit=&#123;e =&gt; console.log(&quot;开始离开动画&quot;)&#125;          onExiting=&#123;e =&gt; console.log(&quot;执行离开动画&quot;)&#125;          onExited=&#123;e =&gt; console.log(&quot;执行离开结束&quot;)&#125;        &gt;          &lt;div className=&#x27;section&#x27; ref=&#123;this.sectionRef&#125;&gt;            &lt;h2&gt;哈哈哈&lt;/h2&gt;            &lt;p&gt;我是内容, 哈哈哈&lt;/p&gt;          &lt;/div&gt;        &lt;/CSSTransition&gt;      &lt;/div&gt;    )  &#125;&#125;export default App\n\n.why-appear, .why-enter &#123;  opacity: 0;&#125;.why-appear-active, .why-enter-active &#123;  opacity: 1;  transition: opacity 2s ease;&#125;/* 离开动画 */.why-exit &#123;  opacity: 1;&#125;.why-exit-active &#123;  opacity: 0;  transition: opacity 2s ease;&#125;\n\nSwitchTransition\n​\t\t两个组件显示和切换时，使用该组件\n​\t\tSwitchTransition中主要有一个属性：mode，有两个值\n​\t\t\tin-out：表示新组件先进入，旧组件再移除；\n​\t\t\tout-in：表示就组件先移除，新组建再进入\n​\t\tSwitchTransition组件里面要有CSSTransition或者Transition组件，不能直接包裹你想要切换的组件\n​\t\tSwitchTransition里面的CSSTransition或Transition组件不再像以前那样接受in属性来判断元素是何种状态，取而代之的是 key属性\nimport React, &#123; PureComponent &#125; from &#x27;react&#x27;import &#123; SwitchTransition, CSSTransition &#125; from &#x27;react-transition-group&#x27;import &quot;./style.css&quot;export class App extends PureComponent &#123;  constructor() &#123;    super()     this.state = &#123;      isLogin: true    &#125;  &#125;  render() &#123;    const &#123; isLogin &#125; = this.state    return (      &lt;div&gt;        &lt;SwitchTransition mode=&#x27;out-in&#x27;&gt;          &lt;CSSTransition            key=&#123;isLogin ? &quot;exit&quot;: &quot;login&quot;&#125;            classNames=&quot;login&quot;            timeout=&#123;1000&#125;          &gt;            &lt;button onClick=&#123;e =&gt; this.setState(&#123; isLogin: !isLogin &#125;)&#125;&gt;              &#123; isLogin ? &quot;退出&quot;: &quot;登录&quot; &#125;            &lt;/button&gt;          &lt;/CSSTransition&gt;        &lt;/SwitchTransition&gt;      &lt;/div&gt;    )  &#125;&#125;export default App\n\n.login-enter &#123;  transform: translateX(100px);  opacity: 0;&#125;.login-enter-active &#123;  transform: translateX(0);  opacity: 1;  transition: all 1s ease;&#125;.login-exit &#123;  transform: translateX(0);  opacity: 1;&#125;.login-exit-active &#123;  transform: translateX(-100px);  opacity: 0;  transition: all 1s ease;&#125;\n\nTransitionGroup\n​\t\t将多个组件包裹在其中，一般用于列表中的元素的动画\n​\t\t◼ 当我们有一组动画时，需要将这些CSSTransition放入到一个TransitionGroup中来完成动画：\n&lt;TransitionGroup component=&quot;ul&quot;&gt;         &#123;           books.map((item, index) =&gt; &#123;             return (               &lt;CSSTransition key=&#123;item.id&#125; classNames=&quot;book&quot; timeout=&#123;1000&#125;&gt;                 &lt;li&gt;                   &lt;span&gt;&#123;item.name&#125;-&#123;item.price&#125;&lt;/span&gt;                   &lt;button onClick=&#123;e =&gt; this.removeBook(index)&#125;&gt;删除&lt;/button&gt;                 &lt;/li&gt;               &lt;/CSSTransition&gt;             )           &#125;)         &#125;       &lt;/TransitionGroup&gt;\n\n.book-enter &#123;  transform: translateX(150px);  opacity: 0;&#125;.book-enter-active &#123;  transform: translateX(0);  opacity: 1;  transition: all 1s ease;&#125;.book-exit &#123;  transform: translateX(0);  opacity: 1;&#125;.book-exit-active &#123;  transform: translateX(150px);  opacity: 0;  transition: all 1s ease;&#125;\n\n36.react纯函数 37.node中对ES6模块化的支持 在13.2.0以后对es6的支持，需要在package.json中添加属性”type”:”module”,导入文件时要跟上.js后缀名 38.redux     redux主要是负责状态管理     store:createStore(reducer,..)     state:通过store.getState()来获取当前state     react的组成         action:是用来更新数据，所有的数据变化，必须通过dispatch来派发action来更新，action可以是一个对象，也可以是一个函数，函数必须返回一个对象         reducer：是将state和action连接起来，reducer是一个纯函数，reducer是将传入的reducer和action整和成为一个新的state         dispatch:用来派发action     redux的三大原则         1.单一数据源         2.state是只读的         3.使用纯函数来执行修改 39.单向数据流 40.react动画中中需要再用包裹,否则会报错 41.react-router     默认是模糊匹配 42.react-hook     import React from “react”&#x2F;&#x2F;这个是在函数式组件和类组件都要写，因为jsx是React.createElement()的语法糖，会在内部调用     useState()     Hook的使用规则：         只能在函数最外层调用Hook,不要在循环，条件判断或者子函数中调用         只能在React的函数组件中调用Hook,不要再其他js函数中使用\n  const [count, setCount] = useState(() =&gt; 10);//useState可以传入一个函数\n\n  console.log(“CounterHook渲染”);\n  function handleBtnClick() {    &#x2F;&#x2F; setCount(count + 10);\n​    setCount((prevCount) &#x3D;&gt; prevCount + 10);&#x2F;&#x2F;preCount是上一个count​​    如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。​    与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 \tsetState 结合展开运算符来达到合并更新对象的效果。​    setState(prevState &#x3D;&gt; {​      &#x2F;&#x2F; 也可以使用 Object.assign​      return {…prevState, …updatedValues};​    });​    useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。\n 43.useEffect()     useEffect(() &#x3D;&gt; {    console.log(“订阅一些事件”);\n​    return () &#x3D;&gt; {​      console.log(“取消订阅事件”)​    }  }, []);&#x2F;&#x2F;通过返回一个函数来执行类似componmentwillumnount来清除副作用，[]这个可以作为优化，只有在组件切换时才执行，[]只会执行一次，相当于是componentDiMount,componentWillUnmount  44.useEffect第二个参数   useEffect(() &#x3D;&gt; {​    console.log(“修改DOM”, count);  }, [count]);&#x2F;&#x2F;useEffect可以让某个属性发生改变时才执行，这个属性必须在useEffect的回调函数中有使用到  如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。\n使用多个useEffect可以分开使用，执行的时候会挨个执行\n45.useContext的使用​\tuseContext可以让多个Context传递给函数式组件的时候减少consumer的嵌套\nconst root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render(  &lt;UserContext.Provider value=&#123;&#123;name: &quot;why&quot;, level: 99&#125;&#125;&gt;    &lt;TokenContext.Provider value=&#123;&#x27;coderwhy&#x27;&#125;&gt;      &lt;App /&gt;    &lt;/TokenContext.Provider&gt;  &lt;/UserContext.Provider&gt;);\n\nimport React, &#123; memo, useContext &#125; from &#x27;react&#x27;import &#123; UserContext, ThemeContext &#125; from &quot;./context&quot;const App = memo(() =&gt; &#123;  // 使用Context  const user = useContext(UserContext)  const theme = useContext(ThemeContext)  return (    &lt;div&gt;      &lt;h2&gt;User: &#123;user.name&#125;-&#123;user.level&#125;&lt;/h2&gt;      &lt;h2 style=&#123;&#123;color: theme.color, fontSize: theme.size&#125;&#125;&gt;Theme&lt;/h2&gt;    &lt;/div&gt;  )&#125;)export default App\n\n46.useCallback的使用useReducer不是redux的替代品，useReducer仅仅是useState的一种替代方案。在某些场景下，如果state的处理逻辑比较复杂，我们可以通过useReducer来对其进行拆分，或者这次修改的state需要依赖之前的state时，也可以使用。\nfunction reducer(state, action) &#123;  switch(action.type) &#123;    case &quot;increment&quot;:      return &#123; ...state, counter: state.counter + 1 &#125;    case &quot;decrement&quot;:      return &#123; ...state, counter: state.counter - 1 &#125;    case &quot;add_number&quot;:      return &#123; ...state, counter: state.counter + action.num &#125;    case &quot;sub_number&quot;:      return &#123; ...state, counter: state.counter - action.num &#125;    default:      return state  &#125;&#125;\n\nconst [state, dispatch] = useReducer(reducer, &#123; counter: 0, friends: [], user: &#123;&#125; &#125;)     &lt;button onClick=&#123;e =&gt; dispatch(&#123;type: &quot;increment&quot;&#125;)&#125;&gt;+1&lt;/button&gt;     &lt;button onClick=&#123;e =&gt; dispatch(&#123;type: &quot;decrement&quot;&#125;)&#125;&gt;-1&lt;/button&gt;     &lt;button onClick=&#123;e =&gt; dispatch(&#123;type: &quot;add_number&quot;, num: 5&#125;)&#125;&gt;+5&lt;/button&gt;     &lt;button onClick=&#123;e =&gt; dispatch(&#123;type: &quot;sub_number&quot;, num: 5&#125;)&#125;&gt;-5&lt;/button&gt;     &lt;button onClick=&#123;e =&gt; dispatch(&#123;type: &quot;add_number&quot;, num: 100&#125;)&#125;&gt;+100&lt;/button&gt;\n\n\n\n47.useMemo的使用在进行大量的计算的时候，使用useMemo可以避免重复的渲染\n可以对子组件传递相同内容的对象的时候避免重新渲染\nimport React, &#123; memo, useCallback &#125; from &#x27;react&#x27;import &#123; useMemo, useState &#125; from &#x27;react&#x27;const HelloWorld = memo(function(props) &#123;  console.log(&quot;HelloWorld被渲染~&quot;)  return &lt;h2&gt;Hello World&lt;/h2&gt;&#125;)function calcNumTotal(num) &#123;  // console.log(&quot;calcNumTotal的计算过程被调用~&quot;)  let total = 0  for (let i = 1; i &lt;= num; i++) &#123;    total += i  &#125;  return total&#125;const App = memo(() =&gt; &#123;  const [count, setCount] = useState(0)  // const result = calcNumTotal(50)  // 1.不依赖任何的值, 进行计算  const result = useMemo(() =&gt; &#123;    return calcNumTotal(50)  &#125;, [])  // 2.依赖count  // const result = useMemo(() =&gt; &#123;  //   return calcNumTotal(count*2)  // &#125;, [count])  // 3.useMemo和useCallback的对比  function fn() &#123;&#125;  // const increment = useCallback(fn, [])  // const increment2 = useMemo(() =&gt; fn, [])  // 4.使用useMemo对子组件渲染进行优化  // const info = &#123; name: &quot;why&quot;, age: 18 &#125;  const info = useMemo(() =&gt; (&#123;name: &quot;why&quot;, age: 18&#125;), [])  return (    &lt;div&gt;      &lt;h2&gt;计算结果: &#123;result&#125;&lt;/h2&gt;      &lt;h2&gt;计数器: &#123;count&#125;&lt;/h2&gt;      &lt;button onClick=&#123;e =&gt; setCount(count+1)&#125;&gt;+1&lt;/button&gt;      &lt;HelloWorld result=&#123;result&#125; info=&#123;info&#125; /&gt;    &lt;/div&gt;  )&#125;)export default App\n\n48.useCallback是针对回调函数进行优化，useMemo是对返回值进行优化。userCallback可以用于传递给被pureComponent或者memo包裹的子组件的函数\nimport React, &#123; memo, useState, useCallback, useRef &#125; from &#x27;react&#x27;// useCallback性能优化的点:// 1.当需要将一个函数传递给子组件时, 最好使用useCallback进行优化, 将优化之后的函数, 传递给子组件//如果没有使用usecallback，函数式组件在发生更新的时候，所有代码都会重新执行，传递给子组件的函数会重新生成，如果使用usecallback,会根据第二个参数数组中的值，是否生成新的函数，使子组件是否重新渲染// props中的属性发生改变时, 组件本身就会被重新渲染，const HYHome = memo(function(props) &#123;  const &#123; increment &#125; = props  console.log(&quot;HYHome被渲染&quot;)  return (    &lt;div&gt;      &lt;button onClick=&#123;increment&#125;&gt;increment+1&lt;/button&gt;      &#123;/* 100个子组件 */&#125;    &lt;/div&gt;  )&#125;)const App = memo(function() &#123;  const [count, setCount] = useState(0)  const [message, setMessage] = useState(&quot;hello&quot;)  // 闭包陷阱: useCallback  解决闭包陷阱方式一，但是会生成新的函数  // const increment = useCallback(function foo() &#123;  //   console.log(&quot;increment&quot;)  //   setCount(count+1)  // &#125;, [count])  // 进一步的优化: 当count发生改变时, 也使用同一个函数(了解)  // 做法一: 将count依赖移除掉, 缺点: 闭包陷阱,因为此时的foo和原来的foo不是同一个foo,而原来的foo依然使用之前的count  // const increment = useCallback(function foo() &#123;  //   console.log(&quot;increment&quot;)  //   setCount(count+1)  // &#125;, [])  // 做法二: useRef, 在组件多次渲染时, 返回的是同一个值  const countRef = useRef()  countRef.current = count  const increment = useCallback(function foo() &#123;    console.log(&quot;increment&quot;)    setCount(countRef.current + 1)  &#125;, [])  // 普通的函数  // const increment = () =&gt; &#123;  //   setCount(count+1)  // &#125;  return (    &lt;div&gt;      &lt;h2&gt;计数: &#123;count&#125;&lt;/h2&gt;      &lt;button onClick=&#123;increment&#125;&gt;+1&lt;/button&gt;      &lt;HYHome increment=&#123;increment&#125;/&gt;      &lt;h2&gt;message:&#123;message&#125;&lt;/h2&gt;      &lt;button onClick=&#123;e =&gt; setMessage(Math.random())&#125;&gt;修改message&lt;/button&gt;    &lt;/div&gt;  )&#125;)// function foo(name) &#123;//   function bar() &#123;//     console.log(name)//   &#125;//   return bar// &#125;// const bar1 = foo(&quot;why&quot;)// bar1() // why// bar1() // why// const bar2 = foo(&quot;kobe&quot;)// bar2() // kobe// bar1() // whyexport default App\n\nuseCallback会返回一个函数的memoized(记忆的)，在依赖不变的情况下，多次定义的时候，返回的值是相同的。通常使用useCallback的目的是不希望子组件进行多次渲染，并不是为了函数继续缓存\nuseRefuseRef返回一个ref对象，返回的ref对象再组件的整个生命周期保持不变，会指向同一个对象\nuseRef的两种用法：\n​\t用法一：引入DOM(或者组件，但是需要class组件)元素\n​\t用法二： 保存一个数据，这个对象在整个生命周期可以保持不变\n49.Refs的转发      就是父组件想获取到子组件的ref,在高阶组件中转发refs      可以使用React.forwardRef()      const ref&#x3D;useRef(initialValue)&#x2F;&#x2F;初始化值后不会发生改变\t\nexport default function RefHookDemo02() &#123;  const [count, setCount] = useState(0);  const numRef = useRef(count);  useEffect(() =&gt; &#123;    numRef.current = count;  &#125;, [count])  return (    &lt;div&gt;      &#123;/* &lt;h2&gt;numRef中的值: &#123;numRef.current&#125;&lt;/h2&gt;      &lt;h2&gt;count中的值: &#123;count&#125;&lt;/h2&gt; */&#125;      &lt;h2&gt;count上一次的值: &#123;numRef.current&#125;&lt;/h2&gt;      &lt;h2&gt;count这一次的值: &#123;count&#125;&lt;/h2&gt;      &lt;button onClick=&#123;e =&gt; setCount(count + 10)&#125;&gt;+10&lt;/button&gt;    &lt;/div&gt;  )&#125;//useEffect和useRef结合使用可以修改numRef.current\n\n50.useImperativeHandle要和React.forwardRef()一起使用\n通过forwardRef可以将ref转发到子组件，获取到子组件内部的ref,子组件拿到父组件创建的ref绑定到某个元素上，forwordRef会将子组件的DOM暴露给父组件，父组件拿到DOM之后可以任意操作，可以使用useImperativeHandle暴露固定的操作\nimport React, &#123; memo, useRef, forwardRef, useImperativeHandle &#125; from &#x27;react&#x27;const HelloWorld = memo(forwardRef((props, ref) =&gt; &#123;  const inputRef = useRef()  // 子组件对父组件传入的ref进行处理  useImperativeHandle(ref, () =&gt; &#123;    return &#123;      focus() &#123;        console.log(&quot;focus&quot;)        inputRef.current.focus()      &#125;,      setValue(value) &#123;        inputRef.current.value = value      &#125;    &#125;  &#125;)  return &lt;input type=&quot;text&quot; ref=&#123;inputRef&#125;/&gt;&#125;))const App = memo(() =&gt; &#123;  const titleRef = useRef()  const inputRef = useRef()  function handleDOM() &#123;    // console.log(inputRef.current)    inputRef.current.focus()    // inputRef.current.value = &quot;&quot;    inputRef.current.setValue(&quot;哈哈哈&quot;)  &#125;  return (    &lt;div&gt;      &lt;h2 ref=&#123;titleRef&#125;&gt;哈哈哈&lt;/h2&gt;      &lt;HelloWorld ref=&#123;inputRef&#125;/&gt;      &lt;button onClick=&#123;handleDOM&#125;&gt;DOM操作&lt;/button&gt;    &lt;/div&gt;  )&#125;)export default App\n\n51.自定义hook：就是将react的hook封装成函数52.fiber的原理53.不要在条件表达式中使用hook54.使用normailze.css对项目进行初始化    使用@craco&#x2F;craco修改react 配置        修改webpack的alias    使用react-config-router进行路由配置    使用styled-compoments进行写css样式        background:url(${reuire()})&#x2F;&#x2F;需要使用require来引入图片        搜索框使用antDesign        数据都是用redux来管理        用redux-thunk进行异步请求        配置redux-devtool        将各个模块的redux分开写再各个文件中，然后进行合并，使用combineReducers        store使用Provider进行传递        所有组件用memo()包裹管理        使用redux的hook:useDispatch()                       useSelector(state&#x3D;&gt;({}),shallowEqual)                       shallowEqual&#x2F;&#x2F;进行浅层比较,做优化        Immutablejs可以解决使用拷贝来决绝数据可变性的问题，带来的性能问题\t\t\nconst im=immutable\t\t\tconst info=&#123;&#125;\t\t\tconst imfoIM=im(info)\t\t\timfoIm.set()\t\t\timfoIM.get()\t\t\timfoIm.list()\t\t\timfoim.fromJS()//深层次转换\n\n​\t\t2.只能再react函数中调用成immutable类型​\t\t\tstate.getIn([“a”,”b”])&#x2F;&#x2F;相当于a.b​\t\t\tstyled-components的传参​\t\t\t使用useCallback对需要传给子组件的函数进行包裹，可以有缓存，并提高性能​\t\t\t​\t\t\t使用 redux-immutable中的commineReducer来优化combineReducer,提高性能\n55 Hook的本质就是javascript函数，他要遵循两条规则    1.只在最顶层使用hook        不要再循环，条件或者嵌套函数中调用hook,确保总是再你的react函数的最顶层去调用他们        遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确    2.只能再react函数中调用Hook      不要在普通的javascript中调用hook,可以在reat函数组件中调用hook,也可以在在定义hook中调用其他hook56.自定义HOOK一定要以use开头57.在两个组件中使用相同的 Hook 会共享 state 吗？不会。自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。58.自定义 Hook 如何获取独立的 state？每次调用 Hook，它都会获取独立的 state    由于我们直接调用了 useFriendStatus，从 React 的角度来看，我们的组件只是调用了 useState 和 useEffect59.惰性初始化state\ninitialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：\nconst [state, setState] = useState(() =&gt; &#123;  const initialState = someExpensiveComputation(props);  return initialState;&#125;);\n\n60.useEffect是在每一轮渲染结束后执行61.组件卸载时需要清除effect创建的订阅，定时器等，useEffect函数需要返回一个清理函数\nuseEffect(() =&gt; &#123;  const subscription = props.source.subscribe();  return () =&gt; &#123;    // 清除订阅    subscription.unsubscribe();  &#125;;&#125;);\n\n为防止内存泄漏，清除函数会在组件卸载之前执行。另外，如果组件多次渲染，则会在子啊个effect之前，上一个effect就会被清除\n62.effect的执行时机与componentDidMount,cimponentDidUpadate不同的是，在浏览器完成布局与绘制之后，\n传给useEffect的函数会延迟调用，这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理情况，因此不应在函数值执行阻塞浏览器更新的操作\n63.useContextconst MyContext= React.createContext(value)const value = useContext(MyContext);\n\nmyContext是React.createContext的返回值，并返回该context的当前值，当前的value值由\n他的上层组件距离当前组件最近的&lt;MyContext.Provider&gt;的value prop决定的\n当Provider中的value发生更新的时候，useContext就会出发重新渲染，即使组件时使用React.emo包裹，或者使用shouldComponentUpdat生命周期，该组件都会重新渲染\n只要MyConetext里面的值发生改变，使用了useContext的组件都会重新渲染，如果重新渲染开销大，可以使用memoization来优化\nuseContext(MyContext)&#x3D;&#x3D;&#x3D;&gt;class中的static contextType&#x3D;MyContext或者&lt;MyContext.Consumer&gt;\nuseContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context。\n64.useReducerconst [state, dispatch] = useReducer(reducer, initialArg, init);useState的替代方案在某些场合会比useState更加适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。\n\nconst initialState = &#123;count: 0&#125;;function reducer(state, action) &#123;  switch (action.type) &#123;    case &#x27;increment&#x27;:      return &#123;count: state.count + 1&#125;;    case &#x27;decrement&#x27;:      return &#123;count: state.count - 1&#125;;    default:      throw new Error();  &#125;&#125;function Counter() &#123;  const [state, dispatch] = useReducer(reducer, initialState);  return (    &lt;&gt;      Count: &#123;state.count&#125;      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;    &lt;/&gt;  );&#125;\n\n惰性初始化useReducer的第三个参数传入一个函数，这样初始state将设置为传入函数的返回值\n可以通过外部来传入\nfunction init(initialCount) &#123;  return &#123;count: initialCount&#125;;&#125;function reducer(state, action) &#123;  switch (action.type) &#123;    case &#x27;increment&#x27;:      return &#123;count: state.count + 1&#125;;    case &#x27;decrement&#x27;:      return &#123;count: state.count - 1&#125;;    case &#x27;reset&#x27;:      return init(action.payload);    default:      throw new Error();  &#125;&#125;function Counter(&#123;initialCount&#125;) &#123;  const [state, dispatch] = useReducer(reducer, initialCount, init);  return (    &lt;&gt;      Count: &#123;state.count&#125;      &lt;button        onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;        Reset      &lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;    &lt;/&gt;  );&#125;\n\n如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 Object.is 比较算法 来比较 state。）\n如果你在渲染期间执行了高开销的计算，则可以使用 useMemo 来进行优化。\nuseReducer不可以作为redux的替代方案，不可以进行数据共享\n65.使用memo包裹函数，可以进行性能优化，会对props进行浅层比较，如果props没有发生更新，则不会重新渲染\n66.没有优化以前。父组件发生改变子组件也会重新渲染\n67.useCallback\n返回一个 memoized 回调函数。\n把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。\n\n\n68.useMeno\n​\tuseCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。\nuseCallback是返回memoized 回调函数。useMeno是返回一个memoized值\nuseMemo只会在依赖项发生改变时才会重新计算执行，返回新的值，避免每次渲染时都进行高开销的计算\n记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。\n如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值\n\n\n69.useRef\nuseRef返回一个ref对象，返回的ref对象在组件的整个生命周期保持不变\n最常用的ref是两种用法\n​\t1.引入DOM(或者是class组件)元素，不可以用在函数组件中\n​\t2.保存一个数据，这个对象在整个生命周期中可以保持不变\n\n\n70.useImperativeHandle\nuseImperativeHandle要和forwardRef结合使用，使用useImperativeHandle可以使父元素不可以对子组件中的ref进行随意操作\n\n\n71.useLayoutEffect\n​\t和useEffect的区别是\n​\tuseEffect会在渲染的内容更新到DOM之后再执行，而不会阻塞DOM的更新\n​\tuseLayoutEffect会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新\n​\t\n\n72.redux-thunk\n​\t 使用中间件目的是再dispatch的action和reducer之间扩展自己的代码，例如日志记录，调用异步接口，添加代码调试功能等等\n​\t可以使用redux-thunk发送异步请求\n​\t1.通常情况下。dispatch(action),actionn余姚是一个javascript对象\n​\t2.redux-thunk可以让dispatch(action函数)，action可以是一个函数\n​\t3.这个函数被调用的时候，会返回一个函数并给这个函数传一个patch,getState函数\n​\t\t\t\tdispatch函数用于再次派发action\n​\t\t\t\tgetState函数获取到之前的状态\n\n\n73.redux-devtools是用来对redux中的状态进行跟踪调试\n\n74.combineReducersredux中提供了一个函数combineReducers来合并多个reducer\ncombinerReducer的实现\n​\t它会将reducer合并，并且返回一个combation函数相当于是新的reducer\n​\t在执行combination函数的过程中，它会通过判断前后返回的数据是否相同来决定返回之前的state还是新的state；\n   新的state会触发订阅者发生对应的刷新，而旧的state可以有效的组织订阅者发生刷新；\n\n75.useSelector()import React from &#x27;react&#x27;import &#123; shallowEqual, useSelector &#125; from &#x27;react-redux&#x27;export const CounterComponent = () =&gt; &#123;  const counter = useSelector((state) =&gt; state.counter,shallowEqual)  return &lt;div&gt;&#123;counter&#125;&lt;/div&gt;&#125;//在hook中使用redux,使用useSlectore来获取state\n\n76.useDispatch()const dispatch = useDispatch()//派发action\n\nexport const Todos = () =&gt; &#123;  const dispatch = useDispatch()  useEffect(() =&gt; &#123;    dispatch(fetchTodos())    // Safe to add dispatch to the dependencies array  &#125;, [dispatch])&#125;\n\n77.useStore()替代createStore()\n","categories":["react","note"]},{"title":"rollup学习","url":"/2022/09/08/rollup%E5%AD%A6%E4%B9%A0/","content":"","categories":["常用构建工具","rollup"]},{"title":"secket.io笔迹","url":"/2022/09/24/secket-io%E7%AC%94%E8%BF%B9/","content":""},{"title":"typescript笔记","url":"/2022/08/05/typescript%E7%AC%94%E8%AE%B0/","content":"1.在定义一个变量时，基本数据类型可以用类型推断，不用定义类型\nlet msg = &quot;hello there!&quot;;\n\n2.ts的常用的数据类型\nstring,number,boolean,arrays,any,function,object,union type,Type Aliases,Interfaces，Type Assertions，bigint，symbol,Type Assertions,.Literal Types,Enums ,null,undefined,any,unknown,void,never ,Tuple\n\n3.interface和type aliases的区别\n实现继承的方式不同interface Animal &#123;  name: string&#125;interface Bear extends Animal &#123;  honey: boolean&#125;type Animal = &#123;  name: string&#125;type Bear = Animal &amp; &#123;   honey: boolean &#125;添加新的字段interface Window &#123;  title: string&#125;interface Window &#123;  ts: TypeScriptAPI&#125;类型别名不能够修改已经创建的字段type Window = &#123;  title: string&#125;type Window = &#123;  ts: TypeScriptAPI&#125; // Error: Duplicate identifier &#x27;Window&#x27;.const src = &#x27;const a = &quot;Hello World&quot;&#x27;;window.ts.transpileModule(src, &#123;&#125;);接口只能声明对象，不能够重命名原语类型别名不能够声明合并，但是接口可以如果是定义非对象类型，通常推荐使用type如果是定义对象类型，那么他们是有区别的：interface 可以重复的对某个接口来定义属性和方法；而type定义的是别名，别名是不能重复的\n\n4.Type Assertions类型断言\nTypeScript 只允许类型断言转换为更具体或更不具体的类型版本，而不可以转成没有关系的类型const a = (expr as any) as T;  可以将两种不相关的类型进行转换时，要进行两次断言，先断雁城any或者unknown\n\n5.Literal Types 文本类型\nconst constantString = &quot;Hello World&quot;;//使用const定义的常量类型function printText(s: string, alignment: &quot;left&quot; | &quot;right&quot; | &quot;center&quot;) &#123;  // ...&#125;您可以使用 as const 将整个对象转换为类型文字：const req = &#123; url: &quot;https://example.com&quot;, method: &quot;GET&quot; &#125; as const;handleRequest(req.url, req.method);\n\n.Enums 枚举\n7.ts的运行环境\n方式一：tsc math.ts   node math.js  这种方式会比较麻烦方式二：webpack中配置本地的运行环境  使用ts-loader方式三：使用ts-nodenpm install ts-node -gnpm install tslib @types/node -gts-node math.ts\n\n8.unkonwn类型和any类型的区别\n任何类型都可以是any类型,ts不会对any类型的变量进行类型检测，任何类型也是可以赋值给unknown,但是使用这个变量必须进行类型检查，否则就会报错\n\n9.Tuple类型(元组)\n元组类型就是不同类型的数组的集合\n\n10.Never类型\nNever类型指永不存在的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型11.函数参数\n\n\n匿名函数的参数类型\n\n\n13.函数参数的对象类型\n\n14.函数参数对象可选参数\n\n15.联合类型\n\n16.一个参数一个可选类型的时候, 它其实类似于是这个参数是 类型|undefined 的联合类型\n17.非空类型断言!\n\n18.可选链操作\n19.!!运算符\n可以将其他数据类型转换成boolean\n20.??操作符  空值合并操作符\nconst messgae1 = &quot;1111&quot;;const content = messgae1 ?? &quot;你好&quot;;如果message1是null或者undefined,content就会使用后面的值，message是空字符串不生效\n\n21.类型缩小  Type Narrowing\n类型缩小就是将例如联合类型进行精确到具体的类型\n常见的类型保护有\ntypeof\n&#x3D;&#x3D;&#x3D;，！&#x3D;&#x3D;\ninstanceof\nin\n…..\n\n\n\n\n\n22.函数类型定义\n\n23.参数的可选类型\n\n24.参数的默认值\n\n25.剩余参数\n\n26.指定this的绑定\n\n27.函数的重载\n通过联合类型的有两个缺点：\n​ 1.需要进行很多类型逻辑判断\n​ 2.返回值类型不能判定\n\n\n27.类的定义\n\n28.类的继承\n\n29.类的多态\n\n30.类的成员修饰符\nprivate 修饰的属性和方法只能在该类内部使用\nprotected修饰的属性和方法只能在类本身及其子类内部使用\npublic是默认的成员修饰符，可以在外部，类，子类使用\n\n31.readonly修饰符\n\n32.访问器setter&#x2F;getter\n\n33.类的静态成员\n\n34.抽象类abstract\n什么是 抽象方法? 在TypeScript中没有具体实现的方法(没有方法体)，就是抽象方法\n抽象方法，必须存在于抽象类中\n抽象类是使用abstract声明的类\n\n35.类本身也可以作为另外一变量的类型\n36.接口的声明\n​ \n37.接口的索引类型\n\n38.函数类型\ninterface也可以定义函数，建议使用类型别名列定义函数\n\n39.接口的继承\n\n\n40.交叉类型\n\n41.字面量赋值\n\n\n42.枚举类型\n枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型； p枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型\n\n\n43.泛型\n\n\n44.泛型接口的定义\n\n45.泛型作为类\n\n46.泛型约束\n\n47.namespace\nnamespace会形成独立的空间，里面的内容需要使用export，外部才可以使用，否则外部无法访问\n48.命名空间的拆分\n可以将命名空间的内容拆分到多个文件中\n49..d.ts文件  类型声明文件\n它仅仅用来做类型检测，告知typescript我们有哪 些类型\n那么typescript会在哪里查找我们的类型声明呢？\n内置类型声明；\n外部定义类型声明；\n自己定义类型声明；\n类型声明文件主要适用于外部类库，例如引入的npm包没有做类型声明，则需要自己写类型声明文件\n50.内置类型声明\n内置类型声明是typescript自带的、帮助我们内置了JavaScript运行时的一些标准化API的声明文件。包括比如Math、Date等内置类型，也包括DOM API，比如Window、Document等； 内置类型声明通常在我们安装typescript的环境中会带有的；\n51.外部定义类型声明和自定义声明\n外部类型声明通常是我们使用一些库（比如第三方库）时，需要的一些类型声明\n这些库通常有两种类型声明方式：\n 方式一：在自己库中进行类型声明（编写.d.ts文件），比如axios\n方式二：通过社区的一个公有库DefinitelyTyped存放类型声明文件\n该库的GitHub地址：https://github.com/DefinitelyTyped/DefinitelyTyped/\n该库查找声明安装方式的地址：https://www.typescriptlang.org/dt/search?search&#x3D;\n比如我们安装react的类型声明： npm i @types&#x2F;react –save-dev\n 什么情况下需要自己来定义声明文件呢？\n情况一：我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash\n情况二：我们给自己的代码中声明一些类型，方便在其他地方直接进行使用；\n52.tsconfig.js文件\n","categories":["typescript","note"]},{"title":"vite3学习","url":"/2022/09/08/vite3%E5%AD%A6%E4%B9%A0/","content":"","categories":["常用构建工具","vite"]},{"title":"vue-router笔记","url":"/2022/08/20/vue-router%E7%AC%94%E8%AE%B0/","content":"路由器维护一张映射表，映射表会决定数据的流向，一个ip地址对应的一台服务器的mac地址，一台服务器只有一个mac地址url的hashurl的hash也就是锚点(#),本质上就是改变window.location的href的属性\n我们可以通过赋值location.hash来改变href,但是不刷新页面\nhash的优势就是兼容性好，在IE中可以运行，但是就是有个缺陷，#，显得不像是一个真实的路径\n&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;a href=&quot;#/home&quot;&gt;home&lt;/a&gt;      &lt;a href=&quot;#/about&quot;&gt;about&lt;/a&gt;    &lt;/div&gt;    &lt;script&gt;      const app = document.querySelector(&quot;#app&quot;);      window.addEventListener(&quot;hashchange&quot;, () =&gt; &#123;        console.log(location.hash);        switch (location.hash) &#123;          case &quot;#/home&quot;:            app.innerHTML = &quot;home&quot;;            break;          case &quot;#/about&quot;:            app.innerHTML = &quot;about&quot;;            break;          default:            app.innerHTML = &quot;app&quot;;        &#125;      &#125;);    &lt;/script&gt;  &lt;/body&gt;\n\nhtml5 history apihistory是html5新增的api 他有六种模式改变url而不刷新页面\nreplaceState  替换原来的路径\npushState  使用新的路径\npopState 路径回退\ngo 向前或者向后改变路径\nforward 向前改变路径\nback 向后改变路径\n&lt;body&gt;  &lt;div id=&quot;App&quot;&gt;    &lt;a href=&quot;/about&quot;&gt;about&lt;/a&gt;    &lt;a href=&quot;/home&quot;&gt;home&lt;/a&gt;    &lt;div class=&quot;show&quot;&gt;&lt;/div&gt;    &lt;script&gt;      const show = document.getElementsByClassName(&quot;show&quot;)[0];      const elea = document.getElementsByTagName(&quot;a&quot;);      console.log(elea);      window.addEventListener(&quot;popstate&quot;, historyChange);      window.addEventListener(&quot;go&quot;, historyChange);      for (const item of elea) &#123;        item.addEventListener(&quot;click&quot;, (e) =&gt; &#123;          e.preventDefault();          const href = item.getAttribute(&quot;href&quot;);          console.log(href);          history.pushState(&#123;&#125;, &quot;&quot;, href);          historyChange();        &#125;);      &#125;      function historyChange() &#123;        switch (location.pathname) &#123;          case &quot;/about&quot;:            show.innerHTML = &quot;about&quot;;            break;          case &quot;/home&quot;:            show.innerHTML = &quot;home&quot;;            break;          default:            break;        &#125;      &#125;    &lt;/script&gt;  &lt;/div&gt;&lt;/body&gt;\n\n安装npm install vue-router\n\n使用步骤router&#x2F;index.js\nimport &#123;  createRouter,  createWebHashHistory,  createWebHistory,&#125; from &quot;vue-router&quot;;// import Home from &#x27;../Views/Home.vue&#x27;// import About from &#x27;../Views/About.vue&#x27;// 路由的懒加载 ，可以进行分包，减少报的大小，进行按需加载   webpackChunkName设置包的名字// const Home = () =&gt; import(/* webpackChunkName: &#x27;home&#x27; */&quot;../Views/Home.vue&quot;)// const About = () =&gt; import(/* webpackChunkName: &#x27;about&#x27; */&quot;../Views/About.vue&quot;)// 创建一个路由: 映射关系const router = createRouter(&#123;  // 指定采用的模式: hash  history: createWebHashHistory(),  // history: createWebHistory(),  // 映射关系  routes: [    &#123;//设置默认路径并进行重定向      path: &quot;/&quot;,      redirect: &quot;/home&quot;,    &#125;,    &#123;      name: &quot;home&quot;,//路由记录独一无二的名称      path: &quot;/home&quot;,      component: () =&gt; import(&quot;../Views/Home.vue&quot;),//组件懒加载      meta: &#123;//这是路由元信息，不在url中携带的信息        name: &quot;why&quot;,        age: 18,      &#125;,       //子路由      children: [        &#123;          path: &quot;/home&quot;,          redirect: &quot;/home/recommend&quot;,        &#125;,        &#123;          path: &quot;recommend&quot;, // /home/recommend          component: () =&gt; import(&quot;../Views/HomeRecommend.vue&quot;),        &#125;,        &#123;          path: &quot;ranking&quot;, // /home/ranking          component: () =&gt; import(&quot;../Views/HomeRanking.vue&quot;),        &#125;,      ],    &#125;,    &#123;      name: &quot;about&quot;,      path: &quot;/about&quot;,      component: () =&gt; import(&quot;../Views/About.vue&quot;),    &#125;,    &#123;      path: &quot;/user/:id&quot;,      component: () =&gt; import(&quot;../Views/User.vue&quot;),    &#125;,    &#123;      path: &quot;/order&quot;,      component: () =&gt; import(&quot;../Views/Order.vue&quot;),    &#125;,    &#123;      path: &quot;/login&quot;,      component: () =&gt; import(&quot;../Views/Login.vue&quot;),    &#125;,    &#123;      // abc/cba/nba  配置404页面      path: &quot;/:pathMatch(.*)*&quot;,      component: () =&gt; import(&quot;../Views/NotFound.vue&quot;),    &#125;,  ],&#125;);// 1.动态管理路由let isAdmin = true;if (isAdmin) &#123;  // 一级路由  router.addRoute(&#123;    path: &quot;/admin&quot;,    component: () =&gt; import(&quot;../Views/Admin.vue&quot;),  &#125;);  // 添加vip页面 &quot;home&quot;必须唯一  router.addRoute(&quot;home&quot;, &#123;    path: &quot;vip&quot;,    component: () =&gt; import(&quot;../Views/HomeVip.vue&quot;),  &#125;);&#125;// 获取router中所有的映射路由对象console.log(router.getRoutes());// 2.路由导航守卫// 进行任何的路由跳转之前, 传入的beforeEach中的函数都会被回调// 需求: 进入到订单(order)页面时, 判断用户是否登录(isLogin -&gt; localStorage保存token)// 情况一: 用户没有登录, 那么跳转到登录页面, 进行登录的操作// 情况二: 用户已经登录, 那么直接进入到订单页面router.beforeEach((to, from) =&gt; &#123;  // 1.进入到任何别的页面时, 都跳转到login页面  // if (to.path !== &quot;/login&quot;) &#123;  //   return &quot;/login&quot;  // &#125;  // 2.进入到订单页面时, 判断用户是否登录  const token = localStorage.getItem(&quot;token&quot;);  if (to.path === &quot;/order&quot; &amp;&amp; !token) &#123;    return &quot;/login&quot;;  &#125;&#125;);export default router;\n\n&#x2F;&#x2F;main.js\n// 5. 创建并挂载根实例const app = Vue.createApp(App)//确保 _use_ 路由实例使//整个应用支持路由。注册插件app.use(router)app.mount(&#x27;#app&#x27;)\n\n在组建中使用\n&lt;router-link&gt;和&lt;router-view&gt;//home.vue&lt;div class=&quot;home-nav&quot;&gt;      &lt;router-link to=&quot;/home/recommend&quot;&gt;推荐&lt;/router-link&gt;      &lt;router-link to=&quot;/home/ranking&quot;&gt;排行&lt;/router-link&gt;&lt;/div&gt;    &lt;button @click=&quot;logoutClick&quot;&gt;退出登录&lt;/button&gt;    &lt;!-- 占位组件 --&gt;   &lt;router-view&gt;&lt;/router-view&gt;\n\n&lt;router-link&gt; Props表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个 string 或者是描述目标位置的对象。\n&lt;!-- 字符串 --&gt;&lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href=&quot;/home&quot;&gt;Home&lt;/a&gt;&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link :to=&quot;&#x27;/home&#x27;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 同上 --&gt;&lt;router-link :to=&quot;&#123; path: &#x27;/home&#x27; &#125;&quot;&gt;Home&lt;/router-link&gt;&lt;!-- 命名的路由 --&gt;&lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: &#x27;123&#x27; &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 `/register?plan=private` --&gt;&lt;router-link :to=&quot;&#123; path: &#x27;/register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125;&#125;&quot;&gt;  Register&lt;/router-link&gt;\n\nreplace设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push()，所以导航后不会留下历史记录。\n&lt;router-link to=&quot;/abc&quot; replace&gt;&lt;/router-link&gt;\n\nactive-class链接激活时，应用于渲染的 &lt;a&gt; 的 class\n默认值：&quot;router-link-active&quot;\n&lt;router-link to=&quot;/about&quot; replace active-class=&quot;active&quot;&gt;关于&lt;/router-link&gt;\n\n可以修改默认的class或者添加新的class\nexact-active-class链接精准激活时，应用于渲染的 &lt;a&gt; 的 class\n默认值：&quot;router-link-exact-active&quot;\n带参数的动态路由匹配const User = &#123;  template: &#x27;&lt;div&gt;User&lt;/div&gt;&#x27;,&#125;// 这些都会传递给 `createRouter`const routes = [  // 动态字段以冒号开始  &#123; path: &#x27;/users/:id&#x27;, component: User &#125;,]\n\n参数可以被当前路由的params获取\nconst User = &#123;  template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;,&#125;\n\n监听响应路由参数的变化使用带有参数的路由时需要注意的是，当用户从 /users/johnny 导航到 /users/jolyne 时，相同的组件实例将被重复使用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会被调用。\n要对同一个组件中参数的变化做出响应的话，你可以简单地 watch $route 对象上的任意属性，在这个场景中，就是 $route.params ：\nconst User = &#123;  template: &#x27;...&#x27;,  created() &#123;    this.$watch(      () =&gt; this.$route.params,      (toParams, previousParams) =&gt; &#123;        // 对路由变化做出响应...      &#125;    )  &#125;,&#125;\n\n或者，使用 beforeRouteUpdate 导航守卫，它也可以取消导航：\nconst User = &#123;  template: &#x27;...&#x27;,  async beforeRouteUpdate(to, from) &#123;    // 对路由变化做出响应...    this.userData = await fetchUser(to.params.id)  &#125;,&#125;\n\n捕获所有路由或 404 Not found 路由常规参数只匹配 url 片段之间的字符，用 / 分隔。如果我们想匹配任意路径，我们可以使用自定义的 路径参数 正则表达式，在 路径参数 后面的括号中加入 正则表达式 :\nconst routes = [  // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下  &#123; path: &#x27;/:pathMatch(.*)*&#x27;, name: &#x27;NotFound&#x27;, component: NotFound &#125;,  // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下  &#123; path: &#x27;/user-:afterUser(.*)&#x27;, component: UserGeneric &#125;,]\n\n在这个特定的场景中，我们在括号之间使用了自定义正则表达式，并将pathMatch 参数标记为可选可重复。这样做是为了让我们在需要的时候，可以通过将 path 拆分成一个数组，直接导航到路由：\nthis.$router.push(&#123;  name: &#x27;NotFound&#x27;,  // 保留当前路径并删除第一个字符，以避免目标 URL 以 `//` 开头。  params: &#123; pathMatch: this.$route.path.substring(1).split(&#x27;/&#x27;) &#125;,  // 保留现有的查询和 hash 值，如果有的话  query: this.$route.query,  hash: this.$route.hash,&#125;)\n\n&lt;h2&gt;NotFound: 您当前的路径&#123;&#123; $route.params.pathMatch &#125;&#125;不正确, 请输入正确的路径!&lt;/h2&gt;\n\n这里还有另外一种写法：  注意：我在&#x2F;:pathMatch(.*)后面又加了一个 *；\n这时候$route.params.pathMatch将是数组\n编程式导航在 Vue 实例中，你可以通过 $router 访问路由实例。因此你可以调用this.$router.push\n想要导航到不同的 URL，可以使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL\n当你点击 &lt;router-link&gt; 时，内部会调用这个方法，所以点击 &lt;router-link :to=&quot;...&quot;&gt; 相当于调用 router.push(...)\n// 字符串路径router.push(&#x27;/users/eduardo&#x27;)// 带有路径的对象router.push(&#123; path: &#x27;/users/eduardo&#x27; &#125;)// 命名的路由，并加上参数，让路由建立 urlrouter.push(&#123; name: &#x27;user&#x27;, params: &#123; username: &#x27;eduardo&#x27; &#125; &#125;)// 带查询参数，结果是 /register?plan=privaterouter.push(&#123; path: &#x27;/register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125; &#125;)// 带 hash，结果是 /about#teamrouter.push(&#123; path: &#x27;/about&#x27;, hash: &#x27;#team&#x27; &#125;)\n\n注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ：\nconst username = &#x27;eduardo&#x27;// 我们可以手动建立 url，但我们必须自己处理编码router.push(`/user/$&#123;username&#125;`) // -&gt; /user/eduardo// 同样router.push(&#123; path: `/user/$&#123;username&#125;` &#125;) // -&gt; /user/eduardo// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益router.push(&#123; name: &#x27;user&#x27;, params: &#123; username &#125; &#125;) // -&gt; /user/eduardo// `params` 不能与 `path` 一起使用router.push(&#123; path: &#x27;/user&#x27;, params: &#123; username &#125; &#125;) // -&gt; /user\n\n当指定 params 时，可提供 string 或 number 参数（或者对于可重复的参数可提供一个数组）。任何其他类型（如 undefined、false 等）都将被自动字符串化。对于可选参数，你可以提供一个空字符串（&quot;&quot;）来跳过它。\n由于属性 to 与 router.push 接受的对象种类相同，所以两者的规则完全相同。\nrouter.push 和所有其他导航方法都会返回一个 Promise，让我们可以等到导航完成后才知道是成功还是失败。我们将在 Navigation Handling 中详细介绍。\nrouter.replace它在导航时不会向 history 添加新记录\nrouter.push(&#123; path: &#x27;/home&#x27;, replace: true &#125;)// 相当于router.replace(&#123; path: &#x27;/home&#x27; &#125;)\n\n// 向前移动一条记录，与 router.forward() 相同router.go(1)// 返回一条记录，与 router.back() 相同router.go(-1)// 前进 3 条记录router.go(3)// 如果没有那么多记录，静默失败router.go(-100)router.go(100)\n\n命名视图用于相同的path之间的切换组件，想同时 (同级) 展示多个视图\n你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default\n&lt;router-view class=&quot;view left-sidebar&quot; name=&quot;LeftSidebar&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view main-content&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view right-sidebar&quot; name=&quot;RightSidebar&quot;&gt;&lt;/router-view&gt;\n\nconst router = createRouter(&#123;  history: createWebHashHistory(),  routes: [    &#123;      path: &#x27;/&#x27;,      components: &#123;        default: Home,        // LeftSidebar: LeftSidebar 的缩写        LeftSidebar,        // 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配        RightSidebar,      &#125;,    &#125;,  ],&#125;)\n\n导航守卫全局前置守卫const router = createRouter(&#123; ... &#125;)router.beforeEach((to, from) =&gt; &#123;  // ...  // 返回 false 以取消导航  return false&#125;)\n\n路由独享的守卫const routes = [  &#123;    path: &#x27;/users/:id&#x27;,    component: UserDetails,    beforeEnter: (to, from) =&gt; &#123;      // reject the navigation      return false    &#125;,  &#125;,]\n\n组件内的守卫const UserDetails = &#123;  template: `...`,  beforeRouteEnter(to, from) &#123;    // 在渲染该组件的对应路由被验证前调用    // 不能获取组件实例 `this` ！    // 因为当守卫执行时，组件实例还没被创建！  &#125;,  beforeRouteUpdate(to, from) &#123;    // 在当前路由改变，但是该组件被复用时调用    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`  &#125;,  beforeRouteLeave(to, from) &#123;    // 在导航离开渲染该组件的对应路由时调用    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`  &#125;,&#125;\n\n使用组合 API#如果你正在使用组合 API 和 setup 函数来编写组件，你可以通过 onBeforeRouteUpdate 和 onBeforeRouteLeave 分别添加 update 和 leave 守卫\n完整的导航解析流程#\n导航被触发。\n在失活的组件里调用 beforeRouteLeave 守卫。\n调用全局的 beforeEach 守卫。\n在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。\n在路由配置里调用 beforeEnter。\n解析异步路由组件。\n在被激活的组件里调用 beforeRouteEnter。\n调用全局的 beforeResolve 守卫(2.5+)。\n导航被确认。\n调用全局的 afterEach 钩子。\n触发 DOM 更新。\n调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。\n\nVue Router 和 组合式 APIimport &#123; useRouter, useRoute &#125; from &#x27;vue-router&#x27;export default &#123;  setup() &#123;    const router = useRouter()    const route = useRoute()    function pushWithQuery(query) &#123;      router.push(&#123;        name: &#x27;search&#x27;,        query: &#123;          ...route.query,        &#125;,      &#125;)    &#125;  &#125;,&#125;\n\n&#x2F;&#x2F;useRouter&#x3D;&gt;$router  useRoute&#x3D;&gt;$route\nuseLink动态路由动态路由主要通过两个函数实现。router.addRoute() 和 router.removeRoute()。它们只注册一个新的路由，也就是说，如果新增加的路由与当前位置相匹配，就需要你用 router.push() 或 router.replace() 来手动导航，才能显示该新路由\n添加嵌套路由要将嵌套路由添加到现有的路由中，可以将路由的 name 作为第一个参数传递给 router.addRoute()，这将有效地添加路由，就像通过 children 添加的一样：\nrouter.addRoute(&#123; name: &#x27;admin&#x27;, path: &#x27;/admin&#x27;, component: Admin &#125;)router.addRoute(&#x27;admin&#x27;, &#123; path: &#x27;settings&#x27;, component: AdminSettings &#125;\n\n这等效于：\nrouter.addRoute(&#123;  name: &#x27;admin&#x27;,  path: &#x27;/admin&#x27;,  component: Admin,  children: [&#123; path: &#x27;settings&#x27;, component: AdminSettings &#125;],&#125;)\n\nVue Router 提供了两个功能来查看现有的路由：\n\nrouter.hasRoute()：检查路由是否存在。\nrouter.getRoutes()：获取一个包含所有路由记录的数组\n\n","categories":["vue","note"]},{"title":"vuex4.0","url":"/2022/08/23/vuex4-0/","content":"Vuex 是什么Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\nnpm install vuex@next --save\n\n//store/index.jsimport &#123; createStore &#125; from &#x27;vuex&#x27;import &#123; CHANGE_INFO &#125; from &#x27;./mutation_types&#x27;import homeModule from &#x27;./modules/home&#x27;import counterModule from &#x27;./modules/counter&#x27;const store = createStore(&#123;  state: () =&gt; (&#123;    // 模拟数据    // counter: 100,    rootCounter: 100,    name: &quot;coderwhy&quot;,    level: 100,    avatarURL: &quot;http://xxxxxx&quot;,    friends: [      &#123; id: 111, name: &quot;why&quot;, age: 20 &#125;,      &#123; id: 112, name: &quot;kobe&quot;, age: 30 &#125;,      &#123; id: 113, name: &quot;james&quot;, age: 25 &#125;    ],    // 服务器数据    // banners: [],    // recommends: []  &#125;),  getters: &#123;    // 1.基本使用    doubleCounter(state) &#123;      return state.counter * 2    &#125;,    totalAge(state) &#123;      return state.friends.reduce((preValue, item) =&gt; &#123;        return preValue + item.age      &#125;, 0)    &#125;,    // 2.在该getters属性中, 获取其他的getters    message(state, getters) &#123;      return `name:$&#123;state.name&#125; level:$&#123;state.level&#125; \t\t\t\t\t\tfriendTotalAge:$&#123;getters.totalAge&#125;`    &#125;,    // 3.getters是可以返回一个函数的, 调用这个函数可以传入参数(了解)    getFriendById(state) &#123;      return function(id) &#123;        const friend = state.friends.find(item =&gt; item.id === id)        return friend      &#125;    &#125;  &#125;,  mutations: &#123;    increment(state) &#123;      state.counter++    &#125;,    changeName(state, payload) &#123;      state.name = payload    &#125;,    incrementLevel(state) &#123;      state.level++    &#125;,     //使用计算属性，将常量作为参数名    [CHANGE_INFO](state, newInfo) &#123;      state.level = newInfo.level      state.name = newInfo.name      // 重要的原则: 不要在mutation方法中执行异步操作      // fetch(&quot;xxxx&quot;).then(res =&gt; &#123;      //   res.json().then(res =&gt; &#123;      //     state.name = res.name      //   &#125;)      // &#125;)    &#125;,    // changeBanners(state, banners) &#123;    //   state.banners = banners    // &#125;,    // changeRecommends(state, recommends) &#123;    //   state.recommends = recommends    // &#125;  &#125;,  actions: &#123;    incrementAction(context) &#123;      // console.log(context.commit) // 用于提交mutation      // console.log(context.getters) // getters      // console.log(context.state) // state      context.commit(&quot;increment&quot;)    &#125;,    changeNameAction(context, payload) &#123;      context.commit(&quot;changeName&quot;, payload)    &#125;,    // fetchHomeMultidataAction(context) &#123;    //   // 1.返回Promise, 给Promise设置then    //   // fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;    //   //   res.json().then(data =&gt; &#123;    //   //     console.log(data)    //   //   &#125;)    //   // &#125;)          //   // 2.Promise链式调用    //   // fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;    //   //   return res.json()    //   // &#125;).then(data =&gt; &#123;    //   //   console.log(data)    //   // &#125;)    //   return new Promise(async (resolve, reject) =&gt; &#123;    //     // 3.await/async    //     const res = await fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;)    //     const data = await res.json()            //     // 修改state数据    //     context.commit(&quot;changeBanners&quot;, data.data.banner.list)    //     context.commit(&quot;changeRecommends&quot;, data.data.recommend.list)    //     resolve(&quot;aaaaa&quot;)    //   &#125;)    // &#125;  &#125;,  modules: &#123;    home: homeModule,    counter: counterModule  &#125;&#125;)export default store\n\n//main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &#x27;./store&#x27;createApp(App).use(store).mount(&#x27;#app&#x27;)\n\nStatestate中主要是管理全局的状态，所有状态都存储在state中\n//state要放到computed中去使用export default &#123;   computed: &#123;     storeCounter() &#123;       return this.$store.state.counter     &#125;   &#125; &#125;\n\n//在setup中使用state 需要使用useStore&lt;script setup&gt;  import &#123; toRefs &#125; from &#x27;vue&#x27;  import &#123; useStore &#125; from &#x27;vuex&#x27;  const store = useStore()  // 如果对store.state进行解构或者赋值给另外一个变量，会变成非响应式的，要使用toRefs  const &#123; counter &#125; = toRefs(store.state)    function increment() &#123;    // store.state.counter++    store.commit(&quot;increment&quot;)  &#125;&lt;/script&gt;\n\nmapState 辅助函数mapState 辅助函数帮助我们生成计算属性\n/ 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from &#x27;vuex&#x27;export default &#123;  // ...  computed: mapState(&#123;    // 箭头函数可使代码更简练    count: state =&gt; state.count,    // 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`    countAlias: &#x27;count&#x27;,    // 为了能够使用 `this` 获取局部状态，必须使用常规函数    countPlusLocalState (state) &#123;      return state.count + this.localCount    &#125;  &#125;)&#125;\n\ncomputed: mapState([  // 映射 this.count 为 store.state.count  &#x27;count&#x27;])//还可以传递数组\n\ncomputed: &#123;  localComputed () &#123; /* ... */ &#125;,  // 使用对象展开运算符将此对象混入到外部对象中  ...mapState(&#123;    // ...  &#125;)&#125;\n\n&#x2F;&#x2F;使用展开运算符和其他computed合并\ncomputed: &#123;     fullname() &#123;       return &quot;xxx&quot;     &#125;,     // name() &#123;     //   return this.$store.state.name     // &#125;,     ...mapState([&quot;name&quot;, &quot;level&quot;, &quot;avatarURL&quot;]),     ...mapState(&#123;       sName: state =&gt; state.name,       sLevel: state =&gt; state.level     &#125;)   &#125; &#125;\n\nGettergetter类似于vue的computed\nGetter 接受 state 作为其第一个参数\nconst store = createStore(&#123;  state: &#123;    todos: [      &#123; id: 1, text: &#x27;...&#x27;, done: true &#125;,      &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;    ]  &#125;,  getters: &#123;    doneTodos (state) &#123;      return state.todos.filter(todo =&gt; todo.done)    &#125;  &#125;&#125;)\n\n通过属性访问Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值：\nstore.getters.doneTodos // -&gt; [&#123; id: 1, text: &#x27;...&#x27;, done: true &#125;]\n\nGetter 也可以接受其他 getter 作为第二个参数：\ngetters: &#123;  // ...  doneTodosCount (state, getters) &#123;    return getters.doneTodos.length  &#125;&#125;store.getters.doneTodosCount // -&gt; 1\n\n我们可以很容易地在任何组件中使用它：\ncomputed: &#123;  doneTodosCount () &#123;    return this.$store.getters.doneTodosCount  &#125;&#125;\n\n注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。\n通过方法访问你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。\ngetters: &#123;  // ...  getTodoById: (state) =&gt; (id) =&gt; &#123;    return state.todos.find(todo =&gt; todo.id === id)  &#125;&#125;store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;\n\n注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果\nmapGetters 辅助函数import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123;  // ...  computed: &#123;  // 使用对象展开运算符将 getter 混入 computed 对象中    ...mapGetters([      &#x27;doneTodosCount&#x27;,      &#x27;anotherGetter&#x27;,      // ...    ])  &#125;&#125;\n\n...mapGetters(&#123;  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`  doneCount: &#x27;doneTodosCount&#x27;&#125;)//还可以取别名\n\n在setup中使用&lt;script setup&gt;  import &#123; computed, toRefs &#125; from &#x27;vue&#x27;;  import &#123; mapGetters, useStore &#125; from &#x27;vuex&#x27;  const store = useStore()  // 1.使用mapGetters  // const &#123; message: messageFn &#125; = mapGetters([&quot;message&quot;])  // const message = computed(messageFn.bind(&#123; $store: store &#125;))  // 2.直接解构, 并且包裹成ref  // const &#123; message &#125; = toRefs(store.getters)  // 3.针对某一个getters属性使用computed  const message = computed(() =&gt; store.getters.message)  function changeAge() &#123;    store.state.name = &quot;kobe&quot;  &#125;&lt;/script&gt;\n\nMutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation\nmutation的使用\nimport &#123; CHANGE_INFO &#125; from &quot;@/store/mutation_types&quot; export default &#123;   computed: &#123;   &#125;,   methods: &#123;     changeName() &#123;       // this.$store.state.name = &quot;李银河&quot;       //传参方式       this.$store.commit(&quot;changeName&quot;, &quot;王小波&quot;)     &#125;,     incrementLevel() &#123;       this.$store.commit(&quot;incrementLevel&quot;)     &#125;,     changeInfo() &#123;        //这是定义常量的方式       this.$store.commit(CHANGE_INFO, &#123;         name: &quot;王二&quot;,         level: 200       &#125;)     &#125;   &#125; &#125;\n\n//在mutation中commitconst store = createStore(&#123;  state: () =&gt; (&#123;    name: &quot;张三&quot;,  &#125;),  mutations: &#123;    updateMut(state, playload) &#123;      state.name = playload;    &#125;,    updateMut2(state, playload) &#123;      store.commit(&quot;updateMut&quot;, playload);    &#125;,  &#125;,&#125;);\n\nMutation 必须是同步函数mutations: &#123;  someMutation (state) &#123;    api.callAsyncMethod(() =&gt; &#123;      state.count++    &#125;)  &#125;&#125;\n\n我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。\nmapMutationsmethods: &#123;      btnClick() &#123;        console.log(&quot;btnClick&quot;)      &#125;,      // ...mapMutations([&quot;changeName&quot;, &quot;incrementLevel&quot;, CHANGE_INFO])  使用常量，在template中要使用正确的函数名    &#125;\n\nActionAction 类似于 mutation，不同在于：\n\nAction 提交的是 mutation，而不是直接变更状态。\nAction 可以包含任意异步操作。\n\nAction 通过 store.dispatch 方法触发：\nstore.dispatch(&#x27;increment&#x27;)\n\n//在action中也可以分发actionactions: &#123;  async actionA (&#123; commit &#125;) &#123;    commit(&#x27;gotData&#x27;, await getData())  &#125;,  async actionB (&#123; dispatch, commit &#125;) &#123;    await dispatch(&#x27;actionA&#x27;) // 等待 actionA 完成    commit(&#x27;gotOtherData&#x27;, await getOtherData())  &#125;&#125;\n\n//在组件中使用methods: &#123;     // counterBtnClick() &#123;     //   this.$store.dispatch(&quot;incrementAction&quot;)     // &#125;,     // nameBtnClick() &#123;     //   this.$store.dispatch(&quot;changeNameAction&quot;, &quot;aaa&quot;)     // &#125;     // ...mapActions([&quot;incrementAction&quot;, &quot;changeNameAction&quot;])   &#125;\n\nModules的使用由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割\nconst moduleA = &#123;  state: () =&gt; (&#123; ... &#125;),  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123; ... &#125;&#125;const moduleB = &#123;  state: () =&gt; (&#123; ... &#125;),  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = createStore(&#123;  modules: &#123;    a: moduleA,    b: moduleB  &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态\n\n当没有添加namaspaced默认情况下使用module的值\n&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;h2&gt;Home Page&lt;/h2&gt;    &lt;!-- 1.使用state时, 是需要state.moduleName.xxx --&gt;    &lt;h2&gt;Counter模块的counter: &#123;&#123; $store.state.counter.count &#125;&#125;&lt;/h2&gt;    &lt;!-- 2.使用getters时, 是直接getters.xxx --&gt;    &lt;h2&gt;Counter模块的doubleCounter: &#123;&#123; $store.getters.doubleCount &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;incrementCount&quot;&gt;count模块+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;script setup&gt;  import &#123; useStore &#125; from &#x27;vuex&#x27;  // 告诉Vuex发起网络请求  const store = useStore()  // 派发事件时, 默认也是不需要跟模块名称  // 提交mutation时, 默认也是不需要跟模块名称  function incrementCount() &#123;    store.dispatch(&quot;incrementCountAction&quot;)  &#125;&lt;/script&gt;\n\n对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：\nconst moduleA = &#123;  // ...  actions: &#123;    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;      if ((state.count + rootState.count) % 2 === 1) &#123;        commit(&#x27;increment&#x27;)      &#125;    &#125;  &#125;&#125;\n\n对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\nconst moduleA = &#123;  // ...  getters: &#123;    sumWithRootCount (state, getters, rootState) &#123;      return state.count + rootState.count    &#125;  &#125;&#125;\n\n命名空间默认情况下，模块内部的 action 和 mutation 仍然是注册在全局命名空间的——这样使得多个模块能够对同一个 action 或 mutation 作出响应。Getter 同样也默认注册在全局命名空间，但是目前这并非出于功能上的目的（仅仅是维持现状来避免非兼容性变更）。必须注意，不要在不同的、无命名空间的模块中定义两个相同的 getter 从而导致错误。\n如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：\nconst store = createStore(&#123;  modules: &#123;    account: &#123;      namespaced: true,      // 模块内容（module assets）      state: () =&gt; (&#123; ... &#125;), // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响      getters: &#123;        isAdmin () &#123; ... &#125; // -&gt; getters[&#x27;account/isAdmin&#x27;]      &#125;,      actions: &#123;        login () &#123; ... &#125; // -&gt; dispatch(&#x27;account/login&#x27;)      &#125;,      mutations: &#123;        login () &#123; ... &#125; // -&gt; commit(&#x27;account/login&#x27;)      &#125;,      // 嵌套模块      modules: &#123;        // 继承父模块的命名空间        myPage: &#123;          state: () =&gt; (&#123; ... &#125;),          getters: &#123;            profile () &#123; ... &#125; // -&gt; getters[&#x27;account/profile&#x27;]          &#125;        &#125;,        // 进一步嵌套命名空间        posts: &#123;          namespaced: true,          state: () =&gt; (&#123; ... &#125;),          getters: &#123;            popular () &#123; ... &#125; // -&gt; getters[&#x27;account/posts/popular&#x27;]          &#125;        &#125;      &#125;    &#125;  &#125;&#125;)\n\n//在组件中的写法&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;h2&gt;Home Page&lt;/h2&gt;    &lt;!-- 1.使用state时, 是需要state.moduleName.xxx --&gt;    &lt;h2&gt;Counter模块的counter: &#123;&#123; $store.state.counter.count &#125;&#125;&lt;/h2&gt;    &lt;!-- 2.使用getters时, 是直接getters.xxx --&gt;    &lt;h2&gt;Counter模块的doubleCounter: &#123;&#123; $store.getters[&quot;counter/doubleCount&quot;] &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;incrementCount&quot;&gt;count模块+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;script setup&gt;  import &#123; useStore &#125; from &#x27;vuex&#x27;  // 告诉Vuex发起网络请求  const store = useStore()  // 派发事件时, 默认也是不需要跟模块名称  // 提交mutation时, 默认也是不需要跟模块名称  function incrementCount() &#123;    store.dispatch(&quot;counter/incrementCountAction&quot;)//有命名空间的写法  &#125;&lt;/script&gt;\n\n启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。\n在带命名空间的模块内访问全局内容如果你希望使用全局 state 和 getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。\nmodules: &#123;  foo: &#123;    namespaced: true,    getters: &#123;      // 在这个模块的 getter 中，`getters` 被局部化了      // 你可以使用 getter 的第四个参数来调用 `rootGetters`      someGetter (state, getters, rootState, rootGetters) &#123;        getters.someOtherGetter // -&gt; &#x27;foo/someOtherGetter&#x27;        rootGetters.someOtherGetter // -&gt; &#x27;someOtherGetter&#x27;        rootGetters[&#x27;bar/someOtherGetter&#x27;] // -&gt; &#x27;bar/someOtherGetter&#x27;      &#125;,      someOtherGetter: state =&gt; &#123; ... &#125;    &#125;,    actions: &#123;      // 在这个模块中， dispatch 和 commit 也被局部化了      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;        getters.someGetter // -&gt; &#x27;foo/someGetter&#x27;        rootGetters.someGetter // -&gt; &#x27;someGetter&#x27;        rootGetters[&#x27;bar/someGetter&#x27;] // -&gt; &#x27;bar/someGetter&#x27;        dispatch(&#x27;someOtherAction&#x27;) // -&gt; &#x27;foo/someOtherAction&#x27;        dispatch(&#x27;someOtherAction&#x27;, null, &#123; root: true &#125;) // -&gt; &#x27;someOtherAction&#x27;        commit(&#x27;someMutation&#x27;) // -&gt; &#x27;foo/someMutation&#x27;        commit(&#x27;someMutation&#x27;, null, &#123; root: true &#125;) // -&gt; &#x27;someMutation&#x27;      &#125;,      someOtherAction (ctx, payload) &#123; ... &#125;    &#125;  &#125;&#125;\n","categories":["vue","note"]},{"title":"webpack5学习","url":"/2022/09/08/webpack5%E5%AD%A6%E4%B9%A0/","content":"//path.jsconst path = require(&#x27;path&#x27;);const appDir = process.cwd();console.log(`Current directory: $&#123;appDir&#125;`);const resolveApp = (relativePath) =&gt; path.resolve(appDir, relativePath);module.exports = resolveApp;\n\n//webpack.common.jsconst resolveApp = require(&#x27;./paths&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const &#123; DefinePlugin &#125; = require(&#x27;webpack&#x27;);const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;);const ESLintPlugin = require(&#x27;eslint-webpack-plugin&#x27;);const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;);const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;);const productionConfig = require(&#x27;./webpack.prod&#x27;);const developmentConfig = require(&#x27;./webpack.dev&#x27;);/*** * 这里有三种方法来进行代码分离，它可以减少打包文件大小，减少文件的加载时间 *  它主要的目的是将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件；    比如默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度    代码分离可以分出出更小的bundle，以及控制资源加载优先级，提供代码的加载性能      1.入口起点：使用entry配置手动分离代码；      2.防止重复：使用Entry Dependencies或者SplitChunksPlugin去重和分离代码；      3.动态导入：通过模块的内联函数调用来分离代码 */const commonConfig = (env, args) =&gt; &#123;  const devMode = args.mode !== &#x27;production&#x27;;  return &#123;    entry: [&#x27;./src/index.js&#x27;],    // 多入口文件 如果两个文件引用相同的代码会造成重复打包，增大单个bundle的大小，从而浪费带宽    // entry: &#123;    //   index: &#x27;./src/index.js&#x27;,    //   another: &#x27;./src/another-module.js&#x27;    // &#125;,    //将公共的包分离出来，减小bundle体积    // entry: &#123;    //   index: &#123;    //     import: &#x27;./src/index.js&#x27;,    //     dependOn: &#x27;shared&#x27;    //   &#125;,    //   another: &#123;    //     import: &#x27;./src/another-module.js&#x27;,    //     dependOn: &#x27;shared&#x27;    //   &#125;,    //   shared: &#x27;lodash&#x27;    // &#125;,    output: &#123;      filename: &#x27;js/[name].bundle.js&#x27;,      // 为import().then异步加载使用      chunkFilename: &#x27;js/[name].[hash:6].chunk.js&#x27;,      // 必须是一个绝对路径      path: resolveApp(&#x27;./dist&#x27;),      // 重新打包时清理dist文件夹      clean: true      // 使用webpack-dev-middleware需要 目的是让文件在服务器中也可以使用,找到对应的文件,要在生产环境放到服务器中才加      // output中的path的作用是告知webpack之后的输出目录      // publicPath: &quot;/&quot;,      // Asset Modules 将这个模块下的文件输出到dist下的指定文件夹      // assetModuleFilename: &quot;img/[name].[hash:6][ext]&quot;    &#125;,    // /如果我们要在单个 HTML 页面上使用多个入口点，还需要 optimization.runtimeChunk: &#x27;single&#x27;    // optimization: &#123;    //   runtimeChunk: &#x27;single&#x27;    // &#125;,    optimization: &#123;      // optimization.chunkIds配置用于告知webpack模块的id采用什么算法生成      // natural: 使用自然数(不推荐),      // named: 使用包所在目录作为name(在开发环境推荐)      // deterministic: 生成id, 针对相同文件生成的id是不变      // chunkIds: devMode ? &#x27;deterministic&#x27; : &#x27;named&#x27;,      // 方式二使用splitChunkPlugin默认集成      splitChunks: &#123;        /**         * async 默认 针对异步导入         * initial 针对同步导入         * all 针对同步和异步         */        chunks: &#x27;all&#x27;,        // 最小尺寸: 如果拆分出来一个, 那么拆分出来的这个包的大小最小为minSize        minSize: 20000,        // 将大于maxSize的包, 拆分成不小于minSize的包        maxSize: 20000,        // 表示至少被引入一次的包才会被分包，没有引用过的不会被打包        minChunks: 1,        /**         * cacheGroups： 用于对拆分的包就行分组，比如一个lodash在拆分之后，并不会立即打包，而是会等到有没有其他符合规则的包一起来打包； test属性：匹配符合规则的包； name属性：拆分包的name属性； filename属性：拆分包的名称，可以自己使用placeholder属性         */        cacheGroups: &#123;          vendor: &#123;            test: /[\\\\/]node_modules[\\\\/]/,            filename: &#x27;js/[id]_venders.js&#x27;,            priority: -10          &#125;,          default: &#123;            minChunks: 2,            filename: &#x27;js/common_[id].js&#x27;,            priority: -20          &#125;        &#125;      &#125;,      /**optimization. runtimeChunk配置       * 配置runtime相关的代码是否抽取到一个单独的chunk中：       * runtime相关的代码指的是在运行环境中，对模块进行解析、加载、模块信息相关的代码；       * 抽离出来后，有利于浏览器缓存的策略：       * 比如我们修改了业务代码（main），那么runtime和component、bar的chunk是不需要重新加载的       * 比如我们修改了component、bar的代码，那么main中的代码是不需要重新加载的       *   true/multiple ：针对每个入口打包一个runtime文件；             single 打包一个runtime文件             object: name name属性决定runtimeChunk的名称；       */      runtimeChunk: &#123;        name: function (entrypoint) &#123;          return `other-$&#123;entrypoint.name&#125;`;        &#125;      &#125;    &#125;,    module: &#123;      rules: [        &#123;          test: /\\.ts$/,          exclude: /node_modules/,          // 本质上是依赖于typescript(typescript compiler)          use: &#x27;babel-loader&#x27;        &#125;,        &#123; test: /\\.jsx$/i, exclude: /node_modules/, use: &#x27;babel-loader&#x27; &#125;,        &#123;          test: /\\.m?js$/i,          exclude: /node_modules/,          // 将es6=》es5          use: &#123;            loader: &#x27;babel-loader&#x27;          &#125;        &#125;,        &#123;          test: /\\.css$/i,          use: [            devMode ? &#x27;style-loader&#x27; : MiniCssExtractPlugin.loader,            &#123;              loader: &#x27;css-loader&#x27;,              options: &#123;                // 允许在使用css-loader之前加载多少个模块 postcss-loader                importLoaders: 1              &#125;            &#125;,            &#x27;postcss-loader&#x27;          ]        &#125;,        &#123;          test: /\\.less$/i,          use: [            devMode ? &#x27;style-loader&#x27; : MiniCssExtractPlugin.loader,            &#123;              loader: &#x27;css-loader&#x27;,              options: &#123;                // 0 =&gt; no loaders (default);                // 1 =&gt; postcss-loader;                // 2 =&gt; postcss-loader, less-loader                importLoaders: 2              &#125;            &#125;,            &#x27;postcss-loader&#x27;,            &#x27;less-loader&#x27;          ]        &#125;,        /**         * 资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：         * 1.asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现         * 2.asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现         * 3.asset/source 导出资源的源代码。之前通过使用 raw-loader 实现         * 4.asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源  体积限制实现         */        &#123;          test: /\\.(png|jpeg|svg|gif|jpg)$/,          type: &#x27;asset&#x27;,          generator: &#123;            filename: &#x27;img/[name].[hash:6].[ext]&#x27;          &#125;,          parser: &#123;            dataUrlCondition: &#123;              maxSize: 100 * 1024            &#125;          &#125;        &#125;,        &#123;          test: /\\.(woff|woff2|eot|ttf|otf)$/i,          type: &#x27;asset/resource&#x27;,          generator: &#123;            filename: &#x27;font/[name].[hash:6].[ext]&#x27;          &#125;        &#125;,        &#123;          test: /\\.(csv|tsv)$/,          use: [&#x27;csv-loader&#x27;]        &#125;,        &#123;          test: /\\.xml$/,          use: [&#x27;xml-loader&#x27;]        &#125;      ]    &#125;,    resolve: &#123;      extensions: [&#x27;.wasm&#x27;, &#x27;.mjs&#x27;, &#x27;.js&#x27;, &#x27;.json&#x27;, &#x27;.jsx&#x27;, &#x27;.ts&#x27;, &#x27;.vue&#x27;],      alias: &#123;        &#x27;@&#x27;: resolveApp(&#x27;./src&#x27;)      &#125;    &#125;,    plugins: [      new ESLintPlugin(),      new HtmlWebpackPlugin(&#123;        title: &#x27;developement&#x27;,        // html模板        template: &#x27;./src/asset/index.html&#x27;      &#125;),      // 定义全局常量      new DefinePlugin(&#123;        BASE_URL: &#x27;&quot;./&quot;&#x27;      &#125;),      // 复制文件到dist文件夹      new CopyWebpackPlugin(&#123;        patterns: [          &#123;            from: &#x27;src/asset&#x27;,            globOptions: &#123;              ignore: [&#x27;**/index.html&#x27;, &#x27;**/.DS_Store&#x27;]            &#125;          &#125;        ]      &#125;)    ]  &#125;;&#125;;module.exports = (env, args) =&gt; &#123;  switch (args.mode) &#123;    case &#x27;development&#x27;:      return merge(commonConfig(env, args), developmentConfig);    case &#x27;production&#x27;:      return merge(commonConfig(env, args), productionConfig);    default:      throw new Error(&#x27;No matching configuration was fou)nd!&#x27;);  &#125;&#125;;\n\n//webpack.dev.jsconst &#123; HotModuleReplacementPlugin &#125; = require(&#x27;webpack&#x27;);module.exports = &#123;  entry: [&#x27;webpack-hot-middleware/client?noInfo=false&amp;reload=true&#x27;],  mode: &#x27;development&#x27;,  // 在开发环境中使用  devtool: &#x27;source-map&#x27;,  // --watch 需要手动刷新页面不方便  // 开启本地服务器  // 官方其实有提到，建议 devServer.publicPath 与 output.publicPath相同  devServer: &#123;    static: &#x27;./dist&#x27;,    /**     *  hot: &#x27;only&#x27;：表示热模块替换，编译失败后不会刷新整个页面     */    hot: true,    compress: true, //开启gzip压缩    port: &#x27;auto&#x27;, //修改本地服务器端口号, auto由服务器自动分配一个端口号    /**     * historyApiFallback是开发中一个非常常见的属性，它主要的作用是解决SPA页面在路由跳转之后，进行页面刷新时，返回404的错误    如果设置为true，那么在刷新时，返回404错误时，会自动返回 index.html 的内容     */    historyApiFallback: true,    //  设置主机地址    // host: &#x27;0.0.0.0&#x27;,    // 是否自动打开浏览器    // open: true,    /**     * 设置开发代理     */    proxy: &#123;      &#x27;/api&#x27;: &#123;        target: &#x27;http://localhost:3000/api&#x27;,        pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;,        changeOrigin: true      &#125;    &#125;  &#125;,  plugins: [    // 使用webpack-hot-middleware替代webpack-dev-middleware开启热更新，因为webpack-dev-middleware不能够热更新    new HotModuleReplacementPlugin()  ]&#125;;\n\n//webpack.prod.jsconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;);const CssMinimizerPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;);// const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;);module.exports = &#123;  mode: &#x27;production&#x27;,  devtool: &#x27;source-map&#x27;,  /**   * 生产环境中使用CDN，不需要下载包，排除这些库   */  externals: &#123;    // window._    lodash: &#x27;_&#x27;,    // window.dayjs    dayjs: &#x27;dayjs&#x27;  &#125;,  // optimization: &#123;  //   //  生产环境中有tree shaking  //   minimize: false,  //   minimizer: [  //     // 对js代码进行压缩相关的操作，开发环境不需要压缩，减少打包时间  //     new TerserPlugin(&#123;  //       parallel: true,  //       extractComments: false,  //       terserOptions: &#123;  //         compress: &#123;  //           arguments: false,  //           dead_code: true  //         &#125;,  //         mangle: true,  //         toplevel: true,  //         keep_classnames: true,  //         keep_fnames: true  //       &#125;  //     &#125;)  //   ]  // &#125;,  plugins: [    /**     * 该插件将 CSS 提取到单独的文件中。它为每个包含 CSS 的 JS 文件创建一个 CSS 文件。它支持 CSS 和 SourceMaps 的按需加载。它建立在新的 webpack v5 功能之上，需要 webpack 5 才能工作。     * 异步加载无重复编译（性能）更容易使用特定于 CSS     */    new MiniCssExtractPlugin(&#123;      filename: &#x27;css/[name].[contenthash:8].css&#x27;,      chunkFilename: &#x27;css/[name].[contenthash:8].css&#x27;    &#125;),    // 对css进行压缩 这样写可以只在production中使用    new CssMinimizerPlugin()  ]&#125;;/** * Hash、ContentHash、ChunkHash *///  在我们给打包的文件进行命名的时候，会使用placeholder，placeholder中有几个属性比较相似：// p hash、chunkhash、contenthash// p hash本身是通过MD4的散列函数处理后，生成一个128位的hash值（32个十六进制）；// n hash值的生成和整个项目有关系：// p 比如我们现在有两个入口index.js和main.js；// p 它们分别会输出到不同的bundle文件中，并且在文件名称中我们有使用hash；// p 这个时候，如果修改了index.js文件中的内容，那么hash会发生变化；// p 那就意味着两个文件的名称都会发生变化；// n chunkhash可以有效的解决上面的问题，它会根据不同的入口进行借来解析来生成hash值：// p 比如我们修改了index.js，那么main.js的chunkhash是不会发生改变的；// n contenthash表示生成的文件hash名称，只和内容有关系：// p 比如我们的index.js，引入了一个style.css，style.css有被抽取到一个独立的css文件中；// p 这个css文件在命名时，如果我们使用的是chunkhash；// p 那么当index.js文件的内容发生变化时，css文件的命名也会发生变化；// p 这个时候我们可以使用contenthash\n\n//server.jsconst express = require(&#x27;express&#x27;);const webpack = require(&#x27;webpack&#x27;);const webpackDevMiddleware = require(&#x27;webpack-dev-middleware&#x27;);const app = express();const config = require(&#x27;./config/webpack.common&#x27;)(&#123;&#125;, &#123; mode: &#x27;development&#x27; &#125;);const compiler = webpack(config);// Tell express to use the webpack-dev-middleware and use the webpack.config.js// configuration file as a base.app.use(  webpackDevMiddleware(compiler, &#123;    publicPath: config.output.publicPath  &#125;));// webpack-hot-middleware可以开启热更新app.use(require(&#x27;webpack-hot-middleware&#x27;)(compiler));// Serve the files on port 3000.app.listen(4000, function () &#123;  console.log(&#x27;Example app listening on port 4000!\\n&#x27;);&#125;);\n\n//package,son&quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,    &quot;build&quot;: &quot;webpack --config ./config/webpack.common.js  --mode production --env production&quot;,    &quot;start&quot;: &quot;webpack serve --open  --config ./config/webpack.common.js  --mode development --env development&quot;,    &quot;watch&quot;: &quot;webpack --config ./config/webpack.common.js --watch  --mode development --env development&quot;,    &quot;serve&quot;: &quot;node server.js&quot;,    &quot;type-check&quot;: &quot;tsc --noEmit&quot;,    &quot;type-check-watch&quot;: &quot;tsc --noEmit --watch&quot;,    &quot;prettier&quot;: &quot;prettier --write .&quot;  &#125;,\n\n","categories":["常用构建工具","webpack"]},{"title":"什么是tailwindcss","url":"/2022/09/08/%E4%BB%80%E4%B9%88%E6%98%AFtailwindcss/","content":"","categories":["CSS","note"]},{"title":"什么是websocket","url":"/2022/09/24/%E4%BB%80%E4%B9%88%E6%98%AFwebsocket/","content":"webSocket是一种网络传输协议，可以在单个TCP连接上进行全双工通信，位于OSI模型的应用层，webSocket协议在2011年由IETF标准化为RFC6455,由RFC7936补充规范，WEB IDL中的webSocket api由W3C标准化，websocket是一种和http不同的协议，但是都是属于OSI模型的应用层，可以通过HTTP的80端口和443端口进行通信，支持HTTP代理和中介，和http协议兼容，为了实现兼容性，webSocket进行握手使用HTTP Upgrade头从http协议改成webSocket协议，websocket支持浏览器和服务器进行双向通信，可以进行实时通信，不需要客户端发起请求，目前大部分浏览器都支持websocket,和HTTP不同，websocket支持全双工通信，websocket还可以TCP之上实现消息流\nwebsocket协议有两种标识符分别是ws和wss，分别是明文传输和加密传输。websocket不支持#，除了这些，其他都和http相同\nws://example.com/wsapiwss://secure.example.com/wsapi\n\nwebsocket的优点\n比较少的控制开销，在服务器和客户端通信的时候，用于协议控制的数据包头部相对较小，在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2到10字节，对于客户端到服务器的内容，此头部还需要加额外的4字节的掩码，相对于http每次都要携带完整的头部，明显减少了开销\n\n更强的实时性，由于协议是全双工的，所以服务器可以随时主动的给客户端发送数据，相对于HTTP请求需要客户端发送请求并且等待服务器响应，减少了等待时间，即使和Comet等类似的长轮询比较，它也可以在短时间传递更多的数据\n\n保持连接状态，与HTTP不同的是，webSocket需要先建立连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息，而http每次请求可能需要携带验证信息\n\n更好的二进制支持，webSocket定义了二进制帧，他会比HTTP更i轻松的处理二进制文件\n\n更好的压缩效果，相对于HTTP压缩，websocket在适当的扩展的支持下，可以沿用之前的内容的上下文，在传递类似的数据的时候可以显著的提高压缩率\n\n\nwebSocket是独立的，建立在TCP上的协议，websocket通过HTTP&#x2F;1.1的101状态吗继续握手，为了建立Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（Handshaking）\n例子客户端请求：\nGET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: http://example.comSec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13\n\n服务器的回应\nHTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat\n\n\nConnection必须设置Upgrade，表示客户端希望连接升级。\nUpgrade字段必须设置Websocket，表示希望升级到Websocket协议。\nSec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行Base64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。\nSec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。\nOrigin字段是必须的。如果缺少origin字段，WebSocket服务器需要回复HTTP 403 状态码（禁止访问）。[16]\n其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用。\n\nwebsocket的基本使用客户端var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function(evt) &#123;   console.log(&quot;Connection open ...&quot;);   ws.send(&quot;Hello WebSockets!&quot;);&#125;;ws.onmessage = function(evt) &#123;  console.log( &quot;Received Message: &quot; + evt.data);  ws.close();&#125;;ws.onclose = function(evt) &#123;  console.log(&quot;Connection closed.&quot;);&#125;;      \n\n\nvar ws = new WebSocket(&#x27;ws://localhost:8080&#x27;);\n\nwenSocket作为构造函数，用于新建WebSocket实例，执行完上面的例子之后，客户端就会和服务器进行连接\nwebSocket.readyStatereadyState属性是返回当前状态，共有四种状态\n\nCONNECTING：值为0，表示正在连接。\nOPEN：值为1，表示连接成功，可以通信了。\nCLOSING：值为2，表示连接正在关闭。\nCLOSED：值为3，表示连接已经关闭，或者打开连接失败。\n\nswitch (ws.readyState) &#123;  case WebSocket.CONNECTING:    // do something    break;  case WebSocket.OPEN:    // do something    break;  case WebSocket.CLOSING:    // do something    break;  case WebSocket.CLOSED:    // do something    break;  default:    // this never happens    break;&#125;\n\nopen属性监听连接之后的回调函数ws.onopen = function () &#123;  ws.send(&#x27;Hello Server!&#x27;);&#125;//执行多个回调函数可以使用addEventListenerws.addEventListener(&#x27;open&#x27;, function (event) &#123;  ws.send(&#x27;Hello Server!&#x27;);&#125;);\n\n实例对象的onclose属性，用于指定连接关闭后的回调函数ws.onclose = function(event) &#123;  var code = event.code;  var reason = event.reason;  var wasClean = event.wasClean;  // handle close event&#125;;ws.addEventListener(&quot;close&quot;, function(event) &#123;  var code = event.code;  var reason = event.reason;  var wasClean = event.wasClean;  // handle close event&#125;);\n\n实例对象的onmessage属性，用于指定收到服务器数据后的回调函数\nws.onmessage = function(event) &#123;  var data = event.data;  // 处理数据&#125;;ws.addEventListener(&quot;message&quot;, function(event) &#123;  var data = event.data;  // 处理数据&#125;);\n\n注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象\nws.onmessage = function(event)&#123;  if(typeof event.data === String) &#123;    console.log(&quot;Received data string&quot;);  &#125;  if(event.data instanceof ArrayBuffer)&#123;    var buffer = event.data;    console.log(&quot;Received arraybuffer&quot;);  &#125;&#125;\n\n除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。\n\n// 收到的是 blob 数据ws.binaryType = &quot;blob&quot;;ws.onmessage = function(e) &#123;  console.log(e.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = &quot;arraybuffer&quot;;ws.onmessage = function(e) &#123;  console.log(e.data.byteLength);&#125;;\n\n实例对象的send()方法用于向服务器发送数据。\n\nws.send(&#x27;your message&#x27;);\n\n发送blob对象的例子\nvar file = document  .querySelector(&#x27;input[type=&quot;file&quot;]&#x27;)  .files[0];ws.send(file);\n\n发送ArrayBuffer对象的例子\n// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123;  binary[i] = img.data[i];&#125;ws.send(binary.buffer);\n\n实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束\nvar data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123;  // 发送完毕&#125; else &#123;  // 发送还没结束&#125;\n\n实例对象的onerror属性，用于指定报错时的回调函数。\n\nsocket.onerror = function(event) &#123;  // handle error event&#125;;socket.addEventListener(&quot;error&quot;, function(event) &#123;  // handle error event&#125;)\n\n服务端的实现如果用node实现websocket\n\nµWebSockets\nSocket.IO\nWebSocket-Node\n\n","categories":["计算机网络","websocket"]},{"title":"使用axios封装请求工具","url":"/2022/09/09/%E4%BD%BF%E7%94%A8axios%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82%E5%B7%A5%E5%85%B7/","content":"//request.jsimport axios from &quot;axios&quot;;import type &#123; AxiosInstance &#125; from &quot;axios&quot;;import &#123; RequestInterceptors, RequestConfig &#125; from &quot;./type&quot;;import &#123; ElLoading &#125; from &quot;element-plus&quot;;const DEFAULT_LOADING = true;class axiosRequest &#123;  instance: AxiosInstance;  interceptors?: RequestInterceptors;  showLoading: boolean;  loading?: any;  constructor(config: RequestConfig) &#123;    this.instance = axios.create(config);    this.showLoading = config.showLoading ?? DEFAULT_LOADING;    this.interceptors = config.interceptors;    // 将config中的拦截器传入    this.instance.interceptors.request.use(      this.interceptors?.requestInterceptor,      this.interceptors?.requestInterceptorCatch,    );    this.instance.interceptors.response.use(      this.interceptors?.responseInterceptor,      this.interceptors?.responseInterceptorCatch,    );    // 设置通用的拦截器    this.instance.interceptors.request.use(      (config) =&gt; &#123;        if (this.showLoading) &#123;          this.loading = ElLoading.service(&#123;            lock: true,            text: &quot;正在请求数据。。。。。&quot;,            background: &quot;rgba(0, 0, 0, 0.5)&quot;,          &#125;);        &#125;        return config;      &#125;,      (err) =&gt; &#123;        return err;      &#125;,    );    this.instance.interceptors.response.use(      (res) =&gt; &#123;        this.loading?.close();        const data = res.data;        if (data.returnCode == &quot;-1001&quot;) &#123;          console.log(&quot;请求失败————————————————————————————&quot;);        &#125; else &#123;          return data;        &#125;      &#125;,      (err) =&gt; &#123;        this.loading?.close();        if (err.response.status === &quot;404&quot;) &#123;          console.log(&quot;页面不存在&quot;);        &#125;        return err;      &#125;,    );  &#125;  request&lt;T = any&gt;(config: RequestConfig&lt;T&gt;): Promise&lt;T&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;      if (config.interceptors?.requestInterceptor) &#123;        config = config.interceptors.requestInterceptor(config);      &#125;      if (config.showLoading === false) &#123;        this.showLoading = config.showLoading;      &#125;      this.instance        .request&lt;any, T&gt;(config)        .then((res) =&gt; &#123;          if (config.interceptors?.responseInterceptor) &#123;            res = config.interceptors.responseInterceptor(res);          &#125;          this.showLoading = DEFAULT_LOADING;          resolve(res);        &#125;)        .catch((err) =&gt; &#123;          this.showLoading = DEFAULT_LOADING;          reject(err);          return err;        &#125;);    &#125;);  &#125;  get&lt;T = any&gt;(config: RequestConfig&lt;T&gt;): Promise&lt;T&gt; &#123;    return this.request&lt;T&gt;(&#123; ...config, method: &quot;GET&quot; &#125;);  &#125;  post&lt;T = any&gt;(config: RequestConfig&lt;T&gt;): Promise&lt;T&gt; &#123;    return this.request&lt;T&gt;(&#123; ...config, method: &quot;POST&quot; &#125;);  &#125;  delete&lt;T = any&gt;(config: RequestConfig&lt;T&gt;): Promise&lt;T&gt; &#123;    return this.request&lt;T&gt;(&#123; ...config, method: &quot;DELETE&quot; &#125;);  &#125;  patch&lt;T = any&gt;(config: RequestConfig&lt;T&gt;): Promise&lt;T&gt; &#123;    return this.request&lt;T&gt;(&#123; ...config, method: &quot;PATCH&quot; &#125;);  &#125;&#125;export default axiosRequest;\n\n//type.jsimport type &#123; AxiosRequestConfig, AxiosResponse &#125; from &quot;axios&quot;;export interface RequestInterceptors&lt;T = AxiosResponse&gt; &#123;  requestInterceptor?: (config: AxiosRequestConfig) =&gt; AxiosRequestConfig;  requestInterceptorCatch?: (error: any) =&gt; any;  responseInterceptor?: (res: T) =&gt; T;  responseInterceptorCatch?: (error: any) =&gt; any;&#125;export interface RequestConfig&lt;T = AxiosResponse&gt; extends AxiosRequestConfig &#123;  interceptors?: RequestInterceptors&lt;T&gt;;  showLoading?: boolean;&#125;\n\n//index.jsimport axiosRequest from &quot;./request&quot;;import localCache from &quot;@/utils/cache&quot;;const httpRequest = new axiosRequest(&#123;  baseURL: process.env.VUE_APP_BASE_URL,  timeout: Number(process.env.VUE_TIME_OUT),  interceptors: &#123;    requestInterceptor: (config) =&gt; &#123;      const token = localCache.getCache(&quot;token&quot;);      if (token) &#123;        config.headers = &#123;&#125;;        config.headers.Authorization = `Bearer $&#123;token&#125;`;      &#125;      return config;    &#125;,    requestInterceptorCatch: (error) =&gt; &#123;      return error;    &#125;,    responseInterceptor: (res) =&gt; &#123;      return res;    &#125;,    responseInterceptorCatch: (error) =&gt; &#123;      return error;    &#125;,  &#125;,&#125;);export default httpRequest;\n\n","categories":["计算机网络","axios"]},{"title":"前端八股文-JS基础","url":"/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-JS%E5%9F%BA%E7%A1%80/","content":"\n\n\t\n    \n\t\n\n\n","categories":["前端八股文"]},{"title":"前端八股文-JS高级","url":"/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-JS%E9%AB%98%E7%BA%A7/","content":"\n\n\t\n    \n\t\n\n\n","categories":["前端八股文"]},{"title":"前端八股文-React全家桶","url":"/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-React%E5%85%A8%E5%AE%B6%E6%A1%B6/","content":"\n\n\t\n    \n\t\n\n\n\n","categories":["前端八股文"]},{"title":"前端八股文-Vue3全家桶实战","url":"/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-Vue3%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E6%88%98/","content":"\n\n\t\n    \n\t\n\n\n\n","categories":["前端八股文"]},{"title":"前端八股文-html-css","url":"/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-html-css/","content":"\n\n\t\n    \n\t\n\n\n\n\n","categories":["前端八股文"]},{"title":"前端八股文-前端工程化基础","url":"/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%9F%BA%E7%A1%80/","content":"\n\n\t\n    \n\t\n\n\n","categories":["前端八股文"]},{"title":"前端八股文-小程序云开发","url":"/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/","content":"\n\n\t\n    \n\t\n\n\n","categories":["前端八股文"]},{"title":"前端八股文-小程序开发","url":"/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/","content":"\n\n\t\n    \n\t\n\n\n","categories":["前端八股文"]},{"title":"前端八股文-框架实战","url":"/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/","content":"\n\n\t\n    \n\t\n\n\n","categories":["前端八股文"]},{"title":"响应式原理的实现","url":"/2022/09/05/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"什么是响应式响应式就是当对象中的属性发生更改的时候，依赖该属性的函数也会重新执行\n封装一个响应式的函数// 定义一个容器来收集依赖const reactiveFns = [];// 定义一个收集依赖的函数const watchFn = (fn) =&gt; &#123;  reactiveFns.push(fn);&#125;;// 对象的响应式const obj = &#123;  name: &quot;why&quot;,  age: 18,&#125;;watchFn(function () &#123;  const newName = obj.name;  console.log(&quot;你好啊, 李银河&quot;);  console.log(&quot;Hello World&quot;);  console.log(obj.name); // 100行&#125;);watchFn(function () &#123;  console.log(obj.name, &quot;demo function -------&quot;);&#125;);function bar() &#123;  console.log(&quot;普通的其他函数&quot;);  console.log(&quot;这个函数不需要有任何响应式&quot;);&#125;obj.name = &quot;kobe&quot;;// 当数据变化的时候，执行对应的函数reactiveFns.forEach((fn) =&gt; &#123;  fn();&#125;);\n\n依赖收集类的封装class Depend &#123;  constructor() &#123;    // 依赖收集容器    this.reactiveFns = [];  &#125;  // 依赖收集的方法  addDepend(fn) &#123;    this.reactiveFns.push(fn);  &#125;  // 更新方法  notify() &#123;    this.reactiveFns.forEach((fn) =&gt; &#123;      fn();    &#125;);  &#125;&#125;const depend = new Depend();function watchFn(fn) &#123;  depend.addDepend(fn);&#125;// 对象的响应式const obj = &#123;  name: &quot;why&quot;, // depend对象  age: 18, // depend对象&#125;;watchFn(function () &#123;  const newName = obj.name;  console.log(&quot;你好啊, 李银河&quot;);  console.log(&quot;Hello World&quot;);  console.log(obj.name); // 100行&#125;);watchFn(function () &#123;  console.log(obj.name, &quot;demo function -------&quot;);&#125;);obj.name = &quot;kobe&quot;;depend.notify();\n\n自动监听对象的变化class Depend &#123;  constructor() &#123;    // 依赖收集容器    this.reactiveFns = [];  &#125;  // 依赖收集的方法  addDepend(fn) &#123;    this.reactiveFns.push(fn);  &#125;  // 更新方法  notify() &#123;    this.reactiveFns.forEach((fn) =&gt; &#123;      fn();    &#125;);  &#125;&#125;const depend = new Depend();function watchFn(fn) &#123;  depend.addDepend(fn);&#125;// 对象的响应式const obj = &#123;  name: &quot;why&quot;, // depend对象  age: 18, // depend对象&#125;;// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxyconst objProxy = new Proxy(obj, &#123;  get(target, key, receiver) &#123;    return Reflect.get(target, key, receiver);  &#125;,  // receiver就是objProxy  set(target, key, newValue, receiver) &#123;    return Reflect.set(target, key, newValue, receiver);  &#125;,&#125;);// 使用对象代理的方式去操作对象，不要直接操作对象watchFn(function () &#123;  const newName = objProxy.name;  console.log(&quot;你好啊, 李银河&quot;);  console.log(&quot;Hello World&quot;);  console.log(objProxy.name); // 100行&#125;);watchFn(function () &#123;  console.log(objProxy.name, &quot;demo function -------&quot;);&#125;);objProxy.name = &quot;kobe&quot;;depend.notify();\n\n依赖收集的管理class Depend &#123;  constructor() &#123;    // 依赖收集容器    this.reactiveFns = [];  &#125;  // 依赖收集的方法  addDepend(fn) &#123;    this.reactiveFns.push(fn);  &#125;  // 更新方法  notify() &#123;    this.reactiveFns.forEach((fn) =&gt; &#123;      if (fn) &#123;        fn();      &#125;    &#125;);  &#125;&#125;// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集let activeReactiveFn = null;function watchFn(fn) &#123;  activeReactiveFn = fn;  // 先执行一次触发get进行依赖收集  fn();  // 将置为null  activeReactiveFn = null;&#125;// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理const targetMap = new WeakMap(); //使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收function getDepend(target, key) &#123;  // 根据target对象获取map的过程  let map = targetMap.get(target); //获取对应的对象的映射  if (!map) &#123;    map = new Map();    targetMap.set(target, map);  &#125;  let depend = map.get(key);  if (!depend) &#123;    depend = new Depend();    map.set(key, depend);  &#125;  return depend;&#125;// 对象的响应式const obj = &#123;  name: &quot;why&quot;, // depend对象  age: 18, // depend对象&#125;;// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxyconst objProxy = new Proxy(obj, &#123;  // receiver 表示当前的proxy,将receiver传入表示当前proxy,在对对象直接操作的时候可以同样对其进行监听get/set进行以下操作  get(target, key, receiver) &#123;    console.log(receiver === objProxy)//true    // 在get中获取对应的depend    const depend = getDepend(target, key);    // 给depend添加响应函数    depend.addDepend(activeReactiveFn);    return Reflect.get(target, key, receiver);  &#125;,  // receiver就是objProxy  set(target, key, newValue, receiver) &#123;    Reflect.set(target, key, newValue, receiver);    const depend = getDepend(target, key);    depend.notify();  &#125;,&#125;);watchFn(function () &#123;  const newName = objProxy.name;  console.log(&quot;你好啊, 李银河&quot;);  console.log(&quot;Hello World&quot;);  console.log(objProxy.name); // 100行&#125;);watchFn(function () &#123;  console.log(objProxy.name, &quot;demo function -------&quot;);&#125;);watchFn(function () &#123;  console.log(objProxy.age, &quot;age 发生变化是需要执行的----1&quot;);&#125;);watchFn(function () &#123;  console.log(objProxy.age, &quot;age 发生变化是需要执行的----2&quot;);&#125;);objProxy.name = &quot;kobe&quot;;objProxy.name = &quot;james&quot;;objProxy.name = &quot;curry&quot;;objProxy.age = 100;const info = &#123;  name: &quot;kobe&quot;,  address: &quot;广州市&quot;,&#125;;watchFn(function () &#123;  console.log(info.address, &quot;监听address变化+++++++++1&quot;);&#125;);watchFn(function () &#123;  console.log(info.address, &quot;监听address变化+++++++++2&quot;);&#125;);\n\n重构Depend// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集let activeReactiveFn = null;class Depend &#123;  /**   * Depend优化:   *  1&gt; depend方法   *  2&gt; 使用Set来保存依赖函数, 而不是数组[]   */  constructor() &#123;    // 依赖收集容器    this.reactiveFns = new Set();  &#125;  // 依赖收集的方法  depend() &#123;    if (activeReactiveFn) &#123;      this.reactiveFns.add(activeReactiveFn);    &#125;  &#125;  // 更新方法  notify() &#123;    this.reactiveFns.forEach((fn) =&gt; &#123;      if (fn) &#123;        fn();      &#125;    &#125;);  &#125;&#125;function watchFn(fn) &#123;  activeReactiveFn = fn;  // 先执行一次触发get进行依赖收集  fn();  // 将置为null  activeReactiveFn = null;&#125;// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理const targetMap = new WeakMap(); //使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收function getDepend(target, key) &#123;  // 根据target对象获取map的过程  let map = targetMap.get(target); //获取对应的对象的映射  if (!map) &#123;    map = new Map();    targetMap.set(target, map);  &#125;  let depend = map.get(key);  if (!depend) &#123;    depend = new Depend();    map.set(key, depend);  &#125;  return depend;&#125;// 对象的响应式const obj = &#123;  name: &quot;why&quot;, // depend对象  age: 18, // depend对象&#125;;// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxyconst objProxy = new Proxy(obj, &#123;  // receiver 表示当前的proxy,将receiver传入表示当前proxy,在对对象直接操作的时候可以同样对其进行监听get/set进行以下操作  get(target, key, receiver) &#123;    // 在get中获取对应的depend    const depend = getDepend(target, key);    // 给depend添加响应函数    depend.depend();    return Reflect.get(target, key, receiver);  &#125;,  // receiver就是objProxy  set(target, key, newValue, receiver) &#123;    Reflect.set(target, key, newValue, receiver);    const depend = getDepend(target, key);    depend.notify();  &#125;,&#125;);watchFn(function () &#123;  const newName = objProxy.name;  console.log(&quot;你好啊, 李银河&quot;);  console.log(&quot;Hello World&quot;);  console.log(objProxy.name); // 100行&#125;);watchFn(function () &#123;  console.log(objProxy.name, &quot;demo function -------&quot;);&#125;);watchFn(function () &#123;  console.log(objProxy.age, &quot;age 发生变化是需要执行的----1&quot;);&#125;);watchFn(function () &#123;  console.log(objProxy.age, &quot;age 发生变化是需要执行的----2&quot;);&#125;);objProxy.name = &quot;kobe&quot;;objProxy.name = &quot;james&quot;;objProxy.name = &quot;curry&quot;;objProxy.age = 100;const info = &#123;  name: &quot;kobe&quot;,  address: &quot;广州市&quot;,&#125;;watchFn(function () &#123;  console.log(info.address, &quot;监听address变化+++++++++1&quot;);&#125;);watchFn(function () &#123;  console.log(info.address, &quot;监听address变化+++++++++2&quot;);&#125;);\n\nvue3对象的响应式操作// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集let activeReactiveFn = null;class Depend &#123;  /**   * Depend优化:   *  1&gt; depend方法   *  2&gt; 使用Set来保存依赖函数, 而不是数组[]   */  constructor() &#123;    // 依赖收集容器    this.reactiveFns = new Set();  &#125;  // 依赖收集的方法  depend() &#123;    if (activeReactiveFn) &#123;      this.reactiveFns.add(activeReactiveFn);    &#125;  &#125;  // 更新方法  notify() &#123;    this.reactiveFns.forEach((fn) =&gt; &#123;      if (fn) &#123;        fn();      &#125;    &#125;);  &#125;&#125;function watchFn(fn) &#123;  activeReactiveFn = fn;  // 先执行一次触发get进行依赖收集  fn();  // 将置为null  activeReactiveFn = null;&#125;// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理const targetMap = new WeakMap(); //使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收function getDepend(target, key) &#123;  // 根据target对象获取map的过程  let map = targetMap.get(target); //获取对应的对象的映射  if (!map) &#123;    map = new Map();    targetMap.set(target, map);  &#125;  let depend = map.get(key);  if (!depend) &#123;    depend = new Depend();    map.set(key, depend);  &#125;  return depend;&#125;// 对象的响应式const obj = &#123;  name: &quot;why&quot;, // depend对象  age: 18, // depend对象&#125;;// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxyfunction reactive(obj) &#123;  return new Proxy(obj, &#123;    // receiver 表示当前的proxy,将receiver传入表示当前proxy,在对对象直接操作的时候可以同样对其进行监听get/set进行以下操作    get(target, key, receiver) &#123;      // 在get中获取对应的depend      const depend = getDepend(target, key);      // 给depend添加响应函数      depend.depend();      return Reflect.get(target, key, receiver);    &#125;,    // receiver就是objProxy    set(target, key, newValue, receiver) &#123;      Reflect.set(target, key, newValue, receiver);      const depend = getDepend(target, key);      depend.notify();    &#125;,  &#125;);&#125;const objProxy = reactive(&#123;  name: &quot;why&quot;, // depend对象  age: 18, // depend对象&#125;);const infoProxy = reactive(&#123;  address: &quot;广州市&quot;,  height: 1.88,&#125;);watchFn(() =&gt; &#123;  console.log(infoProxy.address);&#125;);infoProxy.address = &quot;北京市&quot;;const foo = reactive(&#123;  name: &quot;foo&quot;,&#125;);watchFn(() =&gt; &#123;  console.log(foo.name);&#125;);foo.name = &quot;bar&quot;;\n\nvue2对象的响应式操作// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集let activeReactiveFn = null;class Depend &#123;  /**   * Depend优化:   *  1&gt; depend方法   *  2&gt; 使用Set来保存依赖函数, 而不是数组[]   */  constructor() &#123;    // 依赖收集容器    this.reactiveFns = new Set();  &#125;  // 依赖收集的方法  depend() &#123;    if (activeReactiveFn) &#123;      this.reactiveFns.add(activeReactiveFn);    &#125;  &#125;  // 更新方法  notify() &#123;    this.reactiveFns.forEach((fn) =&gt; &#123;      if (fn) &#123;        fn();      &#125;    &#125;);  &#125;&#125;function watchFn(fn) &#123;  activeReactiveFn = fn;  // 先执行一次触发get进行依赖收集  fn();  // 将置为null  activeReactiveFn = null;&#125;// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理const targetMap = new WeakMap(); //使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收function getDepend(target, key) &#123;  // 根据target对象获取map的过程  let map = targetMap.get(target); //获取对应的对象的映射  if (!map) &#123;    map = new Map();    targetMap.set(target, map);  &#125;  let depend = map.get(key);  if (!depend) &#123;    depend = new Depend();    map.set(key, depend);  &#125;  return depend;&#125;// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxyfunction reactive(obj) &#123;  Object.keys(obj).forEach((key) =&gt; &#123;    let value = obj[key];    Object.defineProperty(obj, key, &#123;      get() &#123;        const depend = getDepend(obj, key);        depend.depend();        return value;      &#125;,      set(newValue) &#123;        value = newValue;        const depend = getDepend(obj, key);        depend.notify();      &#125;,    &#125;);  &#125;);  return obj;&#125;const infoProxy = reactive(&#123;  address: &quot;广州市&quot;,  height: 1.88,&#125;);watchFn(() =&gt; &#123;  console.log(infoProxy.address);&#125;);infoProxy.address = &quot;北京市&quot;;const foo = reactive(&#123;  name: &quot;foo&quot;,&#125;);watchFn(() =&gt; &#123;  console.log(foo.name);&#125;);foo.name = &quot;bar&quot;;foo.name = &quot;hhh&quot;;\n\n","categories":["javascript","搜集"]},{"title":"学习JavaScript数据结构与算法（第3版）第五章 队列与双端队列","url":"/2022/09/17/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%98%9F%E5%88%97%E4%B8%8E%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/","content":"##队列和双端队列class Queue &#123;  /**   * 首先需要一个用于存储队列中元素的数据结构。我们可以使用数组，就像上一章的 Stack类那样。但是，为了写出一个在获取元素时更高效的数据结构，我们将使用一个对象来存储我们的元素（行&#123;3&#125;）。你会发现 Queue 类和 Stack 类非常类似，只是添加和移除元素的原则不同也可以声明一个 count 属性来帮助我们控制队列的大小（行&#123;1&#125;）。此外，由于我们将要从队列前端移除元素，同样需要一个变量来帮助我们追踪第一个元素。因此，声明一个 lowestCount变量（行&#123;2&#125;）   */  constructor() &#123;    this.count = 0;    this.lowestCount = 0;    this.items = &#123;&#125;;  &#125;  // 向队列尾部添加一个（或多个）新的项  enqueue(...elements) &#123;    for (let i = 0; i &lt; elements.length; i++) &#123;      this.items[this.count] = elements[i];      this.count++;    &#125;  &#125;  // 移除队列的第一项（即排在队列最前面的项）并返回被移除的元素  dequeue() &#123;    if (this.count === 0) &#123;      return undefined;    &#125;    const result = this.items[this.lowestCount];    delete this.items[this.lowestCount];    this.lowestCount++;    return result;  &#125;  // 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做  // 任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。该方  // 法在其他语言中也可以叫作 front 方法  peek() &#123;    if (this.count === 0) &#123;      return undefined;    &#125;    return this.items[this.lowestCount];  &#125;  // 如果队列中不包含任何元素，返回 true，否则返回 false  isEmpty() &#123;    return this.count - this.lowestCount === 0 ? true : false;  &#125;  // 返回队列包含的元素个数，与数组的 length 属性类似  size() &#123;    return this.count - this.lowestCount;  &#125;  clear() &#123;    this.count = 0;    this.lowestCount = 0;    this.items = &#123;&#125;;  &#125;  toString() &#123;    let str = &quot;&quot;;    if (this.isEmpty()) &#123;      return str;    &#125;    str = this.items[this.lowestCount];    for (let i = this.lowestCount + 1; i &lt; this.count; i++) &#123;      str += `,$&#123;this.items[i]&#125;`;    &#125;    return str;  &#125;&#125;// const queue = new Queue();// console.log(queue.isEmpty()); // 输出 true// queue.enqueue(&quot;John&quot;);// queue.enqueue(&quot;Jack&quot;);// console.log(queue.toString()); // John,Jack// queue.enqueue(&quot;Camila&quot;);// console.log(queue.toString()); // John, Jack, Camila// console.log(queue.size()); // 输出 3// console.log(queue.isEmpty()); // 输出 false// queue.dequeue(); // 移除 John// queue.dequeue(); // 移除 Jack// console.log(queue.toString()); // Camilaexport default Queue;\n\n双端队列数据结构class Deque &#123;  // 双端队列，遵循先进先出和后进先出  constructor() &#123;    this.items = &#123;&#125;;    this.count = 0;    this.lowestCount = 0;  &#125;  isEmpty() &#123;    return this.count - this.lowestCount === 0;  &#125;  clear() &#123;    this.items = &#123;&#125;;    this.count = 0;    this.lowestCount = 0;  &#125;  size() &#123;    return this.count - this.lowestCount;  &#125;  toString() &#123;    let str = &quot;&quot;;    if (this.isEmpty()) &#123;      return str;    &#125;    str = this.items[this.lowestCount];    for (let i = this.lowestCount + 1; i &lt; this.count; i++) &#123;      str += `,$&#123;this.items[i]&#125;`;    &#125;    return str;  &#125;  // 该方法在双端队列前端添加新的元素  addFront(element) &#123;    if (this.isEmpty()) &#123;      this.addBack(element);    &#125; else if (this.lowestCount &gt; 0) &#123;      this.lowestCount--;      this.items[this.lowestCount] = element;    &#125; else &#123;      for (let i = this.count; i &gt; 0; i--) &#123;        this.items[i] = this.items[i - 1];      &#125;      this.items[0] = element;      this.lowestCount = 0;      this.count++;    &#125;  &#125;  // 该方法在双端队列后端添加新的元素（实现方法和 Queue 类中的enqueue 方法相同）  addBack(element) &#123;    this.items[this.count] = element;    this.count++;  &#125;  // 该方法会从双端队列前端移除第一个元素（实现方法和 Queue 类中的dequeue 方法相同）  removeFront() &#123;    if (this.isEmpty()) &#123;      return undefined;    &#125;    const result = this.items[this.lowestCount];    delete this.items[this.lowestCount];    this.lowestCount++;    return result;  &#125;  //该方法会从双端队列后端移除第一个元素（实现方法和 Stack 类中的pop 方法一样）。  removeBack() &#123;    if (this.isEmpty()) &#123;      return undefined;    &#125;    this.count--;    const result = this.items[this.count];    delete this.items[this.count];    return result;  &#125;  // 该方法返回双端队列前端的第一个元素（实现方法和 Queue 类中的 peek方法一样）。  peekFront() &#123;    if (this.isEmpty()) &#123;      return undefined;    &#125;    return this.items[this.lowestCount];  &#125;  // 该方法返回双端队列后端的第一个元素（实现方法和 Stack 类中的 peek方法一样）  peekBack() &#123;    if (this.isEmpty()) &#123;      return undefined;    &#125;    return this.items[this.count];  &#125;&#125;// const deque = new Deque();// console.log(deque.isEmpty()); // 输出 true// deque.addBack(&quot;John&quot;);// deque.addBack(&quot;Jack&quot;);// console.log(deque.toString()); // John, Jack// deque.addBack(&quot;Camila&quot;);// console.log(deque.toString()); // John, Jack, Camila// console.log(deque.size()); // 输出 3// console.log(deque.isEmpty()); // 输出 false// deque.removeFront(); // 移除 John// console.log(deque.toString()); // Jack, Camila// deque.removeBack(); // Camila 决定离开// console.log(deque.toString()); // Jack// deque.addFront(&quot;John&quot;); // John 回来询问一些信息// console.log(deque.toString()); // John, Jackexport default Deque;\n\n使用队列和双端队列来解决问题循环队列——击鼓传花游戏这其中的一种叫作循环队列。循环队列的一个例子就是击鼓传花游戏（hot  potato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）。\n实现一个模拟的击鼓传花游戏，要用到本章开头实现的 Queue 类（行{1}）。我们会得到一 份名单，把里面的名字全都加入队列（行{2}）。给定一个数字，然后迭代队列。从队列开头移 除一项，再将其添加到队列末尾（行{3}），模拟击鼓传花（如果你把花传给了旁边的人，你被 淘汰的威胁就立刻解除了）。一旦达到给定的传递次数，拿着花的那个人就被淘汰了（从队列中 移除——行{4}）。最后只剩下一个人的时候，这个人就是胜者（行{5}）\nimport Queue from &quot;./Queue.js&quot;;function hotPotato(elementsList, num) &#123;  const queue = new Queue();  const elimitatedList = [];  for (let i = 0; i &lt; elementsList.length; i++) &#123;    queue.enqueue(elementsList[i]);  &#125;  console.log(queue.toString(), &quot;----&quot;);  while (queue.size() &gt; 1) &#123;    for (let i = 0; i &lt; num; i++) &#123;      queue.enqueue(queue.dequeue());    &#125;    elimitatedList.push(queue.dequeue());  &#125;  return &#123;    winner: queue.dequeue(),    eliminated: elimitatedList,  &#125;;&#125;const names = [&quot;John&quot;, &quot;Jack&quot;, &quot;Camila&quot;, &quot;Ingrid&quot;, &quot;Carl&quot;];const result = hotPotato(names, 7);result.eliminated.forEach((name) =&gt; &#123;  console.log(`$&#123;name&#125;在击鼓传花游戏中被淘汰。`);&#125;);console.log(`胜利者： $&#123;result.winner&#125;`);\n\n以上算法的输出如下。\n Camila 在击鼓传花游戏中被淘汰。\n Jack 在击鼓传花游戏中被淘汰。\n Carl 在击鼓传花游戏中被淘汰。\n Ingrid 在击鼓传花游戏中被淘汰。 \n 胜利者：John\n回文检查器下面是维基百科对回文的解释。 回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。 有不同的算法可以检查一个词组或字符串是否为回文。最简单的方式是将字符串反向排列并 检查它和原字符串是否相同。如果两者相同，那么它就是一个回文。我们也可以用栈来完成，但 是利用数据结构来解决这个问题的最简单方法是使用双端队列\nimport Deque from &quot;./Deque.js&quot;;// 回文字符串检测function palindromeChecker(aString) &#123;  if (aString == null || (aString != null &amp;&amp; aString.length === 0)) &#123;    return false;  &#125;  // 判断是否相等，不相等就返回  let isEqual = true;  // 获得第一个和最后一个字符  let firstChar, lastChar;  const deque = new Deque();  // 先将字符串转成小写然后再去掉空格重新拼接  aString = aString.toLocaleLowerCase().split(&quot; &quot;).join(&quot;&quot;);  console.log(aString);  for (let i = 0; i &lt; aString.length; i++) &#123;    deque.addBack(aString.charAt(i));  &#125;  // while循环拿到第一个和最后一个进行比较，只有在isEqual为true才继续比奥,只有一个的时候跳出  while (deque.size() &gt; 1 &amp;&amp; isEqual) &#123;    firstChar = deque.removeFront();    lastChar = deque.removeBack();    if (lastChar !== firstChar) &#123;      isEqual = false;    &#125;  &#125;  return isEqual;&#125;// 全是trueconsole.log(&quot;a&quot;, palindromeChecker(&quot;a&quot;));console.log(&quot;aa&quot;, palindromeChecker(&quot;aa&quot;));console.log(&quot;kayak&quot;, palindromeChecker(&quot;kayak&quot;));console.log(&quot;level&quot;, palindromeChecker(&quot;level&quot;));console.log(  &quot;Was it a car or a cat I saw&quot;,  palindromeChecker(&quot;Was it a car or a cat I saw&quot;));console.log(&quot;Step on no pets&quot;, palindromeChecker(&quot;Step on no pets&quot;));\n\n在我们开始解释算法逻辑之前，需要检查传入的字符串参数是否合法（行{1}）。如果不合 法，我们返回 false。 对于这个算法，我们将使用在本章实现的 Deque 类（行{2}）。由于可能接收到同时包含大 小写字母的字符串，我们会将所有字母转化为小写，同时移除所有的空格（行{3}）。如果你愿意， 也可以移除所有的特殊字符，例如!、?、-、(和)等。为了保证算法简洁，我们会跳过这部分。 然后，我们会对字符串中的所有字符执行 enqueue 操作（行{4}）。如果所有元素都在双端 队列中（如果只有一个字符的话，那它肯定是回文）并且首尾字符相同的话（行{5}），我们将 从前端移除一个元素（行{6}），再从后端移除一个元素（行{7}）。要使字符串为回文，移除的 两个字符必须相同。如果字符不同的话，这个字符串就不是一个回文（行{8}）\n","categories":["数据结构"]},{"title":"学习JavaScript数据结构与算法（第3版）第六章链表","url":"/2022/09/17/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%85%AD%E7%AB%A0%E9%93%BE%E8%A1%A8/","content":"","categories":["数据结构"]},{"title":"学习JavaScript数据结构与算法（第3版）读书笔记","url":"/2022/09/14/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","content":"##第四章栈使用数组来定义数据结构\nclass Stack &#123;  constructor() &#123;    this.items = [];  &#125;  // 添加一个（或几个）新元素到栈顶,返回值是数组的长度  push(element) &#123;    return this.items.push(element);  &#125;  //移除栈顶的元素，同时返回被移除的元素  pop() &#123;    return this.items.pop();  &#125;  //返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）  peek() &#123;    return this.items[this.items.length - 1];  &#125;  // 如果栈里没有任何元素就返回 true，否则返回 false  isEmpty() &#123;    return this.items.length &gt; 0 ? false : true;  &#125;  // 移除栈里的所有元素  clear() &#123;    this.items = [];  &#125;  //返回栈里的元素个数。该方法和数组的 length 属性很类似  size() &#123;    return this.items.length;  &#125;&#125;\n\n使用对象来定义栈\nclass Stack &#123;  constructor() &#123;    this.count = 0;    this.items = &#123;&#125;;  &#125;  push(element) &#123;    this.items[this.count] = element;    this.count++;  &#125;  size() &#123;    return this.count;  &#125;  isEmpty() &#123;    return this.count === 0;  &#125;  pop() &#123;    if (this.isEmpty()) &#123;      return undefined;    &#125;    this.count--;    const result = this.items[this.count];    delete this.items[this.count];    return result;  &#125;  clear() &#123;    this.count = 0;    this.items = &#123;&#125;;    // while(!this.isEmpty())&#123;    //   this.pop()    // &#125;  &#125;  peek() &#123;    if (!this.isEmpty()) &#123;      return undefined;    &#125;    return this.items[this.count - 1];  &#125;  toString() &#123;    if (!this.isEmpty()) &#123;      return &quot;&quot;;    &#125;    let str = this.items[0];    for (let i = 1; i &lt; this.count; i++) &#123;      str = str + `,$&#123;this.items[i]&#125;`;    &#125;    return str;  &#125;&#125;\n\n保护数据结构内部元素\nconst stack = new Stack();console.log(Object.getOwnPropertyNames(stack)); // &#123;1&#125;console.log(Object.keys(stack)); // &#123;2&#125;console.log(stack.items);\n\n外部可以直接拿到内部的数据，因为js中没有私有属性\nclass Stack &#123;  constructor() &#123;  this._count = 0;  this._items = &#123;&#125;;  &#125; &#125;\n\n一部分开发者胡使用下划线作为私有属性的规范，但是这样依然可以被访问，没有实质性的作用\n用 ES2015 的限定作用域 Symbol 实现类const _items = new Symbol(&quot;stackItem&quot;);class Stack &#123;  constructor() &#123;    //使用计算属性和symbol的形式    this[_items] = &#123;&#125;;  &#125;&#125;\n\n虽然这种方式可以让上述方法没办法访问内部属性但是可以通过Object.getOwnPropertySymbol(stack)可以访问到以Symbol为key的属性\n用 ES2015 的 WeakMap 实现类const items=new WeakMap()class WeakMapStack&#123;  constructor()&#123;    items.set(this,[])  &#125;  push(element)&#123;    items.get(this).push(element)  &#125;  pop()&#123;    return items.get(this).pop()  &#125;  //...&#125;\n\n现在我们知道了，items 在 Stack 类里是真正的私有属性。采用这种方法，代码的可读性 不强，而且在扩展该类时无法继承私有属性。鱼和熊掌不可兼得！\n使用栈的实例// 将十进制转成二进制import Stack from &quot;./Stack.js&quot;;function decimalToBinary(decNumber) &#123;  decNumber = Math.floor(Number(decNumber));  const stack = new Stack();  let dec = decNumber;  while (dec &gt; 0) &#123;    console.log(Math.floor(dec % 2));    stack.push(dec % 2);    dec = Math.floor(dec / 2);  &#125;  let binaryString = &quot;&quot;;  while (!stack.isEmpty()) &#123;    binaryString += stack.pop().toString();  &#125;  return binaryString;&#125;\n\n// 把十进制转换成基数为 2～36 的任意进制import Stack from &quot;./Stack.js&quot;;function baseConverter(decNumber, base) &#123;  let dec = decNumber;  let arr = new Stack();  const digits = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;  let str = &quot;&quot;;  if (!(base &gt;= 2 &amp;&amp; base &lt;= 36)) &#123;    return str;  &#125;  while (dec &gt; 0) &#123;    arr.push(Math.floor(dec % base));    dec = Math.floor(dec / base);  &#125;  while (!arr.isEmpty()) &#123;    str += digits[arr.pop()];  &#125;  return str;&#125;console.log(baseConverter(100345, 2)); // 11000011111111001console.log(baseConverter(100345, 8)); // 303771console.log(baseConverter(100345, 16)); // 187F9console.log(baseConverter(100345, 35)); // 2BW0\n\n","categories":["数据结构"]},{"title":"实现bind","url":"/2022/09/05/%E5%AE%9E%E7%8E%B0bind/","content":"Function.prototype.mybind = function (thisArg, ...args) &#123;  // 获得this的指向，就是实际的调用者  let fn = this;  // 获取thisArg,如果是基本数据类型除了null,undefined都转成包装类型，否则指向全局  thisArg = thisArg != null ? Object(thisArg) : globalThis;  // bind会返回一个新的函数  return function newFn(...argArr) &#123;    // 向thisArg对象添加这个方法    thisArg.fn = fn;    // 合并参数    const argTotals = [...args, ...argArr];    // 执行函数    const result = thisArg.fn(...argTotals);    // 执行完成后删除方法    delete thisArg.fn;    return result;  &#125;;&#125;;function foo() &#123;  console.log(&quot;foo被执行&quot;, this);  return 20;&#125;function sum(num1, num2, num3, num4) &#123;  console.log(num1, num2, num3, num4);&#125;// 系统的bind使用var bar = foo.bind(&quot;abc&quot;);bar();var newSum = sum.bind(&quot;aaa&quot;, 10, 20, 30, 40);newSum();// 使用自己定义的bindvar bar = foo.mybind(&quot;abc&quot;);var result = bar();console.log(result);var newSum = sum.mybind(&quot;abc&quot;, 10, 20);var result = newSum(30, 40);\n\n"},{"title":"实现一个时间格式化工具","url":"/2022/09/11/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/","content":"// 如何封装一个时间格式化工具function formatTime(timeStamp, fmtString) &#123;  // 1.先将时间戳转成Date的形式  const date = new Date(timeStamp);  // 2.建立正则表达式和值匹配的映射  const dateObject = &#123;    &quot;y+&quot;: date.getFullYear(),    &quot;M+&quot;: date.getMonth() + 1,    &quot;d+&quot;: date.getDate(),    &quot;h+&quot;: date.getHours(),    &quot;m+&quot;: date.getMinutes(),    &quot;s+&quot;: date.getSeconds(),  &#125;;  // 遍历dateObject匹配  for (const key in dateObject) &#123;    const reg = new RegExp(key);    if (reg.test(fmtString)) &#123;      fmtString = fmtString.replace(reg, (dateObject[key] + &quot;&quot;).padStart(2, 0));    &#125;  &#125;  return fmtString;&#125;console.log(formatTime(new Date().getTime(), &quot;yyyy-MM-dd:hh:mm:ss&quot;)); //2022-09-11:17:05:48\n\n","categories":["javascript","工具"]},{"title":"实现可过期的localstorage数据(仅供参考)","url":"/2022/08/15/%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%BF%87%E6%9C%9F%E7%9A%84localstorage%E6%95%B0%E6%8D%AE/","content":"localstorage相对于cookie中的问题是不能设置过期时间\n所以我们要自己对localStorage进行二次封装，使得localstorage在适当的时间失效\n解法一localStorage.setItem(&quot;key&quot;, &quot;value&quot;);const timeout = 1000 * 60 * 60;setTimeout(() =&gt; &#123;  localStorage.removeItem(&quot;key&quot;);&#125;, timeout);\n\n这种方式需要编写多个定时器，维护成本高，不利于代码的复用\n解法二\n用「localStorage」存一份{key(键): expire(过期时间)}的映射表\n重写「localStorage API」, 对方法进行二次封装\n\nconst store = &#123;  setExpireMap(key, expire) &#123;    const expireMap = localStorage.getItem(&quot;EXPIRE_MAP&quot;) || &#123;&#125;;    localStorage.setItem(      &quot;EXPIRE_MAP&quot;,      JSON.stringify(&#123;        ...expireMap,        [key]: expire,      &#125;)    );  &#125;,  setItem(key, value, expire) &#123;    this.setExpireMap(key, expire);    localStorage.setItem(key, value);  &#125;,  getItem(key) &#123;    const expireMap = JSON.parse(localStorage.getItem(&quot;EXPIRE_MAP&quot;))[key];    if (expireMap &amp;&amp; expireMap &gt; Date.now()) &#123;      return localStorage.getItem(key);    &#125;    localStorage.removeItem(key);    return null;  &#125;,&#125;;\n\n\n对 store 操作时需要维护2份数据, 并且占用缓存空间\n如果 EXPIRE_MAP 误删除将会导致所有过期时间失效\n对操作过程缺少更灵活的控制(比如操作状态, 操作回调等)\n\n解法三惰性删除，只有在下一次取值的时候才删除\nvar lsc = (function (self) &#123;    var prefix = &#x27;one_more_lsc_&#x27;    /**     * 增加一个键值对数据     * @param key 键     * @param val 值     * @param expires 过期时间，单位为秒     */    self.set = function (key, val, expires) &#123;        key = prefix + key;        val = JSON.stringify(&#123;&#x27;val&#x27;: val, &#x27;expires&#x27;: new Date().getTime() + expires * 1000&#125;);        localStorage.setItem(key, val);    &#125;;    /**     * 读取对应键的值数据     * @param key 键     * @returns &#123;null|*&#125; 对应键的值     */    self.get = function (key) &#123;        key = prefix + key;        var val = localStorage.getItem(key);        if (!val) &#123;            return null;        &#125;        val = JSON.parse(val);        if (val.expires &lt; new Date().getTime()) &#123;            localStorage.removeItem(key);            return null;        &#125;        return val.val;    &#125;;    return self;&#125;(lsc || &#123;&#125;));\n\n上述代码通过惰性删除已经实现了可过期的localStorage缓存，但是也有比较明显的缺点：如果一个key一直没有被用到，即使它已经过期了也永远存放在localStorage。为了弥补这样缺点，我们引入另一种清理过期缓存的策略。\n解法四定时删除定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。\n每隔一秒执行一次定时删除，操作如下：\n\n随机测试20个设置了过期时间的key。\n删除所有发现的已过期的key。\n若删除的key超过5个则重复步骤1，直至重复500次。\n\n具体实现如下：\nvar lsc = (function (self) &#123;    var prefix = &#x27;one_more_lsc_&#x27;    var list = [];    //初始化list    self.init = function () &#123;        var keys = Object.keys(localStorage);        var reg = new RegExp(&#x27;^&#x27; + prefix);        var temp = [];        //遍历所有localStorage中的所有key        for (var i = 0; i &lt; keys.length; i++) &#123;        \t//找出可过期缓存的key            if (reg.test(keys[i])) &#123;                temp.push(keys[i]);            &#125;        &#125;        list = temp;    &#125;;    self.init();    self.check = function () &#123;        if (!list || list.length == 0) &#123;            return;        &#125;        var checkCount = 0;        while (checkCount &lt; 500) &#123;            var expireCount = 0;            //随机测试20个设置了过期时间的key            for (var i = 0; i &lt; 20; i++) &#123;                if (list.length == 0) &#123;                    break;                &#125;                var index = Math.floor(Math.random() * list.length);                var key = list[index];                var val = localStorage.getItem(list[index]);                //从list中删除被惰性删除的key                if (!val) &#123;                    list.splice(index, 1);                    expireCount++;                    continue;                &#125;                val = JSON.parse(val);                //删除所有发现的已过期的key                if (val.expires &lt; new Date().getTime()) &#123;                    list.splice(index, 1);                    localStorage.removeItem(key);                    expireCount++;                &#125;            &#125;            //若删除的key不超过5个则跳出循环            if (expireCount &lt;= 5 || list.length == 0) &#123;                break;            &#125;            checkCount++;        &#125;    &#125;    //每隔一秒执行一次定时删除    window.setInterval(self.check, 1000);    return self;&#125;(lsc || &#123;&#125;));\n\n","categories":["javascript","搜集"]},{"title":"实现自动柯里化函数","url":"/2022/09/05/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/","content":"","categories":["javascript","原理"]},{"title":"常用正则表达式","url":"/2022/09/08/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"// 创建正则   // 1&gt; 匹配的规则pattern   // 2&gt; 匹配的修饰符flags   const re1 = new RegExp(&quot;abc&quot;, &quot;ig&quot;)   const re2 = /abc/ig // 我是注释\n\n正则表达式的使用方法JavaScript中的正则表达式被用于 RegExp 的 exec 和 test 方法\n也包括 String 的 match、matchAll、replace、search 和 split 方法\nexec : 一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）\nconst message = &quot;fdabc123 faBC323 dfABC222 A2324aaBc&quot;;const re1 = /abc/gi;// console.log(re1.test(message));console.log(re1.exec(message));/** * [  &#x27;aBC&#x27;,  index: 10,  input: &#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;,  groups: undefined] */\n\ntest:一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false\nconst message = &quot;fdabc123 faBC323 dfABC222 A2324aaBc&quot;;const re1 = /abc/gi; console.log(re1.test(message));\n\nmatch:一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null\n// match方法const res2 = message.match(re1);console.log(res2);//[ &#x27;abc&#x27;, &#x27;aBC&#x27;, &#x27;ABC&#x27;, &#x27;aBc&#x27; ]\n\nmatchAll :一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）\n// matchAllconst res = message.matchAll(re1);for (const iterator of res) &#123;  console.log(iterator);&#125;[  &#x27;abc&#x27;,  index: 2,  input: &#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;,  groups: undefined][  &#x27;aBC&#x27;,  index: 10,  input: &#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;,  groups: undefined][  &#x27;ABC&#x27;,  index: 19,  input: &#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;,  groups: undefined][  &#x27;aBc&#x27;,  index: 32,  input: &#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;,  groups: undefined]\n\nsearch :一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。\nconst result5 = message.search(re1)console.log(result5)\n\nreplace:一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串\nsplit:一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中 的 String 方法\n修饰符flag的使用常见的修饰符\ng:全局匹配\ni:不区分大小写\nm:多行匹配\n规则 – 字符类\\d  平匹配数字0-9\\s  空格符号，包括空格，制表符\\t , 换行符\\n,和其他少数稀有字符，例如\\v,\\f,\\r\\w  表示单字字符  字母、数字、下划线\n\n反向类\n\\D 表示非数字的其他字符包括数字\n\\W 表示非单字字符\n\\S 非空格字符\n规则 – 锚点符号 ^ 和符号 $ 在正则表达式中具有特殊的意义，它们被称为“锚点”\n符号 ^ 匹配文本开头；\n符号 $ 匹配文本末尾；\n词边界（Word boundary）\n​\t词边界 \\b 是一种检查，就像 ^ 和 $ 一样，它会检查字符串中的位置是否是词边界\n​\t词边界测试 \\b 检查位置的一侧是否匹配 \\w，而另一侧则不匹配 “\\w”\nconst message = &quot;My name! is WHY.&quot;;// 需求: name, name必须是一个单独的词// 词边界if (/\\bname\\b/i.test(message)) &#123;  console.log(&quot;有name, name有边界&quot;);&#125;// 词边界的应用const infos = &quot;now time is 11:56, 12:00 eat food, number is 123:456&quot;;const timeRe = /\\b\\d\\d:\\d\\d\\b/gi;console.log(infos.match(timeRe));/** * 有name, name有边界[ &#x27;11:56&#x27;, &#x27;12:00&#x27; ] */\n\n规则 – 转义字符串转义字符要做常规字符来使用，需要使用对其进行转义，只要在它前面加个反斜杠\n常见的需要转义的字符：\n[] \\  ^ $ . | ? * + ()\n\n斜杠符号 ‘&#x2F;’ 并不是一个特殊符号，但是在字面量正则表达式中也需要转义集合（Sets）和范围（Ranges）有时候我们只要选择多个匹配字符的其中之一就可以 有时候我们只要选择多个匹配字符的其中之一就可以\n\n集合  []  表示匹配中括号里面的任意一个字符\n范围  \n​\t[0-9] 方括号也可以包含字符范围，例如匹配从a到z范围的字母[a-z],[0-5],\n​\t\\d  &#x3D;&#x3D;&#x3D;[0-9]\n​\t\\w &#x3D;&#x3D;&#x3D;[a-zA-Z0-9]\n​\t.    点表示匹配除换行符之外的所有字符\n排除范围：除了普通的范围匹配，还有类似 [^…] 的“排除”范围匹配量词数量  {n} 确切的数  ,{n,m} 表示多少范围匹配\n缩写\n​\t+  表示一个或者多个 &#x3D;&#x3D;&#x3D;{1，}\n​\t？表示零个或者一个 &#x3D;&#x3D;&#x3D;{0，1}\n​\t*  表示零个或者多个 &#x3D;&#x3D;&#x3D;{0，}\n贪婪（ Greedy）和惰性（ lazy）模式默认是贪婪模式，\n// 1.贪婪模式/惰性模式const message =  &quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;;// 默认.+采用贪婪模式const nameRe = /《.+》/gi;const result1 = message.match(nameRe);console.log(result1);//[ &#x27;《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27; ]\n\nconst message =  &quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;;// // 默认.+采用贪婪模式// const nameRe = /《.+》/gi;// const result1 = message.match(nameRe);// console.log(result1);// 使用惰性模式const nameRe = /《.+?》/gi;const result1 = message.match(nameRe);console.log(result1);//[ &#x27;《黄金时代》&#x27;, &#x27;《沉默的大多数》&#x27;, &#x27;《一只特立独行的猪》&#x27; ]\n\n默认情况下的匹配规则是查找到匹配的内容后，会继续向后查找，一直找到最后一个匹配的内容 , 这种匹配的方式，我们称之为贪婪模式（Greedy）\n懒惰模式中的量词与贪婪模式中的是相反的。 \n只要获取到对应的内容后，就不再继续向后匹配； \n我们可以在量词后面再加一个问号 ‘?’ 来启用它； \n 所以匹配模式变为 *? 或 +?，甚至将 ‘?’ 变为 ?\n捕获组（capturing group）模式的一部分可以用括号括起来 (…)，这称为“捕获组（capturing group）”\n模式的一部分可以用括号括起来 (…)，这称为“捕获组（capturing group）”。\n ◼ 这有两个作用： \n​\t它允许将匹配的一部分作为结果数组中的单独项；\n​\t 它将括号视为一个整体； \n​\t\t\t方法 str.match(regexp)，如果 regexp 没有 g 标志，将查找第一个匹配并将它作为一个数组返回：\n​\t\t\t\t  在索引 0 处：完全匹配。\n​\t\t\t\t  在索引 1 处：第一个括号的内容。 \n​\t\t\t\t 在索引 2 处：第二个括号的内容。 \n​\t\t\t\t\t …等等\n// 1.捕获组const message =  &quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;;// 使用惰性模式//这是通过在开始括号之后立即放置 ?&lt;name&gt; 来完成的const nameRe = /(?:《)(?&lt;why&gt;.+?)(?:》)/gi;//可以给捕获组起名字const iterator = message.matchAll(nameRe);for (const item of iterator) &#123;  console.log(item);&#125;// 2.将捕获组作为整体const info = &quot;dfabcabcfabcdfdabcabcabcljll;jk;j&quot;;const abcRe = /(abc)&#123;2,&#125;/gi;console.log(info.match(abcRe));[  &#x27;《黄金时代》&#x27;,  &#x27;黄金时代&#x27;,  index: 10,  input: &#x27;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27;,  groups: [Object: null prototype] &#123; why: &#x27;黄金时代&#x27; &#125;][  &#x27;《沉默的大多数》&#x27;,  &#x27;沉默的大多数&#x27;,  index: 17,  input: &#x27;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27;,  groups: [Object: null prototype] &#123; why: &#x27;沉默的大多数&#x27; &#125;][  &#x27;《一只特立独行的猪》&#x27;,  &#x27;一只特立独行的猪&#x27;,  index: 26,  input: &#x27;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27;,  groups: [Object: null prototype] &#123; why: &#x27;一只特立独行的猪&#x27; &#125;][ &#x27;abcabc&#x27;, &#x27;abcabcabc&#x27; ]\n\n// 1.将捕获组作为整体const info = &quot;dfabcabcfabcdfdabcabcabcljcbacballnbanba;jk;j&quot;;const abcRe = /(abc|cba|nba)&#123;2,&#125;/gi;console.log(info.match(abcRe));//[ &#x27;abcabc&#x27;, &#x27;abcabcabc&#x27;, &#x27;cbacba&#x27;, &#x27;nbanba&#x27; ]\n\n非捕获组：\n  有时我们需要括号才能正确应用量词，但我们不希望它们的内容出现在结果中。\n 可以通过在开头添加 ?: 来排除组。\n","categories":["正则表达式","note"]},{"title":"常用的git操作","url":"/2022/09/08/%E5%B8%B8%E7%94%A8%E7%9A%84git%E6%93%8D%E4%BD%9C/","content":"##git基本使用初始化Git仓库git init\n\n克隆仓库git clone https://github.com/coderwhy/hy-react-web-music.git\n\n检测文件的状态git statusgit status -sgit status --short\n\n将所有文件添加到暂存区git add .\n\n将暂存区的文件提交git commit -m &quot;提交信息&quot;\n\nadd commit 进行合并操作git commit -a -m &quot;修改文件&quot;\n\n查看提交历史git loggit log --pretty=oneline\n\n版本回退git reset  --hard HEAD^git reset  --hard HEAD~1000git reset  --hard 2d44982\n\n管理远程仓库git remote -v  //查看远程仓库地址git remote add &lt;shortname&gt; &lt;url&gt;  //添加远程仓库，让本地仓库和远程仓库建立连接git remote rename gitlab glab  //重命名远程仓库git remote remove gitlab  //移除远程仓库\n\n将代码push到远程仓库：将本地仓库的代码推送到远程仓库中默认情况下是将当前分支（比如master）push到origin远程仓库的；git pushgit push origin master\n\n从远程仓库fetch代码：从远程仓库获取最新的代码默认情况下是从origin中获取代码；git fetchgit fetch origin获取到代码后默认并没有合并到本地仓库，我们需要通过merge来合并；git merge\n\n从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作git pull ===git fetch + git merge(rebase)\n\n合并冲突Git标签（tag） - 创建taggit tag v1.0git tag -a v1.1 -m &quot;附注标签&quot;\n\npush taggit push origin v1.0git push origin --tags\n\n删除本地taggit tag -d v1.1\n\n删除远程taggit push origin  --delete v1.1\n\n切换到目标tag版本git checkout v1.0\n\nGit创建分支git branch testing\n\nGit切换分支git checkout testing\n\n创建分支同时切换git checkout -b testing\n\n分支开发与合并git checkout mastergit merge hotfix\n\n查看和删除分支git branch  查看当前所有分支git brabch -v  查看最后一次提交git branch --merged 查看所有合并到当前分支的分支git branch --no-merged 查看所有没有合并到当前分支的分支\n\n远程分支的管理git push &lt;remote&gt; &lt;branch&gt;  推送远程分支git checkout --track &lt;remote&gt;/&lt;branch&gt; 跟踪远程分支git push origin --delete &lt;branch&gt; 删除远程分支\n\nGit rebase用法git checkout experimentgit rebase mastergit checkout mastergit merge experiment\n\n","categories":["git","note"]},{"title":"操作系统","url":"/2022/09/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":"","categories":["操作系统"]},{"title":"数据结构","url":"/2022/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"","categories":["数据结构"]},{"title":"数组转换成树形解构","url":"/2022/09/05/%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A0%91%E5%BD%A2%E8%A7%A3%E6%9E%84/","content":"","categories":["javascript","原理"]},{"title":"杀手级的TypeScript功能：const断言","url":"/2022/10/06/%E6%9D%80%E6%89%8B%E7%BA%A7%E7%9A%84TypeScript%E5%8A%9F%E8%83%BD%EF%BC%9Aconst%E6%96%AD%E8%A8%80/","content":"const assertions是ts3.4新增的功能，们可以用这个新功能省略很多繁琐的类型声明\nconst assertionsconst x = &#123; text: &quot;hello&quot; &#125; as const;\n\n官方的解释是\nconst断言是ts3.4新增的一种构造函数，他的语法是用const代替type的类型断言，例如 123 as const），当我们使用const进行断言literal expression的时候，会做以下处理\n\n该表达式的字面量类型不会被扩展\n对象字面量获取的是readonly属性\narray literals将会变成readonly tuples\n\n官方的解释会比较困惑\nNo type widening for literal types [文字类型没有类型扩展]通过const断言，文字类型不会被扩展为更加宽泛的类型，当我们使用const声明字面量变量的时候，类型就会等于右侧的字面量\nconst x = &#x27;x&#x27;; // x has the type &#x27;x&#x27;\n\nconst关键字可以确保不会重新分配变量类型并且会保证更加严格的类型定义，但是，如果我们使用let替代const的时候，let就会变成更加宽泛的类型\nconst x = &#x27;x&#x27;; // has the type &#x27;x&#x27; let y = &#x27;x&#x27;;   // has the type string\n\ny会扩展为更加宽泛的值，允许分配其他值给y,而x只能是字面量的x,如果我们向让let也可以这么做，就可以使用const断言\nlet y = &#x27;x&#x27; as const; // y has type &#x27;x&#x27;\n\nobject literals get readonly properties [对象字面量获得只读属性]const action = &#123; type: &#x27;INCREMENT&#x27;, &#125; // has type &#123; type: string &#125;\n\nconst声明对象时，却依然会出现属性的扩展\n如果你熟悉使用redux的时候，action用于执行修改变量，对外界来说，redux是全局不可修改的state store,state只能通过action在reducer中进行修改，reducer是纯函数，他会返回更新之后的state的版本，在action被dispatch之后、\n在redux中，通常情况下，是在actionCreator中创建action,actionCreators是纯函数，它会返回redux action的字面量的对象，以及提供参数给action\n用一个例子进行解释说明\nconst setCount = (n: number) =&gt; &#123;  return &#123;    type: &#x27;SET_COUNT&#x27;,    payload: n,  &#125;&#125;const action = setCount(3)// action has type// &#123; type: string, payload: number &#125;\n\ntype的类型应该是字面量的，但是会被自动转换成更加宽泛的类型，在TS3.4以前，我们需要显示的指定返回值类型才可以达到类似的效果，\ninterface SetCount &#123;  type: &#x27;SET_COUNT&#x27;;  payload: number;&#125;const setCount = (n: number): SetCount =&gt; &#123;  return &#123;    type: &#x27;SET_COUNT&#x27;,    payload: n,  &#125;&#125;const action = setCount(3)// action has type SetCount\n\nts3.4以后使用const断言也可以实现同样的效果,而且是只读属性的\nconst setCount = (n: number) =&gt; &#123;  return &lt;const&gt;&#123;    type: &#x27;SET_COUNT&#x27;,    payload: n  &#125;&#125;const action = setCount(3);// action has type//  &#123; readonly type: &quot;SET_COUNT&quot;; readonly payload: number &#125;;\n\n对于使用了联合类型的action,在没有使用const断言的时候会比较麻烦\ninterface SetCount &#123;  type: &#x27;SET_COUNT&#x27;;  payload: number;&#125;interface ResetCount &#123;  type: &#x27;RESET_COUNT&#x27;;&#125;const setCount = (n: number): SetCount =&gt; &#123;  return &#123;    type: &#x27;SET_COUNT&#x27;,    payload: n,  &#125;&#125;const resetCount = (): ResetCount =&gt; &#123;  return &#123;    type: &#x27;RESET_COUNT&#x27;,  &#125;&#125;type CountActions = SetCount | ResetCount\n\n通过使用const的用法\nconst setCount = (n: number) =&gt; &#123;  return &lt;const&gt;&#123;    type: &#x27;SET_COUNT&#x27;,    payload: n  &#125;&#125;const resetCount = () =&gt; &#123;  return &lt;const&gt;&#123;    type: &#x27;RESET_COUNT&#x27;  &#125;&#125;type CountActions = ReturnType&lt;typeof setCount&gt; | ReturnType&lt;typeof resetCount&gt;;\n\nArray literals become readonly tuplesconst action = &#123;  type: &#x27;SET_HOURS&#x27;,  payload: [8, 12, 5, 8],&#125;//  &#123; type: string; payload: number[]; &#125;action.payload.push(12) // no error\n\naction。payload是可以修改的\n如果使用了const断言\nconst action = &lt;const&gt;&#123;  type: &#x27;SET_HOURS&#x27;,  payload: [8, 12, 5, 8]&#125;// &#123;//  readonly type: &quot;SET_HOURS&quot;;//  readonly payload: readonly [8, 12, 5, 8];// &#125;action.payload.push(12);  // error - Property &#x27;push&#x27; does not exist on type &#x27;readonly [8, 12, 5, 8]&#x27;.\n\n总结let obj = &#123;  x: 10,  y: [20, 30],  z: &#123;    a:      &#123;  b: 42 &#125;  &#125; &#125; as const;\n\n转换成\nlet obj: &#123;  readonly x: 10;  readonly y: readonly [20, 30];  readonly z: &#123;    readonly a: &#123;      readonly b: 42;    &#125;;  &#125;;&#125;;\n","categories":["typescript","note"]},{"title":"深拷贝的实现方式","url":"/2022/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","content":"// 判断是否是对象function isObject(value) &#123;  const valueType = typeof value;  return value != null &amp;&amp; (valueType === &quot;object&quot; || valueType === &quot;function&quot;);&#125;function deepClone(originValue) &#123;   // 数据类型是symbol  if (typeof originValue === &quot;symbol&quot;) &#123;    return Symbol(originValue.description);  &#125;  // 原始数据类型直接返回  if (!isObject(originValue)) &#123;    return originValue;  &#125;  // 判断是否是function  if (typeof originValue === &quot;function&quot;) &#123;    return originValue;  &#125;  // 判断是否是set类型  if (originValue instanceof Set) &#123;    const newSet = new Set();    for (const item of originValue) &#123;      newSet.add(deepClone(item));    &#125;    return newSet;  &#125;  // 判断是否是Map类型  if (originValue instanceof Map) &#123;    const newMap = new Map();    for (const [key, value] of originValue) &#123;      newMap.set(key, deepClone(value));    &#125;  &#125;  // 判断是否是Array  const newOBj = Array.isArray(originValue) ? [] : &#123;&#125;;  for (const key in originValue) &#123;    newOBj[key] = deepClone(originValue[key]);  &#125;  // 单独遍历Symbol  const symbolKeys = Object.getOwnPropertySymbols(originValue);  for (const symbolKey of symbolKeys) &#123;    newOBj[Symbol(symbolKey.description)] = deepClone(originValue[symbolKey]);  &#125;  return newOBj;&#125;\n\n当拷贝的对象中出现循环引用时// 判断是否是对象function isObject(value) &#123;  const valueType = typeof value;  return value != null &amp;&amp; (valueType === &quot;object&quot; || valueType === &quot;function&quot;);&#125;function deepClone(originValue, map = new WeakMap()) &#123;  // 数据类型是symbol  if (typeof originValue === &quot;symbol&quot;) &#123;    return Symbol(originValue.description);  &#125;  // 原始数据类型直接返回  if (!isObject(originValue)) &#123;    return originValue;  &#125;  // 判断是否是function  if (typeof originValue === &quot;function&quot;) &#123;    return originValue;  &#125;  // 判断是否是set类型  if (originValue instanceof Set) &#123;    const newSet = new Set();    for (const item of originValue) &#123;      newSet.add(deepClone(item));    &#125;    return newSet;  &#125;  // 判断是否是Map类型  if (originValue instanceof Map) &#123;    const newMap = new Map();    for (const [key, value] of originValue) &#123;      newMap.set(key, deepClone(value));    &#125;  &#125;  // 如果有循环引用的对象，return  if (map.get(originValue)) &#123;    return map.get(originValue);  &#125;  // 判断是否是Array  const newOBj = Array.isArray(originValue) ? [] : &#123;&#125;;  map.set(originValue, newOBj);  for (const key in originValue) &#123;    newOBj[key] = deepClone(originValue[key], map);  &#125;  // 以symbol作为key  const symbolKeys = Object.getOwnPropertySymbols(originValue);  for (const symbolKey of symbolKeys) &#123;    newOBj[Symbol(symbolKey.description)] = deepClone(      originValue[symbolKey],      map    );  &#125;  return newOBj;&#125;// const info = &#123;//   name: &quot;why&quot;,//   age: 18,//   friend: &#123;//     name: &quot;kobe&quot;,//     address: &#123;//       name: &quot;洛杉矶&quot;,//       detail: &quot;斯坦普斯中心&quot;,//     &#125;,//   &#125;,//   // self: info// &#125;;// info.self = info;// let newObj = deepClone(info);// console.log(newObj);// console.log(newObj.self === newObj);const set = new Set([&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;]);const s1 = Symbol(&quot;s1&quot;);const s2 = Symbol(&quot;s2&quot;);const info1 = &#123;  name: &quot;why&quot;,  age: 18,  friend: &#123;    name: &quot;kobe&quot;,    address: &#123;      name: &quot;洛杉矶&quot;,      detail: &quot;斯坦普斯中心&quot;,    &#125;,  &#125;,  // 1.特殊类型: Set  set: set,  // 2.特性类型: function  running: function () &#123;    console.log(&quot;running~&quot;);  &#125;,  // 3.值的特殊类型: Symbol  symbolKey: Symbol(&quot;abc&quot;),  // 4.key是symbol时  [s1]: &quot;aaaa&quot;,  [s2]: &quot;bbbb&quot;,&#125;;info1.self = info1;const newObj1 = deepClone(info1);console.log(newObj1);\n\n","categories":["javascript","原理"]},{"title":"前端系统课笔记","url":"/2022/08/14/%E7%AC%94%E8%AE%B0/","content":"1.margin-left的值如果是百分比时，相对于他的包含块的宽度的百分比，即他的父元素2.性能优化点：link ref=`dns-prefetch`dns预获取，在资源加载之前获取到真实的ip地址3.rgb R红 G绿 B蓝  \\#ff0000 十六进制表示法  rgb(0，0，0) 十进制表示4.image/vedio是行内可替换元素，不是行内块级元素5.line-hight是继承属性6.#表示多个属性是以逗号分隔7.+表示多个属性是以空格分隔8.text-align 时将行内元素相对于父级块元素进行居中例如img 文本 input等9.text-ident和width以em为单位的时候是相对于自身的，font-size可以从父元素继承，如果父元素设置了font-size则会继承下来并相对于自身10.普遍兄弟选择器只能选中下面的所有兄弟元素11.script标签放到html的头部时要加window.onload12.伪类hover,link,visited,active的执行顺序 LVHA13.除了a标签，hover和active也可以用在其他元素上14.a元素没有设置伪类，默认所有伪类都是相同的设置15.::first-line选中首行元素::first-letter选中首字母元素之间的间隙默认是换行符，去掉换行符可以::after&#123;content:url(&quot;./image/icon.svg&quot;);//可以这样来添加图片color:green&#125;&lt;p&gt;这是上面代码的实现&lt;br /&gt;  我们有一些 &lt;span data-descr=&quot;collection of words and punctuation&quot;&gt;文字&lt;/span&gt; 有一些  &lt;span data-descr=&quot;small popups which also hide again&quot;&gt;提示&lt;/span&gt;。&lt;br /&gt;  把鼠标放上去&lt;span data-descr=&quot;not to be taken literally&quot;&gt;看看&lt;/span&gt;。&lt;/p&gt;//自定义属性::after伪元素，attr()CSS表达式和一个自定义数据属性 data-descr 创建一个纯CSS content: attr(data-descr);   16.怎么画0.5px的线 17.常见的继承属性：font-size,font-weight,font-family,line-height,color,text-align一般和文本有关的 1.  css的权重 important 10000 内联选择器 1000 id选择器 100 类选择器，属性选择器，伪类 10 元素选择器，伪元素 1 通配选择器  019.img，vedio,input是行内替换元素  和其他行内元素在一行显示，可以设置宽高\t行内非替换元素不可以设置宽高20.伪元素是行内非替换元素，不可以设置宽高，必须转成行内块级元素和块级元素，在使用伪元素过程中必须加content21.不要在p元素里面放块元素22.行内元素不要放块级元素，只能放行内元素23.设置元素不可见的方式\t1.display:none 不占据任何空间\t2.visibility:hidden占据空间不可见\t3.设置颜色透明度\t4.background:transparent可以是背景颜色透明\t5.opacity:1,可以设置透明度，但是会使子元素也会变透明，具有穿透性24.padding:10px 20px 30px 写三个值得时候，左边没有值，用右边的替代25.border-radius百分比圆角水平方向是width+border的百分比，圆角垂直方向是height+border的百分比\tborder-radius:50%是个圆，超过百分之50%也是圆，超过50%，无效26.margin\tmargin的传递 左右margin不传递\tmargin-top的传递 如果块级元素顶部线和父元素的顶部线重叠，那么这个块级元素的margin-top就会传递给父元素\tmargin-bottom\t如果块级元素的底部线和父元素的底部线出现重叠，且父元素高度为auto时，会传递\t解决：1.父元素设置border\t\t 2.父元素使用padding\t\t 3.触发bfc\t上下margin的折叠 \t兄弟块元素上下两个margin合并成一个margin，折叠后取较大的值。解决方法只设置一个\t父子之间折叠，也会出线相同的情况27.outline  外轮廓不占据空间，默认显示在border外面 outlone:none\t\t可以去除a元素，input元素focus状态下的默认外轮廓\t28.box-shadow:offset-x offset-y blur(模糊度) 向外扩散的值 color ，多个阴影以逗号分隔，会叠加29.text-shadow:文字添加阴影27.行内非替换元素的注意事项\t1.不可以设置width和height\t2.设置margin-top.margin-bottom不生效，margi-left和margin-right生效\t3.设置padding-top,padding-bottom会不等高，且不占据空间，设置padding-right和padding-left生效\t4.设置border和padding给相同效果28.html5语义化标签\t&lt;header&gt;\t&lt;nav&gt;\t&lt;section&gt;\t&lt;artical&gt;\t&lt;aside&gt;\t&lt;footer&gt;29.vedio和audio时行内替换元素   在针对不同的播放格式写法   &lt;vedio src=&quot;&quot;&gt;   \t\t&lt;source src=&quot;.../....mp4&quot;&gt;&lt;/source&gt;   \t\t&lt;source src=&quot;.avi&quot;&gt;&lt;/source&gt;   \t\t&lt;source src=&quot;&quot;&gt;&lt;/source&gt;   \t\t&lt;p&gt;该浏览器不支持&lt;/p&gt;   &lt;/vedio&gt;30.data-*自定义属性，可以html和js中进行数据传递31.white-space:normal|nowrap|pre|.....32.text-overflow:clip|esclip text-overflow必须在overflow不是visible才生效33.css函数\t1.var 定义CSS变量\t\t属性名要以--开头\t\thtml&#123;\t\t\t--main-color:#fffff\t\t&#125;\t\tdiv&#123;\t\t\tcolor:var(--main-color)\t\t&#125;\t2.calc 计算CSS值，\t3.blur  高斯模糊--毛玻璃效果  blur(radius)可以应用于图片或者元素，radius模糊半径\t\t\t可以和filter一起使用。filter:blur(5px)，会使所有子元素都有高斯模糊\t\t\t图片的高斯模糊也可以在图片上添加一个遮盖层，用定位元素\t\t\t父元素：position:relative\t\t\t.cover&#123;\t\t\t\tposition:absolute\t\t\t\ttop:0\t\t\t\tleft:0\t\t\t\tright:0\t\t\t\tbottom:0\t\t\t\tbackground:rgba(0,0,0,.5)//透明效果\t\t\t\tbackground-filter:blur(5px)//高斯模糊\t\t\t&#125;\t4.gradient 颜色渐变函数 是一种&lt;image&gt;css数据类型的子类型，用于图片颜色的过度转变\t  liner-gradient 线性渐变 background-image:linear-gradient(to right top ,red,blue)     34.background背景色对也border,padding有效   color前景色对border也是有效的，border没有设置颜色时，会使用color的值  35.浏览器前缀：-o-,-xv-,-ms-,-mso-,0moz-.-webkit-36.bfc 兄弟块元素margin折叠35.媒体查询36.css单位\tem \trem\tpx\tvw/vh\t%37.less\t定义变量 @mainColor:#ffff\t使用变量 @mainColor\t兼容css\t\t&amp;:hover &amp;::after\tless的运算\tless的混合(Mixins)\t    .box2(@borderwidth:1px,@borderColor:red)&#123;\t    \tborder:@borderwidth solid @borderColor\t    &#125;\t    .box-size&#123;\t    \twidth:100px;\t    \theight:200px\t    &#125;\t\t.box&#123;\t\t//混入方式,可以传参\t\t\t.box2(2px,green)\t\t\twidth:.box-size[width]//混入和映射结合使用\t\t\t&amp;:extend(.box-size) //继承\t\t&#125;\t\t\tless内置函数\t\t.box&#123;\t\t\tcolor:color(red)//将转换成16进制\t\t\twidth:convert(100px,&quot;in&quot;)单位准换，转成英寸\t\t\tfloor()向下取整\t\t\tceil()向上取整\t\t&#125;\tless的作用域：查找一个变量时，会在本地和混入先查找，然后再父级查找\tless的注释\tless的导入 import\t38.移动端适配   视口viewport   \t布局视口   \t视觉视口   \t理想视口   \t&lt;meta name=&quot;viewport&quot; content=&quot;width=980px&quot;&gt;//修改布局视口的宽度，对pc端无效   \t&lt;meta name=&quot;viewport&quot; content=&quot;device-width，initial-scal=1.0,user-scalable=no   \tminimun-scal=1.0,maximun-scale=1.0   \t&gt;39.\tcss的相对单位em,是相对于自身的font-size来进行定位的，如果自己已经定义了font-size的px，则用自身的font-size,否则就继承自父元素的font-size\trem是基于根元素的字体的大小\tvw是视窗宽度的1%\tvh是视窗高度的1%40.再pc端，布局视口和视觉视口是同一个，不用区分\t默认情况下，一个在PC端的网页在移动端会如何显示呢？ 第一，它会按照宽度为980px来布局一个页面的盒子和内容； 第二，为了显示可以完整的显示在页面中，对整个页面进行缩小我们相对于980px布局的这个视口，称之为布局视口（layout viewport）； 布局视口的默认宽度是980px；\t视觉视口（visual viewport） 如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用户的可见区域中； 那么显示在可见区域的这个视口，就是视觉视口（visual viewport）41.适配方案 – rem+动态html的font-size   使用该方案有两个问题   \t 问题一：针对不同的屏幕，设置html不同的font-size；     问题二：将原来要设置的尺寸，转化成rem单位；    方案一：媒体查询     可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸；     缺点：    ✓ 1.我们需要针对不同的屏幕编写大量的媒体查询；    ✓ 2.如果动态改变尺寸，不会实时的进行更新；    ◼ 方案二：编写js代码     如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码；     方法：    ✓ 1.根据html的宽度计算出font-size的大小，并且设置到html上；    ✓ 2.监听页面的实时改变，并且重新设置font-size的大小到html上；        rem的单位换算\t方案一：手动换算\t方案二：less/scss函数\t◼ 方案四：VSCode插件\t px to rem 的插件，在编写时自动转化\t◼ 方案四：VSCode插件\t px to rem 的插件，在编写时自动转化三：postcss-pxtorem\t42。meta标签的作用\t可以在head中定义元信息，例如 比如标题title、样式style、link外部资源等；     meta用于定义那些不能使用其他定元相关（meta-related）元素定义的任何元数据信息；    \tmeta 元素定义的元数据的类型包括以下几种：             如果设置了 charset 属性，meta 元素是一个字符集声明，告诉文档使用哪种字符编码。             如果设置了 http-equiv 属性，meta 元素则是编译指令。             如果设置了 name 属性，meta 元素提供的是文档级别（document-level）的元数据，应用于整个页面。            \t例如：robots，author，Copyright，description，keywords            \t 43.link图标 \t&lt;link rel=&quot;icon&quot; href=&quot;https:;;;;&quot; /&gt; \t也可以直接将该favicon.ico直接置于根目录下，不需要使用link来引入，因为大部分浏览器都可以识别 \t \t 44.CSS样式的字符编码 \t开发中推荐在CSS的开头编写@charset指定编码：@import &quot;utf-8&quot; 45.全局属性data-* \tdata设置的属性可以在JavaScript的DOM操作中通过dataset轻松获取到；\t通常用于HTML和JavaScript数据之间的传递；46.&quot;&quot;==null //false\tnull和undefined不能转换成任何数据类型进行比较\t47.const obj=&#123;\t[Symbol.toPrimitive]()&#123;\treturn &quot;123&quot;\t&#125;&#125;48.转换成boolean的方式\tBoolean(a)\t!!a49.switch case 是严格匹配===，还要防止case穿透50.npxnpx 是 npm v5.2.0 引入的一条命令（ npx ），是一个 npm 包执行器。我们可以使用 npx 来执行各种命令。主要有以下特点：临时安装可执行依赖包，不用全局安装，不用担心长期的污染。可以执行依赖包中的命令，安装完成自动运行。自动加载 node_modules 中依赖包，不用指定 $PATH 。可以指定 node 版本、命令的版本，解决了不同项目使用不同npx 执行流程如下：到 node_modules/.bin 路径检查对应的命令是否存在，找到之后执行；没有找到，就去环境变量 $PATH 里面，检查对应命令是否存在，找到之后执行;还是没有找到，自动下载一个临时的依赖包最新版本在一个临时目录，然后再运行命令，运行完之后删除，不污染全局环境。51.函数默认的返回值是undefined52.递归53.斐波那契数列\tfunction fibonacci(n)&#123;    if(n===1||n===2) return 1    return fibonacci(n-1)+fibonacci(n-2)  &#125;54.立即执行函数\t1.会立即执行\t2.函数有独立的作用域，可以避免外界访问或者修改内部的变量，\t3.可以有参数和返回值\t4.匿名函数多种写法\t\t\t(function()&#123;\t\t\t\t\t\t&#125;)()            // 匿名函数多种写法            (function (fn) &#123;              console.log(&quot;立即执行函数&quot;);            &#125;)();            // + - ！都可以，但是不要这样用            +(function foo() &#123;              console.log(&quot;立即执行函数&quot;);            &#125;)();\t5.应用：。\t\t1.解决命名冲突的问题，防止全局变量的命名冲突\t\t2.const btnRtm1 = document.querySelectorAll(&quot;.btn&quot;);for (var i = 0; i &lt; btnRtm.length; i++) &#123;  var btn = btnRtm[i];  (function (m) &#123;    btn.onclick = function () &#123;      console.log(m);    &#125;;  &#125;)(i);&#125;// 打印 4 4 4 4 .....// 立即执行函数可以解决上述问题还有for循环中有异步代码例如setTimeout，也可以用let解决// 因为在如下代码中，但执行onclick执行的时候，此时for循环已经执行完，i已经变成btnRtm.length 所以执行代码永远是4 4 4 ，而使用立即执行函数，会每次将i作为参数传入立即执行函数中，尽管i执行完之后已经变成4，但是m存储这0 1 2 3 const btnRtm = document.querySelectorAll(&quot;.btn&quot;);for (var i = 0; i &lt; btnRtm.length; i++) &#123;  var btn = btnRtm[i];  (function (m) &#123;    btn.onclick = function () &#123;      console.log(m);    &#125;;  &#125;)(i);&#125;// 打印 1 2 3 4....const btnRtm3 = document.querySelectorAll(&quot;.btn&quot;);for (let i = 0; i &lt; btnRtm.length; i++) &#123;  var btn = btnRtm[i];  btn.onclick = function () &#123;    console.log(i);  &#125;;&#125;// 打印1 2 3 4 .....55.js代码规范56.Object的key是字符串57.Object可以使用delete来删除属性，Object.name/Object[&quot;name&quot;]来获取，或者修改属性，obj[name]是计算属性，name是一个变量58.Object 遍历可以使用forin,或者Object.keys()   59.栈内存和堆内存\t原始数据类型是在栈内存\t引用类型实在堆内存60.包装类型，   当有包装类型的原始数据类型可以调用方法，是因为js引擎会将原始类型转换成包装类调用对应的方法   123..toString(2)//转换成二进制   toFixed(2)保留两位小数。是四舍五入   parseInt===Number.parseInt     String类   length   str[0]   charAt(0)//字符位置   for   for...of   for...in   字符串是不可变的   \t例如：var str = &quot;name&quot;;\t\t str[0] = &quot;v&quot;;\t\t console.log(str);//name\t\t \t\t var str = str.toUpperCase();\t\t\tconsole.log(str);//这是新的字符串，不是原来的\tstr.indexOf(searchString,fromIndex)//返回值是索引值\tstr.includes()\tstr.startsWidth(&quot;1&quot;)//是否以1开头\tstr.endsWidth()\tstr.replace()\tstr.slice()\tstr.substring()\tstr.substr()\t字符串拼接+，cocat()\ttrim()\tsplit()\treplace()替换，是纯函数61.Array\tsplice()//添加，删除，替换\tpop\tpush\tshift\tunshift\tarr.length可以获得数组的长度，修改数组的长度，删除数组\t如果arr.length为6\tarr.length=2//可以删除剩余的元素\tarr.length=0可以删除所有元素\tarr.length=8//可以扩容\t\tarr.slice()\tarr.join()\tarr.concat()\tarr.indexOf()\tarr.find(arr.find(callback[, thisArg]) callback(element,index,array) //会返回匹配到的元素，匹配到多个的时候会返回第一个   find 方法不会改变数组\tarr.findIndex( \t)\t//实现find\tArray.prototype.myFind = function (callback, thisArg) &#123;  for (let i = 0; i &lt; this.length; i++) &#123;    if (callback.call(thisArg, this[i], i, this)) &#123;      return this[i];    &#125;  &#125;&#125;;//实现forEach\tArray.prototype.MyForEach = function (callback, thisArg) &#123;  for (let i = 0; i &lt; this.length; i++) &#123;    callback.apply(thisArg, [this[i], i, this]);  &#125;&#125;;includes()arr.sort()// 默认是降序arr.sort((item1, item2) =&gt; &#123;  return item1.age - item2.age;&#125;);console.log(arr);// 升序arr.sort((item1, item2) =&gt; &#123;  return item2.age - item1.age;&#125;);console.log(arr);arr.reverse()arr.filter()Array.prototype.myfilter = function (callback, thisArg) &#123;  let newArr = [];  for (let i = 0; i &lt; this.length; i++) &#123;    if (callback.call(thisArg, this[i], i, this)) &#123;      newArr.push(this[i]);    &#125;  &#125;  return newArr;&#125;;arr.map()arr.reduce()Date类型new Date()Date.now()//当前事件的时间戳date.getTime()//将时间转换成时间戳date.valueOf()//也是一样+date//也可以将字符串转换成时间戳var dateString = &quot;2020-5-15&quot;;console.log(new Date(dateString).getTime());console.log(Date.parse(dateString));==================================================================================Dom62.所有节点都继承自EventTarget63.document对象-可以获得整个网页node节点\tvar html=document.documnetElement\tvar body=documnet.body\tbody,html,body都是documnet的属性\t获取所有节点的导航 var bodyEl=document.body\t获取所有子节点 bodyEl.childNodes  换行符也属于text节点，注释是comment节点\t获取下一个兄弟节点 bodyEl.nextSibling\t前兄第节点 preSibling\n\n打印body的子节点\n\n\n64.获取子元素\tbodyEl.children65.获取第一个子节点  bodyEl.firstElementChild    bodyEl.children[0]  \tbodyEl.nextElementSibling66.Document和Element的关系   没有关系。document.body,body是他的属性，不是继承类，body:document.querySelectAll(&quot;body&quot;) ,所以Documnet和Element不是继承的关系，ELment是body的值67.table和form之间的导航68.document.getElementById(&quot;&quot;)   documnet.querySelector(&quot;&quot;)   document.querySlectorAll(&quot;&quot;)   document.getElementsByName(&quot;&quot;)   document.getElementsByTagName(&quot;&quot;)   document.getElementsByClassName(&quot;&quot;)//这3个是实时的69.NodeList是类数组对象，但是可以用forEach,可以用Array.from()转换成array70.节点类型判断\t通过childNodes获取的节点判断节点类型用nodeType属性 1.元素节点 3.文本 8，注释节点71.nodeName获取节点名称，tagName元素名72.data用于非元素节点获取数据 innerHTML 获取元素 textContent获取文本\t设置的时候，innerHTML和innerContent都可以设置文本，innerContent设置元素不会被解析为html元素，会当作普通文本\tinnerHTML 将会删除所有该元素的后代并以给出的 htmlString 替代\t不是追加73.outerHTML会获取本身及其子元素74.常见全局属性 id style title class hidden:相当于设置display:none\ton+事件75.attribute\thtml定义的是标准attribute\t自定义的属性是非标准attribute\t\t所有attribute都支持的方法\t\t\telement.hasAttribute(e)\t\t\telement.getAttribure(e)\t\t\telement.setAttribute(e)\t\t\telement.removeAttribute(e)\t\t\telement.attributes-&gt;like array\t\t\t\t\t\t这些对大小写不敏感，而且返回值都是string76.property对象中的属性称为property元素中的属性称为attribute标准的attribute中在对应的对象模型中都有对用的propertyproperty和attribute会相互影响使用点语法也可以获得元素的属性77.className和classList\tclassList是可迭代对象78.style在js中要使用驼峰\t多个样式可以使用style.cssText=&quot;&quot;这个不用写驼峰，但是会覆盖，不推荐78.style的读取getComputedStyle()，ele.style只能读取内联样式，就是直接在元素上定义的样式，widow.getComputedStyle(ele,[pseudoElt])可以读取所有的css属性，包括外部样式，但是getComputedStyle是只读属性79.data-*80.var el=document.createElement(&quot;element&quot;)//创建元素\tel.className=&quot;&quot;\tel.classList.add(&quot;&quot;)\tboxel.append(el)//向父元素插入创建的元素，默认是插入最后\tboxel.prepend(el)//添加到父元素的里面的最前面\tboxel.before(el)//添加到元素的前面\tboxel.after(el)//添加到元素后面\tboxel.replacewith(...node|string)//替换元素\tappendChild,insertbefore这些方法比较旧了81.el.remove()//将自己移除82.克隆var newEl=el.cloneNode()//默认是不会克隆子节点cloneNode(true)会克隆子节点83.获取元素的宽高 ele.width ele.height84.clientWidth:元素content+padding(不包含滚动条)\tclientTop:border-top的宽度。clientLeft\toffsetWidth:元素的完整宽度content+border+padding\toffsetLeft 距离父元素左边的距离 offsetTop\tscrollHeight 元素可滚动的高度\tscrollTop 滚动条滚动的距离85.window的大小和滚动   window.outerWidth//   window.innerWidth//窗口的宽度，不包括调试窗口和工具栏   document.doeumnetElement.offsetWidth document.doeumnetElement.offsetHeight   window.scrollX  获取x轴的滚动位置 window.scrollY Y轴的滚动位置  也可以用别名pagexOffset  pageYOffset   设置滚动的位置 window.scrollBy(x,y)//在原来的位置基础上叠加滚动的位置   \twindow.scrollTo(x,y)//滚动到绝对的位置，到了位置不会变   \twindow.onscroll//监听滚动   \t86.事件\ton+event\tele.addEventListener(&quot;event&quot;,callback)87.事件流\t事件冒泡\t事件捕获\t捕获阶段-》目标阶段-》冒泡阶段88.event常见属性方法\tevent.type:事件类型\tevent.target:目标元素\tevent.currentTarget:绑定事件的元素\tevent.offsetX\tevent.clientX\tevent.pageX\tevent.screenX\ttarget和currentTarget的区别\t\ttarget事件发生的对象，currentTarget是事件绑定的对象，如果\t\t如果绑定事件的元素和触发事件的元素相同时，target===currentTarget\tevent.preventDefault()\tevent.propagetion()\t\ton+event中普通函数中this指向绑定事件的元素。addEentListener()也是一样89.EventTarget类\t所有节点，元素都继承自eventtarget，window也是\teventTarget.removeEventListener(event,callbackName,)\teventTarget.dispatchEvent()90.事件委托91.import * from 是否包含export default\texport &#123;&#125;和export const a ,export const b有区别吗92.&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;\tbox.click()//如果是id，也可以这样写但是不推荐92.常见的鼠标事件\tonclick //只能接受event作为唯一的参数，且不用再调用的时候写\toncontextmenu\tonmousedown\tonmouseup\tonmousemove93.mouseover和mouseenter的区别\tmouseenter和mouseleave\t不支持冒泡\t进入子元素依然属于该元素只会触发子元素的mouseenter，父元素没反应\tmouseover和mouseout\t支持冒泡94.键盘事件\tonkeydown\tonkeypress\tonkeyup\t\tevent.code \tevent.key95.onfocus和onblur96.oninput和onchange99.表单事件 onsubmit onreset100.onload和DOMContentLoaded101.onresize102.定时器\tsetTimeout和setInterval是window的方法103.ontransitioned监听动画的结束后调用104.tab切换中切换.active的方法\t1.for循环\t2.使用documnet.queryslector(&quot;.active&quot;)修改\t3.使用在外面进行变量记录105.BOM浏览器对象模型106.node:global==lobalThis\twindow:window==globalThis\t放到window的属性全局都可访问\t用var申明的全局对象都放到window对像中\tvar openWin=window.open(&quot;&quot;)//打开网址\twindow.close()//只能关闭通过open()打开的新的窗口107.window常见事件\twindow.onfocus\twindow.onblur\twindow.onhashchange108.location对象属性，用于表示window当前连接url信息\tlocation.href//完整url\t//url信息\tlocation.hostname\tlocation.host\tloaction.protocol\tlocation.port\tlocation.pathname\tlocation.hash\tloacation.search\t//location方法\tloacation.assign()//打开新的网页，是加入历史记录站，可以返回\tlocation.replace()//替代当前url,不可以返回\tloaction.reload()//重新加载109.URLSearchParams\tvar searchParams=new URLSearchParams(str)\tget(&quot;name“)\tappend(&quot;address&quot;,&quot;zzzz&quot;)\thas()\tset()\tURLSearchParams可以使用for...of\t中文使用encodeURLComponment和decodeURLComponment进行编解码\tfor (const [key, value] of searchParams) &#123;&#125;\tfor (const [key, value] of searchParams.entries()) &#123;&#125;110.history//属性\thistory,length\thistory.state//修改history\thistory.pushState(&#123;name:&quot;mike&quot;,age:18&#125;)\thsitory.back()\thistory.forword()\thistory.go(-2)\treplacestate()111.json\tvar item=JSON.stringfy(item)\tvar item=JSON.parse(item)\tjson的方法还可以实现深拷贝var obj=JSON.parse(JSON.strigfy(obj1))112.protobuf113.&amp;gt; &amp;lt;114.&lt;button onclick=&quot;add()&quot;&gt;按钮&lt;/button&gt;//再元素上事件的写法115./* 设置图片水平方向和垂直方向上自动居中，随着浏览器大小的变化 */.img_center&#123;  position: relative;  transform: translate(-50%,-%50);  left: 50%;  top:50%;&#125;\n\n\n\n\n\n117.this的指向\t1.this的指向是由函数调用执行的时候决定的\t2.this的绑定分为：默认绑定：独立函数调用this是指向window,例如fn()\t\t\t\t\t隐式绑定：对象中this的指向是指向调用的对象，例如obj.fn()\t\t\t\t\t显示绑定:通过call,apply,bind来进行显示绑定下，this指向绑定的对象\t\t\t\t\tnew的绑定：通过new创建的对象，this会指向新创建的对象\t3.this指向的优先级：new&gt;显示绑定&gt;隐式绑定&gt;默认绑定\t4.箭头函数是没有this,arguments，是由上层函数作用域来决定，一层一层作用域找\t\t注意：\t\tvar name=&quot;mike&quot;\t\tvar obj=&#123;\t\t\t\t\t\tfoo()&#123;\t\t\t\treturn ()=&gt;&#123;\t\t\t\t\tconsole.log(this.name)\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;//this会先去foo中去找，找不到就去全局作用域，对象中没有作用域\t\t不可以使用显示绑定改变this的指向\t5.显示绑定中如果指向的是一个基本数据类型，如果有包装类型则转换成包装类\t6.setTimeout中的this默认指向window\t7.forEach中this默认指向window，可以通过第二个参数修改\t8.事件绑定中this指向绑定的元素\t9.new不可以和apply和call一起使用\t10.bind的优先级高于call/apply\t11.new的优先级高于bind\t12.间接函数引用：\t\t1.(obj1.foo=obj2.foo)()这样直接调用，this是默认绑定指向window\t\t2.(b=person.sauName)()   //window\t13.foo.apply(null)/foo.apply(undefined)指向window\t\t\t14.箭头函数可以替代var _this=this来替代，可以获得上层作用域118. Array.prototype.slice 来将一个类似于数组的对象（array-like object）转换成一个真正的数组，Aaary.prototye.slice.apply()/bind()119.html解析过程中，遇到css文件会下载，但是不会阻止html的解析，但会阻塞render的渲染过程120.回流和重绘121.script\tdefer js的下载和执行不阻塞Dom tree的构建\tdefer代码执行的时候Dom构建完成，defer会在DomContentLoad以后执行\t多个defer顺序执行\tdefer推荐放在head中\tdefer仅适用于外部脚本，对script的内容会忽略\t\tasync 多个async不能保证顺序执行，不会组设Dom渲染。不能保证DOMContentLoaded之前或者之后执行行\tasync用于独立脚本，没有外部依赖122.函数的执行是在函数执行上下文中执行123.函数的作用域链再函数创建时就确定了。每个执行上下文都有自己的作用域链\n\n\n当查找变量的时候，函数首先会在local中寻找，找不到再去上层作用作用域寻找，而这个函数的上层作用域是Window\n\n124.垃圾回收器\n​\t\t1..引用计数\n​\t\t\t\t\t当一个对象有一个引用指向它时，那么这个对象的引用就+1\n​\t\t\t\t\t当一个对象的引用为0时，这个对象就可以销毁掉\n​\t\t\t\t\t这个算法有一个回答的弊端就是会产生循环引用\n​\t\t2.标记清除\n​\t\t3.标记整理\n​\t\t4.分代收集\n​\t\t5.增量收集\n​\t\t6.闲时收集\n125.闭包\t1.狭义：函数引用外层函数的自由变量就是闭包。\t2.通过返回一个函数，外部可以通过这个函数访问这个函数所在作用域链的变量，闭包可以突破作用域链126.GUI的渲染和js的执行是在同一个线程，是互斥的127.foo.name,获取函数名\tfoo.length//获取行参个数，不会把剩余参数和默认参数计算在内，\targuments//类数组对象，可以通过下标获取值，有length属性，是可迭代对象，但是本身不可以使用数组的方法，可以通过Array.prototype.map.call(arguments)来使用\targument转array\t1.for循环，将argument一个个放到数组中\t2.Array.from(argumsnets)\t3.[...arguments]\t4.var arr=Array.prototype.slice.call/apply(arguments)//会截取整段，并返回新的数组\t\t或者var arr=[].slice.call/apply(arguments)\t\t箭头函数没有argments,会去上层作用域去找arguments128.剩余参数   剩余参数必须放到最后129.剩余参数和argument的区别\t剩余参数是数组，可以使用所有数组方法，arguments是类数组\t剩余参数只包含没有对应形参的实参，arguments包含所有参数130.纯函数\t相同的输入产生相同的输出，\t不会产生副作用\t不依赖外部变量\t确定输出\t不能修改外部变量\t作用：\t\t只是单纯的实现自己的业务，不需要关注外部的数据变化131.函数柯里化\t就是把接受多个函数的函数变成返回接受单一参数的函数\t\tvar foo=x=&gt;y=&gt;z=&gt;console.log(x+y+z)shiyo132.async默认会返回promise\tasync的返回值会被promise包裹，相当于Promise.resolve()\tawait 后面是一个promsie,则会返回Promise.resolve(res)的值\t如果不是promise，则用Promise.resolve(res)包裹\tawait 使用trycatch捕获异常\t133.封装自动转化成柯里化函数134.组合函数\t组合函数的封装135.Function.prototype.name   Function.prototype.length Function.prototype.displayName136.with(obj)&#123;\tconsole.log(message)//扩展一个语句的作用域链，它首先会去obj里面去找，找不到再去上层作用域找，但是不推荐使用&#125;137.eval()138.严格模式\t开启严格模式的方式\tclass和module会自动开启严格模式\t严格模式的限制\t\t1.无法意外创建全局变量\t\t2.引起静默模式失败\t\t3.不能用with\t\t4.this默认指向undefined,this不会装换成包装类139.Object.defineProperty(obj,prop.descriptor)\t属性描述符的分类\t\t1.数据属性描述符：configurable:表示这个属性是否可删除,默认值是false，使用delete不嫩删除，如果设置为false,则不可以配置了，后续其他属性描述符也不可以使用了。就是Configurable:false,后续不可以对这个属性使用Object.defineProperty配置。\t\tenumerable:是否可以枚举属性，false:forin,Object.keys()这些都不可以美剧，默认是true\t\twritable:是否可以写入，默认是可以写入，设置为false是只读属性\t\tvalue:&quot;mike&quot;,设置属性值\t\t\t\t\t\t如果使用字面量创建对象，则所有属性描述符都是true,object.defineProperty()设置的属性的value\t\t的优先级会比字面量创建的属性设置的值高\t\t2.存取属性描述符\t\tget\t\tset\t\t\t\twiritable,value和get,set不可以同时使用140.Object.defineProperties()//同时设置多个属性描述符141.Object.getOwnPropertyDescriptor(obj, &quot;name1&quot;)//获取某个属性描述符142.Object.getOwnPropertyDescriptors(obj)//获取所有属性描述符143.Object.preventExtensions(obj);//不允许扩展属性144.object.seal(obj)//密封对象，不允许配置和删除属性，增加新的属性145.Object.freeze(obj)//不能修该现有属性，也不能增加新的属性146.原型和原型链\t__proto__是浏览器加，非标准的，要看各个浏览器如何实现，建议使用Object.getPrototypeOf(obj)来获取对象的原型\t__proto__隐式原型\tprototype显式原型\t所有的对象都有隐式原型，函数有隐式原型和显示原型\t\t\t当对象获取值的时候p1.address如果实例对象没没有这个属性则会到他的原型练上去寻找\t当对象属性赋值的时候，如果该属性不存在则会在当前对象中新建一个属性赋值，不会修改原型链上的属性的值\tp1.address=&quot;us&quot;//这样不会对原型链上的该属性进行修改\t如果要对原型的属性进行修改：Person.prototype.address=&quot;japan&quot;\tPerson.prototype=&#123;\t\tmessage:&quot;章&quot;,\t\tinfo:&#123;&#125;,\t\teating:function()&#123;\t\t\t\t&#125;,\t\tconstructor:Person\t&#125;//修改Person的显示原型指向新的对象\tp1.__proto_===Object.prototype\tconstructor应该是不可以枚举的，要用Object.deineProperty()来修改定义\t原型链：实例对象在查找某个属性的时候，他先去自己对象寻找，然后再去原型链里面去找，直到找到null为止147.面向对象的特性:封装，继承，多态148.使用new关键字创建对象的过程\t1.创建一个空对象\t2.让这个对象的[[prototype]]属性指向该构造函数的prototype对象\t3.让构造函数的中的this指向新创建的对象\t4.执行该构造函数\t5.如果构造函数没有返回一个非空对象，则返回新创建出来的对象149.原型链的继承\t1.Student.prototype=Person.prototype//这种继承虽然可以继承到Person的方法，但是添加student的方法的时候，会添加到Person原型上，对Person和Student都会有影响\t2.原型链继承\tstudent.prototype=new Person()//改善上面一种方法，不会对Person.prototype上的方法进行干扰\t但是，如果有和Person相同的属性的时候例如\tfunction Student(age,gender,name,weight)&#123;\t\tthis.age=age;\t\tthis.gender=gender;\t\tthis.name=name;\t\tthis.weight=weigth\t&#125;\tage,gender属性在pERson里面也有，这样会有代码重复的问题，但是可以获取到自己的age,gender\t如果不写，调用的时候是获取到Person的age和gender,多个实例共享相同的属性了\t3.借用构造函数继承\t  function Student(age,gender,name,weight)&#123;\t  \tPerson.call(this,age,gender)\t  \tthis.name=name;\t\tthis.weight=weigth\t  &#125;\t  使用这个方法可以实现属性的继承\t  将2，3方法结合起来就是组合继承\t  student.prototype=new Person(age,gender)//继承父类的方法\t   function Student(age,gender,name,weight)&#123;\t  \tPerson.call(this,age,gender)//这样没有调用父类的constructor\t  \tthis.name=name;\t\tthis.weight=weigth\t  &#125;\t  缺点：new student的时候构造函数会调两次，一次Person,一次student，拥有两份父类属性，父类的静态属性和静态方法也没有继承\t  4.寄生组合继承\t  function Student(age,gender,name,weight)&#123;\t  \tPerson.call(this,age,gender)\t  \tthis.name=name;\t\tthis.weight=weigth\t  &#125;\t  inhert(Student,Person)\t  Object.assign(Student, Person);//继承静态属性和方法(或者称为类方法或者类属性)150.原型式继承函数\t\t// 使用这个方法来处理Object.create()的兼容性问题        function createObject(o) &#123;          function F() &#123;&#125;          F.prototype = o;          return new F();        &#125;        // 封装工具函数实现继承        function inhert(Subtype, Supertype) &#123;        \t//Subtype.prototype.__proto__=Supertype.prototype        \t//Object.setPrototypeOf(Subtype.prototype,Supertype.prototype)          // Subtype.prototype = createObject(Supertype.prototype);          Subtype.prototype = Object.create(Supertype.prototype);//Object.create()不会调用constructor          Object.defineProperty(Subtype, &quot;constructor&quot;, &#123;            configurable: false,            enumerable: false,            value: Subtype,            writable: true,          &#125;);        &#125;\t  \t  //对象之间的继承\t  \tfunction object(o)&#123;\t  \t\tvar obj=&#123;&#125;\t  \t\tobj.__proto__=o.prototype//Object,setPrototypeOf(obj,o.prototype)\t  \t\treturn obj\t  \t&#125;151.Object是所有类的父类152.obj.hasOwnProperty()、//判断是否在自己身上\t&quot;name&quot; in obj//判断属性是否在obj的里面或者原型链上\tfor in 遍历原型链可枚举属性和方法\tinstanceOf\tPerson.protytype.isPrototypeOf(stu)//判断实例是否在莫格原型链上，判断对象之间的继承153.对象具备__proto__属性。函数有__proto__和prototype属性154.Person.run()//这个调用的是类方法，protoytype上面的方法是实例方法155.class定义类\tclass会有默认的constructor\tclass是的构造函数、原型链的语法糖156.对象中访问器的写法\tvar obj = &#123;  name: &quot;mike&quot;,&#125;;//对象访问器的写法一Object.defineProperty(obj, &quot;name&quot;, &#123;  configurable: true,  enumerable: true,  get() &#123;    return obj.name;  &#125;,  set(value) &#123;    obj.name = value;  &#125;,&#125;);//对象访问器的写法二var obj2 = &#123;  name: &quot;zhang&quot;,  get getName() &#123;    return this.name;  &#125;,  set setName(value) &#123;    this.name = value;  &#125;,&#125;;//三class Person &#123;  constructor(name) &#123;    this._name = name;  &#125;  get name() &#123;    return this._name;  &#125;  set name(value) &#123;    this._name = value;  &#125;&#125;157.类方法/static方法中的this指向类本身158.class的继承 extend159.面向对象的三大特性：封装，继承，多态\t多态的条件：1。必须实现继承\t\t\t  2.必须有父类引用指向子类对象\t\t\t  3.js中可以说到处是多态160.对象字面量增强：\t1.属性的增强\t\tvar name=&quot;why&quot;\t\tvar obj=&#123;\t\t\tname\t\t&#125;\t2.方法的增强\t\tvar obj=&#123;\t\t\teating()&#123;\t\t\t\t\t\t&#125;\t\t&#125;\t3.计算属性名\t\tobj=&#123;\t\t\t[name]:\t\t&#125;\t\t161.数组的解构和对象的解构\tconst [name1,name2,name3]=arr\tconst &#123;age,name,color&#125;=obj\t\tconst [name1,name2,...name3]=arr//将剩下的元素放入name3数组中\t\tconst [name1,name2,name3=&quot;default&quot;]=arr//设置默认值\t\t//对象的解构是没有顺序的，根据Key来进行解构\t//对象解构的重命名\t  const &#123;age:age1,name:name1&#125;=obj//重命名为age1,name1\t //对象解构默认值默认值\t const &#123;age:age1=18,...other&#125;=obj1//可以使用剩余运算符和默认值162.手写apply,call,bind163.词法环境\t词法环境由环境记录和外部词法环境两部分组成\t一个执行上下文关联两个环境\t\tLexicalEnvironment和VariableEnvirment\t\tLexicalEnvironment用于处理let和const\t\tVariableEnvirment用于处理var,function164.https://262.ecma-international.org/8.0/165.let和const\tlet/const不可以重复声明\tconst声明的是引用类型则可以修改const指向的地址的内部的变量，但不可以修改const的指向\tlet/const不会出现变量提升，必须先声明再使用，否则会出现暂时性死区\tlet/const会提前创建出来，但是不可以被访问，只有赋值的时候才可以访问\t暂时性死区取决于代码执行的顺序，和定义的位置没有关系\t\tvar定义的全局变量默认会添加到window上。而let/const不会再window添加任何属性\tvar 会被添加到 object environment record而const /let会被添加到decaretive environment record166.块级作用域\tlet/const/function/class声明是有块级作用域的，\tfoo()//在这之前不可以访问\t&#123;\t\tfunction foo()&#123;&#125;\t&#125;\tfoo()//这样可以访问\t浏览器做了特殊处理，可以让块级作用域里面的函数在块级作用域之后被访问167.立即执行函数会形成闭包，形成自己的作用域168.for(let i=0;i&lt;btnEls.length;i++)&#123;\tvar btnEl=btnEls[i]\tbtnEl.onclick=function()&#123;\tconsole.log(`点击了$&#123;i&#125;按钮`)\t&#125;&#125;//会形成4个词法环境，每个词法环境都会保存着自己的i，function引用外层的词法环境，所以执行完外层词法不会被销毁，当需要i的时候，会往上层寻找，因为当前词法环境中保存着i\n\n\n\n169.模板字符串\t1.普通模板字符串\t2.标签模板字符串170,函数默认值\tfunction foo(arg1,arg2)&#123;\t\targ1=arg1?arg1:0\t\targ1=arg1||0\t\targ1=(arg===null)||(arg1===undefined)?0:arg1\t\t//es6\t\targ1=arg1??&quot;我是默认值&quot;\t&#125;\tfoo(arg1,arg2=&quot;why&quot;)&#123;&#125;//默认参数最好放后面\t剩余参数也是放在后面，如果两个都有的话，剩余参数放后面\tfunction foo(&#123;name,age&#125;=&#123;name=&quot;why&quot;,age=18&#125;)&#123;\tconsole.log(name,age)//对传入的对象进行解构赋值，给默认值\t&#125;\tfunction foo(&#123;name=&quot;why&quot;,age=18&#125;=&#123;&#125;)&#123;\t\tconsole.log(name,age)//对象参数的解构赋值，如果传入的参数\t\t中没有该值name,age，则给name,age赋值\t&#125;\t默认参数不计算在argument内171.箭头函数没有显示原型，不可以作为构造函数，不能通过new创建172.展开运算符\tvar obj=&#123;\t\tname:&quot;why&quot;,\t\tage:18\t&#125;\tfoo(...obj)//这样来用是不可以的，因为函数参数必须是可迭代对象173.浅拷贝：就是将对象里面的内容赋值到新的对象里面，如果对象里面还有对象，则只会复制对象的引用\t\t\t就是浅拷贝只会拷贝第一层对象\t\t\t浅拷贝的方法可以使用展开运算符和Object.assign()\t\t\t174.ele.append()和ele.appendChild()的区别\tappend参数可以是node/string appendChild只能是Node,append()没有返回值，appendChild会返回插入值本身，append可以追加多个字符串、node，而appendChild只能加一个节点175.数值的表示176.Symbol\tconst s1=Symbol()\tconst obj=&#123;\t\t[s1]:&quot;aaaa&quot;\t&#125;\t//对象中key可以是string/Symbol\t由Symbol()生成是独一无二的177.set\t存储任何类型的唯一的值\tconst set=new Set()\tset.add(dd)\tset.has(dd)\tset.size//获取元素数量\tset.delete(value)//删除元素\tclear(set)//清空\tset.forEach()//可以用于数组的遍历\tset.keys()\tset.values()//keys()和values的返回值是相同的\tset.entry()//返回值为[value,value]\tforof\t数组去重\tconst newArr=Array.from(new Set(arr))/[...new Set(arr)]\tSet中NaN===NaN\t178.WeakSet\tWeakSet是弱引用，可以被垃圾回收器回收\tweakSet只能存储对象\tweakSet对对象都是弱引用的，所以不可以遍历\tWeakSet中由has(),add(),delete()\t它和 Set 对象的区别有两点：    与Set相比，WeakSet 只能是对象的集合，而不能是任何类型的任意值。    WeakSet持弱引用：集合中对象的引用为弱引用。 如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 WeakSet 中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的。\n\n\n179.Mapmap也是可迭代对象map可以使用任何数据类型作为key,而Object只可以使用string、symbol作为keyconst map=new Map()map.set(info,&quot;999&quot;)map.delete(info)map.has(info)clear(map)forEachmap.get(info)forof180.Map和Object的区别181.WeakMap\tkey只能是对象，对对象的引用是弱引用，如果没有其他引用引用该对象，他就会被GC回收\tweakMap的key是不可以枚举的，不可以遍历\t不能使用forof,forEach进行遍历\tdelete(key)\tget(key)\thas(key)\tset(key,value)\t\tweakMap可以解决Map可能导致内存泄漏的问题，因为数组会一值引用每一个key,value\t参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap182.Array.prototype.includes(item)183.Math.pow()/**184.Object.values(obj)185.Object.keys(obj)186.Object。entries(obj)//obj可以是对象，数组，字符串\t获取的数组和forin遍历的顺序是一致的，但是不会遍历原型链上的属性和方法187.String.prototype.padStart(总长度,填充字符串)//字符串填充 会返回新的字符串\t例如隐藏只显示身份证的部分数字，其余部分填充*188.Object.getOwnPropertyDescriptors189.Array.prototype.flat(number)//将多维数组扁平化190.Array.prototype.flatMap(callback(currval,index,arr))//相当于先使用map再使用flat(1)进行扁平化191.数组扁平化的方法192.Object.fromEntries(entries)//把entry转换成Obj\t将queryString转换成对象\n\n\n193.空值合并运算符 ??194.str.trim()/trimStart()/trimRight()195.可选链操作符  ?.\t可以替代\tif(obj.friend&amp;&amp;obj.friend.running)&#123;\tobj.friend.running()\t&#125;\t\tobj?.friend?.running?.()196.WeakRef//暂时不建议使用197.逻辑赋值运算符\tmessage=message||&quot;默认值&quot;=&gt;message||=&quot;默认值&quot;\tmessage??=&quot;默认值&quot;\tobj&amp;&amp;obj.friend&amp;&amp;obj.friend.running()198.const new=str.replaceAll()//替换所有匹配到的字符串  原始字符串保持不变。199.str.at(index)200.Object.hasOwn(obj,propKey)//可以替代obj.hasOwnProperty(prop),因为hasOwnProperty()可能会被使用者重写const info=Object.create(null)//这样创建的对下个原型指向nullinfo.name=&quot;why&quot;info.hasOwnProperty(name)//由于原型指向null,所以获取不到hasOwnProperty方法需要使用Object.hasOwn()替代201.Object.create()\t创建一个新对象，使用现有的对象来提提供新创建对象的__proto__\tObject.create(proto,[prppertiesObject])202.Class Person&#123;\theight=1.88//在这里写的时候，new创建对象时也会被添加到新的对象里面，再class内部可以通过\t\t\t\t\tthis来访问\tconstructor(name,age)&#123;\tthis.name=name\tthis.age=age\tthis.address=&quot;广州市&quot;\t&#125;\t\tstatic &#123;\t\t//静态代码块\t&#125;&#125;\t203.proxy\tObject.defineProperty()的缺点，不可以监听到对象属性的新增和删除操作，新增的属性也没办法监听，只能监听属性，不能监听整个对象\n\n\nProxy是监听整个对象，他有13个捕获器，这些捕获器可以劫持对象的一些操作用proxy替代obj操作\n\n\n204.Reflect的作用Reflect是为了替代Object中的一些方法\n\n\n\n\n205.Reflect.construct的作用Reflect.construct(target, argumentsList[, newTarget])\n\n\n​\t\n206.new.target作用207.promise\t三种状态：\t\tpending\t\tfulfilled\t\trejected\t\t状态发生改变，就不可以更改\t\t\t\tresolve(value)//value会作为then方法中的回调函数的参数\t\t1.普通值则作为参数直接传过去\t\t2.如果传入的是promise,则由promise的中的·resolve参数决定\t\t3.thenable对象则会执行then方法并且由then方法中的reslove的参数决定\t\t\t\tthen()//可以传两个参数，成功的回调和失败的回调\t\tcatch()//失败的回调208.Window.getComputedStyle(ele,prop?)和Element.getBoundingClientRect()的区别\tgetComputedStyle是定义在window上的方法，getBoundingClientRect是Element的方法，getComputedStyle返回值是CSS属性值，而getBoundingClientRect返回的是具体的位置信息\n\n\n209.Promise.prototype.then()//返回值是一个promise,链式调用中，then会等待上一个then的返回值promise的状态来决定\tconst promise=new Promise((resolve,reject)=&gt;&#123;\t\tresolve(111)\t&#125;)\tpromise.then(res=&gt;&#123;\t\treturn res\t&#125;).then(res=&gt;&#123;\t\t&#125;)\tthen的返回值\t\t1.普通值则会直接包裹成promise返回\t\t2. new Promise 则有这个promise的状态来决定\t\t3.有thenable方法的对象，则由thenable方法的状态来决定\tthen抛出异常时，就处于reject状态，则会调用后面的catch\tthen return 时处于fulfilled\tthen没有返回值则不会继续调用then210.Promsie.prototype.catch()\tcatch 里面调用return的时候默认状态是fuifilled,他的返回值是一个promise\t和then一样\t如果向继续链式调用catch，需要抛出异常\t当promise中调用reject的时候，会调用最近catch\t没有返回值时不会继续链式调用211.中断函数的执行\t\treturn\t\tthrow\t\t前两种会直接结束函数的执行\t\tyield\n\n\n212.Promise.prototype.finally(callback)\t\n​\t\t无论Promise对象变成fulfilled还是rejected状态，最终都会执行\n​\t\tfinally方法的回调函数参数是不接受参数的\n\nPromise.resolve()相当于new Promsie()并且执行resolve方法。\n就是希望将变量转换成Promise来使用\nPromise.resolve(&quot;why&quot;)==&gt;new Promsise((resolve)=&gt;resolve(&quot;why&quot;))参数和resolve一样\n\nPromise.reject() reject方法类似于resolve方法，只是会将Promise对象的状态设置为reject状态\nPromise.reject(&quot;why&quot;)=&gt;new Promise((_,reject)=&gt;reject(&quot;why&quot;))//_不传可以这样写Promsie.reject无论传什么参数都是rejected\n\nPromsie.all([])\n他的作用是将对各promise,放入到数组中执行，all方法的最终状态是由数组中的所有promisek结果决定的，如果Promise所有状态都是fulfilled状态则Pramise.all的状态为fulfilled，并且将所有数组中的promise的返回值做成一个数组返回如果数组中出现一个promise状态为rejected则all的状态也会变成rejected,并将第一个reject的返回值作为参数Promsie.all([p1,p2,p3]).then(res=&gt;res).catch(err=&gt;err)\n\nPromise.allSettled([])\nPromsie.allSettled([p1,p2,p3]).then(res=&gt;res)//状态都是fulfilled,会返回一个[&#123;stattus:fulfilled/rejected,value:&quot;&quot;&#125;]\n\nPromsie.race([])\nrece的状态由[]中的promise那个先完成的状态来决定的\n\n\n\nPromise.any([])\n\n\n只要[]中的promise中的第一个变成fulfilled的状态来决定的，返回值也是这个promise返回值如果所有的promsie状态都是rejected则会变成any的状态会变成reject果所有的Promise都是reject的，那么会报一个AggregateError的错误。\n\n219.迭代器\n220.async函数的执行\nasync函数 没有await的话则和普通的函数没有区别，都是会同步执行返回值如果是普通值则会被Promise.resolve()包裹返回值是promsie时，会有promise的状态来决定返回值是thenable对象，则由thenable的状态来决定async函数的执行函数的执行函数想返回reject状态，调用catch,可以使用返回一个promsie 里面用reject(),thenable也是一样，或者使用Promise.reject()还可以用throw 来抛出异常async的异常不会报错，而是会作为Promise.reject来传递await关键字 只能在async里面使用await 之后的代码相当于Promsie.then(),await要捕获错误需要使用try...catch\tawait 后面跟的代码是Promise.resolve包裹，会等待promise的返回值await会阻塞代码的执行，等待promise返回值，await之前都是同步的\n\n221.浏览器的事件循环\n​\t\t宏任务队列(marcotask queue)：\najax,setTimeout,setInterval,DOM监听，UI Rendering等\n\n​\t\t微任务队列(microtask queue)\nPromise的then回调，Mutation Obderver API queueMicrotask async await\n\n​\t执行宏任务之前，会先检查微任务队列是否为空，如果不为空，先执行微任务\n222.错误处理方案\n​\t\tthrow 会中断后面代码的执行\nthrow String/number/boolean/Object\n\n​\t\t异常的捕获\n​\t\ttry..catch..finally\n223.cookie存储是由浏览器自动做的，携带cookie也是由浏览器做的\n224.Storage\n​\t\tlocalStorage在页面关闭并重新打开时不会被清除，sessionStroage会被清除\n​\t\t在页面内发生跳转不打开新页面时，sessionStorage和localStorage都会被保留\n​\t\t在页面外发生跳转打开新的页面时，sessionStorage不保存，localStorage会保存\n​\t\tsessionStorage只会在本次会话中存储，不会在新页面中获取\n225.cache工具的封装\n226.正则表达式\nconst re1=new REgExp(pattern,&quot;ig&quot;)//new 创建const re2=/aaaa/ig //字面量写法message.replaceAll(/abc/ig,&quot;cba&quot;)message.replaceAll(/\\d+/ig,&quot;cba&quot;)message.test(/^abc$/ig)//返回值是boolean值message.match(/abc/ig)//返回匹配到的值的数组结合message.matchAll(/abc/ig)//必须加g,返回值是迭代器message.split(/abc/ig)message.search(/abc/i)//返回索引，没有则返回-1常见修饰符\tg 匹配全部\ti 忽略大小写\tm 多行匹配\t规则\t\\d digit 一个数字0-9\t\\s space 一个空格字符，换行符,\\t,\\n\t\\w word 一个拉丁字母或者数字，下划线\t.  匹配任意字符，除了换行符\t\t反向类\t\\D 非数字 除\\d以外字符 如字母\t\\S 非空格 \t\\W 非单字字符\t\t转义\t/\\./ig 对.进行转义\t[,],\\,^,$,.,|,?,*,+,(,),/  常见的需要进行转义\t\tconst jsfile=/\\.jsx?$/  ?表示前面的字符可选\t\t集合\t\t匹配到多个字符中的其中之一.用[]\t\t/[0-9]/,/[156]/\t\tconst phone=/^1[3-9]\\d&#123;9&#125;$/ //匹配电话号码\t\t\t\t排除范围[^...]，不匹配括号里面的\t量词\t\t/a&#123;5&#125;/ 匹配5个a /a&#123;3,5&#125;/匹配3-5个a\t\t缩写\t\t\t+:一个或者多个,&#123;1,&#125;\t\t\t?:0或者1个 &#123;0,1&#125;\t\t\t*:0个或者多个 &#123;0,&#125;\t\t\t\t\t\tconst tag=/&lt;\\/?[a-z][a-z0-9]*\\/?/ig  匹配多个元素标签\t\t\t\t\t\t贪婪模式和惰性模式\t\t\tconst name=/《.+?》/g 惰性模式\t\t\tconst name=/《.+》/g 贪婪模式\t\t\t\t捕获组\t\t\tconst name=/《(.+?)》/g\t\t\tstr.matchAll(name)\t\t\t\t\t\t未学完\t\t\t227.http 超文本传输协议  \t默认端口是80端口，是应用层协议228.HTTP组成\t一次请求包括request和response229.http版本\tHTTP/1.0\tHTTP/1.1 添加了持久化连接\tHTTP/2.0\tHTTP/3.0230.HTTP的请求方式\tGET\tHEAD//和get相似,但是没有响应体，例如准备下载一个文件前，先获取文件的大小，再决定是否进行下载\tPOST//将实体提交到指定的资源\tPUT//替换所有数据\tDELETE\tPATCH//对部分数据进行修改\tCONNECT\tTRACE231.request header\tcontent-type是请求携带的数据类型\t\tapplication/x-www-form-urlencoded 表示被编码成以&amp;分隔name=why&amp;age=18\t\tapplication/json 表示是一种json类型\t\ttext/plain 表示文本类型\t\tapplication/xml\t\tmultipart/form-data //表示文件上传 ，很多浏览器会自动设置\tcontent-length 文件长度 不需要设置\tkeep-alive http/1.1 默认为true\taccept-encoding:告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip压缩对应.gz文件，浏览器会自动解压，这个属性不用配，浏览器会配，在webpack中可以打包成gzip文件\taccept:告诉浏览器，客户端可以接受的文件的格式类型 默认是任何格式都接受\tuser-agent:客户端相关的信息232.http response status\t200 ok \t201 create post请求，创建新的资源\t301 永久重定向\t400 bad request 客户端的错误，服务器无法或者不进行处理\t401 unauthorized 未授权 一般是没有登录的情况下 没有cookie,token或者过期\t403 forbidden 没有权限\t404 NOt found 一般是接口不存在，url错误\t500 服务器未知错误\t503 暂时无法访问\t\t400、403都是浏览器返回的\t有些开发所有返回的status都是200，在数据里面来自定义错误信息233.xhr\tconst xhr=new XMLHttpRequest()\txhr.onload=function()&#123;\t\t//xhr.response   一般使用这个\t\t//xhr.responseText\t\t//xhr.responseXML\t&#125;\txhr.responseType=&quot;json&quot;//默认是text,一般是json\t\txhr.open(&quot;get&quot;,url)//第一个参数是请求类型，第二个参数是url，第三个参数是是否同步，默认是异步\t//设置过期时间\txhr.timeout=3000\txhr.ontimeout=function()&#123;\t\t&#125;\txhr.abort()//取消请求\t//发送网络请求\txhr.send()234.ajax的封装235.Fetch \t返回值是promise\t文件上传地址http://123.207.32.32:1888/02_param/upload236.gitgit add .git commit -m &quot;提交描述&quot;git pushgit pull origin master //从远程的某个分支获取git branch --set-upstream-to=origin/master  //设置上游分支就可以只写 git pull了git merge --allow-unrelated-histories  //强制合并git statusgit clone url//克隆代码push到远程仓库git pushgit push origin masterfetch代码git fetch git fetch origin master获取到代码后默认并没有合并，需要mergegit mergeget merge origin/master也可以使用git pull相当于git fetch+git merge(rebase)链接远程仓库geit remote add origin ....git push origin master //第一次图送会推送到main分支  第二次推送会被推送到mastergit push origin master:maingit push origin head:main  head默认指向main如果要push master默认要这么写git push origin master:main  如果想写git push就要这么写配置git push 指向上游路径master，就是配置好的git branch --set-upstream-to=origin/master调用git push 就会push到master,但是这样每个分支都是push到mastergit config push.default upstream  [--global]//加上global可以全局使用，否则就是当前项目使用git config push.default current  //这个会先去仓库找有没有和本地相同的分支，如果没有就在远程创建一个新的和本地相同的分支push.default 默认是simple 就是push相同的分支git tag 打标签git tag v1.0.0git tag -a v1.0.1 -m &quot;注释&quot;默认情况子git tag 不会push到服务器git push origin v1.0.0  推送到远程git push origin --tags 把所有tag都推送上去git tag -d tagname  //删除本地的taggit oush origin&lt;在本地定义的远程的名字，默认是origin&gt; -d或者--delete v1.0.0git checkpout v1.0.0 跳转到目标tag, 回到tag版本代码 不能再当前tag修改代码，需要根据当前的tag,创建新的分支来修改git cat-file -p 00d2  //查看.git/objects/00/d2..... 就可以看到文件的内容git cat-file -t 00d2 //查看文件内容//blod 表示文件还没提交的文件//commit 表示已经提交//tag 表示是tag\n\n237.Git分支\n创建新的分支其实创建一个新的可移动的指针\ngit branch 分支  创建分支\ngit checkout 分支 切换分支\ngit 怎么直到指向那个分支 也是使用HEAD的指针 \ngit checkout 分支  就是将head指针指向它\n先使用 git branch 分支 创建分支 然后再使用 git checkout 分支 将切换分支指针指向该分支\ngit checkout -b    &#x2F;&#x2F;创建新的分支并且切换分支\n 238.git flow \n在项目开发过程中，首先会创建master主分支用于线上发布，可以打上tag作为版本，如果线上出现bug,则从master开辟分支，进行代码的修复，然后合并到master分支，和develop分支。develop分支用于开发，需要上线时会开辟release分支用于测试，并且修复测试遇到的bug,完成测试后就可以合并到master和develop,如果需要开发新的功能，则需要从develop开辟新分支进行开发\n239.git的远程分支\ngit remote add origin url\ngit fetch origin main  &#x2F;&#x2F;把main分支拉取\ngit branch –set-upstream-to&#x3D;origin&#x2F;main  &#x2F;&#x2F;设置上游分支\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nget merge&#x2F;&#x2F;默认合并upstream   合并必须要有共同的祖先\n远程分支是也是一种分支结构：  以 remote&#x2F;branch式命名的\n240.跟踪远程分支\n当克隆一个仓库时，它通常会自动地创建一个跟踪 origin&#x2F;master 的 master 分支\n如果你愿意的话可以设置其他的跟踪分支，可以通过运行 git checkout –track origin&#x2F;分支名\n 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支\ngit checkout --track &lt;remote&gt;/&lt;branch&gt;  相当于git branch --set-upstream-to=origin/main  跟踪origin/main  并且创建和切换mian分支git checkout &lt;branch&gt;  上面的简写他会先检查远程有没有这个分支，然后在跟踪这个分支，并且在本地创建这个分支，在切换到这个分支\n\n241.git checkout -b  develop\n​\t\tgit push origin develop\n如果需要创建一个分支，并且推送到远程，远程也会创建相同的分支\n242.git branch -d  分支     删除本地分支\n243.删除远程分支\ngit push origin --delete &lt;branch&gt;\n\n244.查看git log\ngit log --pretty=oneline\n\n245 git rebase\ngit checkout featuregit rebase mastergit checkout mastergit merge  feature//永远不要在主分支上rebase\n\n246.git rebase的原理\n247.rebase和merge的区别\nmerge会记录git的所有历史，那么分支的历史错综复杂，也会全部记录下来\nrebase用于简化历史记录，将两个分支的历史简化，整个历史更加简洁\n","categories":["note","前端系统课笔记"]},{"title":"自定义事件总线","url":"/2022/09/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/","content":"&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;button class=&quot;nav-btn&quot;&gt;nav button&lt;/button&gt;    &lt;script&gt;    // 类EventBus -&gt; 事件总线对象    class HYEventBus &#123;      constructor() &#123;        this.eventMap = &#123;&#125;      &#125;      on(eventName, eventFn) &#123;        let eventFns = this.eventMap[eventName]        if (!eventFns) &#123;          eventFns = []          this.eventMap[eventName] = eventFns        &#125;        eventFns.push(eventFn)      &#125;            off(eventName, eventFn) &#123;        let eventFns = this.eventMap[eventName]        if (!eventFns) return        for (let i = 0; i &lt; eventFns.length; i++) &#123;          const fn = eventFns[i]          if (fn === eventFn) &#123;            eventFns.splice(i, 1)            break          &#125;        &#125;        // 如果eventFns已经清空了        if (eventFns.length === 0) &#123;          delete this.eventMap[eventName]        &#125;      &#125;      emit(eventName, ...args) &#123;        let eventFns = this.eventMap[eventName]        if (!eventFns) return        eventFns.forEach(fn =&gt; &#123;          fn(...args)        &#125;)      &#125;    &#125;    // 使用过程    const eventBus = new HYEventBus()    // aside.vue组件中监听事件    eventBus.on(&quot;navclick&quot;, (name, age, height) =&gt; &#123;      console.log(&quot;navclick listener 01&quot;, name, age, height)    &#125;)    const click =  () =&gt; &#123;      console.log(&quot;navclick listener 02&quot;)    &#125;    eventBus.on(&quot;navclick&quot;, click)    setTimeout(() =&gt; &#123;      eventBus.off(&quot;navclick&quot;, click)    &#125;, 5000);    eventBus.on(&quot;asideclick&quot;, () =&gt; &#123;      console.log(&quot;asideclick listener&quot;)    &#125;)    // nav.vue    const navBtnEl = document.querySelector(&quot;.nav-btn&quot;)    navBtnEl.onclick = function() &#123;      console.log(&quot;自己监听到&quot;)      eventBus.emit(&quot;navclick&quot;, &quot;why&quot;, 18, 1.88)    &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["javascript","原理"]},{"title":"节流函数的实现","url":"/2022/09/07/%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"节流函数的基本实现&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;script&gt;      function myThrottle(fn, interval) &#123;        let startTime = 0;        return function _throttle() &#123;          const nowTime = new Date().getTime();          const waitTime = interval - (nowTime - startTime); //第一次肯定会执行，因为startTime为0          if (waitTime &lt;= 0) &#123;            fn();            startTime = nowTime;          &#125;        &#125;;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      inputEl.oninput = myThrottle((e) =&gt; &#123;        console.log(e, &quot;-----&quot;);      &#125;, 1000);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\nthis和参数绑定&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;script&gt;      function myThrottle(fn, interval) &#123;        let startTime = 0;        return function _throttle(...args) &#123;          const nowTime = new Date().getTime();          const waitTime = interval - (nowTime - startTime); //第一次肯定会执行，因为startTime为0          if (waitTime &lt;= 0) &#123;            fn.apply(this, args);            startTime = nowTime;          &#125;        &#125;;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      inputEl.oninput = myThrottle((e) =&gt; &#123;        console.log(e, &quot;-----&quot;);      &#125;, 1000);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n对立即执行进行控制&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;script&gt;      function myThrottle(fn, interval, leading = true) &#123;        let startTime = 0;        return function _throttle(...args) &#123;          const nowTime = new Date().getTime();          // 对立即执行进行控制          if (!leading &amp;&amp; startTime === 0) &#123;            startTime = nowTime;          &#125;          const waitTime = interval - (nowTime - startTime); //第一次肯定会执行，因为startTime为0          if (waitTime &lt;= 0) &#123;            fn.apply(this, args);            startTime = nowTime;          &#125;        &#125;;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      inputEl.oninput = myThrottle(        (e) =&gt; &#123;          console.log(e, &quot;-----&quot;);        &#125;,        1000,        false      );    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n尾部执行控制\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;script&gt;      function myThrottle(        fn,        interval,        &#123; leading = true, trailing = false &#125; = &#123;&#125;      ) &#123;        let startTime = 0;        let timer = null;        return function _throttle(...args) &#123;          const nowTime = new Date().getTime();          // 对立即执行进行控制          if (!leading &amp;&amp; startTime === 0) &#123;            startTime = nowTime;          &#125;          const waitTime = interval - (nowTime - startTime); //第一次肯定会执行，因为startTime为0          if (waitTime &lt;= 0) &#123;            if (timer) clearTimeout(timer);            fn.apply(this, args);            startTime = nowTime;            timer = null;            return;          &#125;          // 针对waitTime还有余数的时候          if (trailing &amp;&amp; !timer) &#123;            timer = setTimeout(() =&gt; &#123;              fn.apply(this, args);              timer = null;              startTime = new Date().getTime();            &#125;, waitTime);          &#125;        &#125;;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      inputEl.oninput = myThrottle(        (e) =&gt; &#123;          console.log(e, &quot;-----&quot;);        &#125;,        1000,        &#123; trailing: true &#125;      );    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n取消函数&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;script&gt;      function myThrottle(        fn,        interval,        &#123; leading = true, trailing = false &#125; = &#123;&#125;      ) &#123;        let startTime = 0;        let timer = null;        function _throttle(...args) &#123;          const nowTime = new Date().getTime();          // 对立即执行进行控制          if (!leading &amp;&amp; startTime === 0) &#123;            startTime = nowTime;          &#125;          const waitTime = interval - (nowTime - startTime); //第一次肯定会执行，因为startTime为0          if (waitTime &lt;= 0) &#123;            if (timer) clearTimeout(timer);            fn.apply(this, args);            startTime = nowTime;            timer = null;            return;          &#125;          // 针对waitTime还有余数的时候          if (trailing &amp;&amp; !timer) &#123;            timer = setTimeout(() =&gt; &#123;              fn.apply(this, args);              timer = null;              startTime = new Date().getTime();            &#125;, waitTime);          &#125;        &#125;        // 取消函数        _throttle.cancel = function () &#123;          if (timer) clearTimeout(timer);          timer = null;          startTime = 0;        &#125;;        return _throttle;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      inputEl.oninput = myThrottle(        (e) =&gt; &#123;          console.log(e, &quot;-----&quot;);        &#125;,        1000,        &#123; trailing: true &#125;      );    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n获取返回值&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;script&gt;      function myThrottle(        fn,        interval,        &#123; leading = true, trailing = false &#125; = &#123;&#125;      ) &#123;        let startTime = 0;        let timer = null;        function _throttle(...args) &#123;          try &#123;            return new Promise((resolve, reject) =&gt; &#123;              try &#123;              &#125; catch (error) &#123;&#125;            &#125;);            const nowTime = new Date().getTime();            // 对立即执行进行控制            if (!leading &amp;&amp; startTime === 0) &#123;              startTime = nowTime;            &#125;            const waitTime = interval - (nowTime - startTime); //第一次肯定会执行，因为startTime为0            if (waitTime &lt;= 0) &#123;              if (timer) clearTimeout(timer);              const res = fn.apply(this, args);              resolve(res);              startTime = nowTime;              timer = null;              return;            &#125;            // 针对waitTime还有余数的时候            if (trailing &amp;&amp; !timer) &#123;              timer = setTimeout(() =&gt; &#123;                fn.apply(this, args);                timer = null;                startTime = new Date().getTime();              &#125;, waitTime);            &#125;          &#125; catch (error) &#123;            reject(error);          &#125;        &#125;        // 取消函数        _throttle.cancel = function () &#123;          if (timer) clearTimeout(timer);          timer = null;          startTime = 0;        &#125;;        return _throttle;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      inputEl.oninput = myThrottle(        (e) =&gt; &#123;          console.log(e, &quot;-----&quot;);        &#125;,        1000,        &#123; trailing: true &#125;      );    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n","categories":["javascript","原理"]},{"title":"虚拟列表的实现","url":"/2022/09/11/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"","categories":["javascript","工具"]},{"title":"计算机组成原理","url":"/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","content":"","categories":["计算机组成原理"]},{"title":"计算机网络","url":"/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":""},{"title":"计算机网路笔记(一)","url":"/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%AC%94%E8%AE%B0-%E4%B8%80/","content":"","categories":["计算机网络"]},{"title":"防抖函数的实现","url":"/2022/09/07/%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","content":"节流函数的基本实现&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;script&gt;      function mydebounce(fn, delay) &#123;        // 记录上一次的timer        let timer = null;        // 返回需要执行的函数        return function _debounce() &#123;          //频繁触发执行都会先清除上一次的timer          if (timer) clearTimeout(timer);          timer = setTimeout(() =&gt; &#123;            fn();            timer = null; // 执行过函数之后, 将timer重新置null          &#125;, delay);        &#125;;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      inputEl.oninput = mydebounce(function (e) &#123;        console.log(e, &quot;----------&quot;);      &#125;, 1000);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\nthis的绑定和参数传递&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;script&gt;      function mydebounce(fn, delay) &#123;        // 记录上一次的timer        let timer = null;        // 返回需要执行的函数        return function _debounce(...args) &#123;          //频繁触发执行都会先清除上一次的timer          if (timer) clearTimeout(timer);          timer = setTimeout(() =&gt; &#123;            fn.apply(this, args);            timer = null; // 执行过函数之后, 将timer重新置null          &#125;, delay);        &#125;;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      inputEl.oninput = mydebounce(function (e) &#123;        console.log(e, this, &quot;----------&quot;);      &#125;, 1000);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n取消功能的实现&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;button&gt;取消&lt;/button&gt;    &lt;script&gt;      function mydebounce(fn, delay) &#123;        // 记录上一次的timer        let timer = null;        // 返回需要执行的函数        function _debounce(...args) &#123;          //频繁触发执行都会先清除上一次的timer          if (timer) clearTimeout(timer);          timer = setTimeout(() =&gt; &#123;            fn.apply(this, args);            timer = null; // 执行过函数之后, 将timer重新置null          &#125;, delay);        &#125;        // 取消功能        _debounce.cancel = function () &#123;          if (timer) clearTimeout(timer);          console.log(&quot;button&quot;);          timer = null;        &#125;;        return _debounce;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      const buttonEl = document.querySelector(&quot;button&quot;);      const debounce = mydebounce(function (e) &#123;        console.log(e, this, &quot;----------&quot;);      &#125;, 3000);      inputEl.oninput = debounce;      buttonEl.onclick = debounce.cancel;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n实现立即执行功能&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;button&gt;取消&lt;/button&gt;    &lt;script&gt;      function mydebounce(fn, delay, immediate = false) &#123;        // 记录上一次的timer        let timer = null;        // 记录是否需要第一次是否执行和immediate配合        let isInvoke = false;        // 返回需要执行的函数        function _debounce(...args) &#123;          //频繁触发执行都会先清除上一次的timer          if (timer) clearTimeout(timer);          // 当immediate为true时          if (immediate &amp;&amp; !isInvoke) &#123;            fn.apply(this, args);            isInvoke = true;            return;          &#125;          timer = setTimeout(() =&gt; &#123;            fn.apply(this, args);            timer = null; // 执行过函数之后, 将timer重新置null            isInvoke = false; //重置          &#125;, delay);        &#125;        // 取消功能        _debounce.cancel = function () &#123;          if (timer) clearTimeout(timer);          console.log(&quot;button&quot;);          timer = null;        &#125;;        return _debounce;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      const buttonEl = document.querySelector(&quot;button&quot;);      const debounce = mydebounce(        function (e) &#123;          console.log(e, this, &quot;----------&quot;);        &#125;,        3000,        true      );      inputEl.oninput = debounce;      buttonEl.onclick = debounce.cancel;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n获取返回值的实现获取返回值的方式有两种\n传入回调函数\n通过promise.then来获取\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;button&gt;取消&lt;/button&gt;    &lt;script&gt;      function mydebounce(        fn,        delay,        immediate = false,        resultCallback = () =&gt; &#123;&#125;      ) &#123;        // 记录上一次的timer        let timer = null;        // 记录是否需要第一次是否执行和immediate配合        let isInvoke = false;        // 返回需要执行的函数        function _debounce(...args) &#123;          return new Promise((resolve, reject) =&gt; &#123;            try &#123;              //频繁触发执行都会先清除上一次的timer              if (timer) clearTimeout(timer);              // 当immediate为true时              if (immediate &amp;&amp; !isInvoke) &#123;                const result = fn.apply(this, args);                resultCallback(result);                resolve(result);                isInvoke = true;                return;              &#125;              timer = setTimeout(() =&gt; &#123;                const result = fn.apply(this, args);                resultCallback(result);                resolve(result);                timer = null; // 执行过函数之后, 将timer重新置null                isInvoke = false; //重置              &#125;, delay);            &#125; catch (error) &#123;              reject(error);            &#125;          &#125;);        &#125;        // 取消功能        _debounce.cancel = function () &#123;          if (timer) clearTimeout(timer);          console.log(&quot;button&quot;);          timer = null;          isInvoke = false;        &#125;;        return _debounce;      &#125;    &lt;/script&gt;    &lt;script&gt;      const inputEl = document.querySelector(&quot;input&quot;);      const buttonEl = document.querySelector(&quot;button&quot;);      const debounce = mydebounce(        function (e) &#123;          console.log(e, this, &quot;----------&quot;);        &#125;,        3000,        true      );      inputEl.oninput = debounce;      buttonEl.onclick = debounce.cancel;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n","categories":["javascript","原理"]},{"title":"面向对象的原型继承","url":"/2022/09/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/","content":"直接将父类的原型赋值给子类// 定义Person构造函数(类)function Person(name, age, height, address) &#123;  this.name = name;  this.age = age;  this.height = height;  this.address = address;&#125;Person.prototype.running = function () &#123;  console.log(&quot;running~&quot;);&#125;;Person.prototype.eating = function () &#123;  console.log(&quot;eating~&quot;);&#125;;// 定义学生类function Student(name, age, height, address, sno, score) &#123;  this.name = name;  this.age = age;  this.height = height;  this.address = address;  this.sno = sno;  this.score = score;&#125;Student.prototype = Person.prototype;Student.prototype.getName = function () &#123;  return this.name;&#125;;const stu = new Student(&quot;111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;444&quot;, &quot;555&quot;, &quot;666&quot;);console.log(stu);console.log(stu.getName());const p = new Person(&quot;777&quot;, &quot;888&quot;, &quot;999&quot;, &quot;101010&quot;);console.log(p.getName());\n\n这种方式会使父类和子类共用原型链上的方法，子类也会修改父类原型链的方法，修改或者添加子类原型链上的方法，父类也会受到影响，父类原型链上也会有这个方法\n通过父类实例实现继承// 定义Person构造函数(类)function Person(name, age, height, address) &#123;  this.name = name;  this.age = age;  this.height = height;  this.address = address;&#125;Person.prototype.running = function () &#123;  console.log(&quot;running~&quot;);&#125;;Person.prototype.eating = function () &#123;  console.log(&quot;eating~&quot;);&#125;;// 定义学生类function Student(sno, score) &#123;  this.sno = sno;  this.score = score;&#125;// Student.prototype指向Person实例const p1 = new Person();Student.prototype = p1;Student.prototype.getName = function () &#123;  return this.name;&#125;;const stu = new Student(&quot;555&quot;, &quot;666&quot;);console.log(stu);console.log(stu.getName());const p = new Person(&quot;777&quot;, &quot;888&quot;, &quot;999&quot;, &quot;101010&quot;);console.log(p.getName());\n\n原型链继承虽然可以解决子类会修改父类的原型链上的方法的问题，但是子类无法查看父类的参数，也，也没办法修改父类的参数，打印看不到父类的参数，不可以给父类传参\n借用构造函数的继承function Person(name, age, height, address) &#123;  this.name = name;  this.age = age;  this.height = height;  this.address = address;&#125;Person.prototype.running = function () &#123;  console.log(&quot;running~&quot;);&#125;;Person.prototype.eating = function () &#123;  console.log(&quot;eating~&quot;);&#125;;// 定义学生类function Student(name, age, height, address, sno, score) &#123;  // 借用父类的构造函数  Person.call(this, name, age, height, address);  this.sno = sno;  this.score = score;&#125;// Student.prototype指向Person实例const p1 = new Person();Student.prototype = p1;Student.prototype.getName = function () &#123;  return this.name;&#125;;const stu = new Student(&quot;111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;444&quot;, &quot;555&quot;, &quot;666&quot;);console.log(stu);console.log(stu.getName());console.log(stu.eating());const p = new Person(&quot;777&quot;, &quot;888&quot;, &quot;999&quot;, &quot;101010&quot;);console.log(p.eating());\n\n这种方式会调用两次父类的构造函数\n一次在创建子类原型的时候\n另一次在子类构造函数内部(也就是每次创建子类实例的时候)；\n组合寄生式继承// 创建工具函数function createObject(o) &#123;  function F() &#123;&#125;  F.prototype = o;  return new F();&#125;// 创建寄生函数function inherit(Subtype, Supertype) &#123;  // 方式一  // const obj=Object.create(Supertype.prototype)  // Subtype.prototype=obj  // 方式二  Subtype.prototype = createObject(Supertype.prototype);  Object.defineProperty(Subtype.prototype, &quot;constructor&quot;, &#123;    configurable: true,    enumerable: false,    writable: true,    value: Subtype,  &#125;);  Object.setPrototypeOf(Subtype, Supertype);  // Subtype.__proto__=Supertype&#125;// 寄生组合式继承// 原型链/借用/原型式(对象之间)/寄生式函数function Person(name, age, height) &#123;  this.name = name;  this.age = age;  this.height = height;&#125;Person.prototype.running = function () &#123;  console.log(&quot;running~&quot;);&#125;;Person.prototype.eating = function () &#123;  console.log(&quot;eating~&quot;);&#125;;//类方法Person.sleep = function () &#123;  console.log(&quot;static sleep&quot;);&#125;;function Student(name, age, height, sno, score) &#123;  Person.call(this, name, age, height);  this.sno = sno;  this.score = score;&#125;inherit(Student, Person);Student.prototype.studying = function () &#123;  console.log(&quot;studying&quot;);&#125;;// 创建实例对象var stu1 = new Student(&quot;why&quot;, 18, 1.88, 111, 100);console.log(stu1);stu1.studying();Student.sleep();\n\nES6中的继承es6中增加了extends关键字来实现继承\nclass Person &#123;   constructor(name, age) &#123;     this.name = name;     this.age = age;   &#125;   running() &#123;     console.log(&quot;running~&quot;);   &#125;   eating() &#123;     console.log(&quot;eating~&quot;);   &#125;   static sleep() &#123;     console.log(&quot;static animal sleep&quot;);   &#125; &#125; class Student extends Person &#123;   constructor(name, age, sno, score) &#123;     // super可用来调用父类的构造函数、实例方法，静态方法     super(name, age);     this.sno = sno;     this.score = score;   &#125;   studying() &#123;     console.log(&quot;studying~&quot;);   &#125; &#125; const stu = new Student(&quot;111&quot;, &quot;222&quot;, &quot;333&quot;, &quot;444&quot;, &quot;555&quot;); // 类方法也可以实现继承 Student.sleep();\n\n","categories":["javascript","原理"]},{"title":"vue3项目搭建","url":"/2022/09/13/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","content":"项目搭建规范一. 代码规范1.1. 集成editorconfig配置EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。\n# http://editorconfig.orgroot = true[*] # 表示所有文件适用charset = utf-8 # 设置文件字符集为 utf-8indent_style = space # 缩进风格（tab | space）indent_size = 2 # 缩进大小end_of_line = lf # 控制换行类型(lf | cr | crlf)trim_trailing_whitespace = true # 去除行首的任意空白字符insert_final_newline = true # 始终在文件末尾插入一个新行[*.md] # 表示仅 md 文件适用以下规则max_line_length = offtrim_trailing_whitespace = false\n\n\n\nVSCode需要安装一个插件：EditorConfig for VS Code\n\n1.2. 使用prettier工具Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。\n1.安装prettier\nnpm install prettier -D\n\n2.配置.prettierrc文件：\n\nuseTabs：使用tab缩进还是空格缩进，选择false；\ntabWidth：tab是空格的情况下，是几个空格，选择2个；\nprintWidth：当行字符的长度，推荐80，也有人喜欢100或者120；\nsingleQuote：使用单引号还是双引号，选择true，使用单引号；\ntrailingComma：在多行输入的尾逗号是否添加，设置为 none；\nsemi：语句末尾是否要加分号，默认值true，选择false表示不加；\n\n&#123;  &quot;useTabs&quot;: false,  &quot;tabWidth&quot;: 2,  &quot;printWidth&quot;: 80,  &quot;singleQuote&quot;: true,  &quot;trailingComma&quot;: &quot;none&quot;,  &quot;semi&quot;: false&#125;\n\n\n\n3.创建.prettierignore忽略文件\n/dist/*.local.output.js/node_modules/****/*.svg**/*.sh/public/*\n\n\n\n4.VSCode需要安装prettier的插件\n\n5.测试prettier是否生效\n\n测试一：在代码中保存代码；\n测试二：配置一次性修改的命令,批量修改；\n\n在package.json中配置一个scripts：\n&quot;prettier&quot;: &quot;prettier --write .&quot;\n\n\n\n1.3. 使用ESLint检测1.在前面创建项目的时候，我们就选择了ESLint，所以Vue会默认帮助我们配置需要的ESLint环境。\n2.VSCode需要安装ESLint插件：\n\n3.解决eslint和prettier冲突的问题：\n安装插件：（vue在创建项目时，如果选择prettier，那么这两个插件会自动安装）\nnpm i eslint-plugin-prettier eslint-config-prettier -D\n\n添加在eslintrc中添加prettier插件：\nextends: [  &quot;plugin:vue/vue3-essential&quot;,  &quot;eslint:recommended&quot;,  &quot;@vue/typescript/recommended&quot;,  &quot;@vue/prettier&quot;,  &quot;@vue/prettier/@typescript-eslint&quot;,  &#x27;plugin:prettier/recommended&#x27;],\n\n\n\n1.4. git Husky和eslint虽然我们已经要求项目使用eslint了，但是不能保证组员提交代码之前都将eslint中的问题解决掉了：\n\n也就是我们希望保证代码仓库中的代码都是符合eslint规范的；\n\n那么我们需要在组员执行 git commit  命令的时候对其进行校验，如果不符合eslint规范，那么自动通过规范进行修复；\n\n\n那么如何做到这一点呢？可以通过Husky工具：\n\nhusky是一个git hook工具，可以帮助我们触发git提交的各个阶段：pre-commit、commit-msg、pre-push\n\n如何使用husky呢？\n这里我们可以使用自动配置命令：\nnpx husky-init &amp;&amp; npm install\n\n这里会做三件事：\n1.安装husky相关的依赖：\n\n2.在项目目录下创建 .husky 文件夹：\nnpx huksy install\n\n\n\n\n3.在package.json中添加一个脚本：\n\n接下来，我们需要去完成一个操作：在进行commit时，执行lint脚本：\n\n这个时候我们执行git commit的时候会自动对代码进行lint校验。\n1.5. git commit规范1.5.1. 代码提交风格通常我们的git commit会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。\n\n但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：Commitizen\n\nCommitizen 是一个帮助我们编写规范 commit message 的工具；\n\n1.安装Commitizen\nnpm install commitizen -D\n\n2.安装cz-conventional-changelog，并且初始化cz-conventional-changelog：\nnpx commitizen init cz-conventional-changelog --save-dev --save-exact\n\n这个命令会帮助我们安装cz-conventional-changelog：\n\n并且在package.json中进行配置：\n\n这个时候我们提交代码需要使用 npx cz：\n\n第一步是选择type，本次更新的类型\n\n\n\n\nType\n作用\n\n\n\nfeat\n新增特性 (feature)\n\n\nfix\n修复 Bug(bug fix)\n\n\ndocs\n修改文档 (documentation)\n\n\nstyle\n代码格式修改(white-space, formatting, missing semi colons, etc)\n\n\nrefactor\n代码重构(refactor)\n\n\nperf\n改善性能(A code change that improves performance)\n\n\ntest\n测试(when adding missing tests)\n\n\nbuild\n变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）\n\n\nci\n更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等\n\n\nchore\n变更构建流程或辅助工具(比如更改测试环境)\n\n\nrevert\n代码回退\n\n\n\n第二步选择本次修改的范围（作用域）\n\n\n\n第三步选择提交的信息\n\n\n\n第四步提交详细的描述信息\n\n\n\n第五步是否是一次重大的更改\n\n\n\n第六步是否影响某个open issue\n\n\n我们也可以在scripts中构建一个命令来执行 cz：\n\n1.5.2. 代码提交验证如果我们按照cz来规范了提交风格，但是依然有同事通过 git commit 按照不规范的格式提交应该怎么办呢？\n\n我们可以通过commitlint来限制提交；\n\n1.安装 @commitlint&#x2F;config-conventional 和 @commitlint&#x2F;cli\nnpm i @commitlint/config-conventional @commitlint/cli -D\n\n2.在根目录创建commitlint.config.js文件，配置commitlint\nmodule.exports = &#123;  extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;\n\n3.使用husky生成commit-msg文件，验证提交信息：\nnpx husky add .husky/commit-msg &quot;npx --no-install commitlint --edit $1&quot;\n\n\n\n二. 第三方库集成2.1. vue.config.js配置vue.config.js有三种配置方式：\n\n方式一：直接通过CLI提供给我们的选项来配置：\n比如publicPath：配置应用程序部署的子目录（默认是 /，相当于部署在 https://www.my-app.com/）；\n比如outputDir：修改输出的文件夹；\n\n\n方式二：通过configureWebpack修改webpack的配置：\n可以是一个对象，直接会被合并；\n可以是一个函数，会接收一个config，可以通过config来修改配置；\n\n\n方式三：通过chainWebpack修改webpack的配置：\n是一个函数，会接收一个基于  webpack-chain 的config对象，可以对配置进行修改；\n\n\n\nconst path = require(&#x27;path&#x27;)module.exports = &#123;  outputDir: &#x27;./build&#x27;,  // configureWebpack: &#123;  //   resolve: &#123;  //     alias: &#123;  //       views: &#x27;@/views&#x27;  //     &#125;  //   &#125;  // &#125;  // configureWebpack: (config) =&gt; &#123;  //   config.resolve.alias = &#123;  //     &#x27;@&#x27;: path.resolve(__dirname, &#x27;src&#x27;),  //     views: &#x27;@/views&#x27;  //   &#125;  // &#125;,  chainWebpack: (config) =&gt; &#123;    config.resolve.alias.set(&#x27;@&#x27;, path.resolve(__dirname, &#x27;src&#x27;)).set(&#x27;views&#x27;, &#x27;@/views&#x27;)  &#125;&#125;\n\n\n\n\n\n2.2. vue-router集成安装vue-router的最新版本：\nnpm install vue-router@next\n\n创建router对象：\nimport &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;import &#123; RouteRecordRaw &#125; from &#x27;vue-router&#x27;const routes: RouteRecordRaw[] = [  &#123;    path: &#x27;/&#x27;,    redirect: &#x27;/main&#x27;  &#125;,  &#123;    path: &#x27;/main&#x27;,    component: () =&gt; import(&#x27;../views/main/main.vue&#x27;)  &#125;,  &#123;    path: &#x27;/login&#x27;,    component: () =&gt; import(&#x27;../views/login/login.vue&#x27;)  &#125;]const router = createRouter(&#123;  routes,  history: createWebHashHistory()&#125;)export default router\n\n安装router：\nimport router from &#x27;./router&#x27;createApp(App).use(router).mount(&#x27;#app&#x27;)\n\n在App.vue中配置跳转：\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;    &lt;router-link to=&quot;/main&quot;&gt;首页&lt;/router-link&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;\n\n\n\n2.3. vuex集成安装vuex：\nnpm install vuex@next\n\n创建store对象：\nimport &#123; createStore &#125; from &#x27;vuex&#x27;const store = createStore(&#123;  state() &#123;    return &#123;      name: &#x27;coderwhy&#x27;    &#125;  &#125;&#125;)export default store\n\n安装store：\ncreateApp(App).use(router).use(store).mount(&#x27;#app&#x27;)\n\n在App.vue中使用：\n&lt;h2&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;/h2&gt;\n\n\n\n2.4. element-plus集成Element Plus，一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的桌面端组件库：\n\n相信很多同学在Vue2中都使用过element-ui，而element-plus正是element-ui针对于vue3开发的一个UI组件库；\n它的使用方式和很多其他的组件库是一样的，所以学会element-plus，其他类似于ant-design-vue、NaiveUI、VantUI都是差不多的；\n\n安装element-plus\nnpm install element-plus\n\n\n\n2.4.1. 全局引入一种引入element-plus的方式是全局引入，代表的含义是所有的组件和插件都会被自动注册：\nimport ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/lib/theme-chalk/index.css&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;createApp(App).use(router).use(store).use(ElementPlus).mount(&#x27;#app&#x27;)\n\n\n\n2.4.2. 局部引入也就是在开发中用到某个组件对某个组件进行引入：\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;    &lt;router-link to=&quot;/main&quot;&gt;首页&lt;/router-link&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;h2&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;/h2&gt;    &lt;el-button&gt;默认按钮&lt;/el-button&gt;    &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;    &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt;    &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt;    &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt;    &lt;el-button type=&quot;danger&quot;&gt;危险按钮&lt;/el-button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;import &#123; ElButton &#125; from &#x27;element-plus&#x27;export default defineComponent(&#123;  name: &#x27;App&#x27;,  components: &#123;    ElButton  &#125;&#125;)&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;\n\n但是我们会发现是没有对应的样式的，引入样式有两种方式：\n\n全局引用样式（像之前做的那样）；\n局部引用样式（通过babel的插件）；\n\n1.安装babel的插件：\nnpm install babel-plugin-import -D\n\n2.配置babel.config.js\nmodule.exports = &#123;  plugins: [    [      &#x27;import&#x27;,      &#123;        libraryName: &#x27;element-plus&#x27;,        customStyleName: (name) =&gt; &#123;          return `element-plus/lib/theme-chalk/$&#123;name&#125;.css`        &#125;      &#125;    ]  ],  presets: [&#x27;@vue/cli-plugin-babel/preset&#x27;]&#125;\n\n\n\n但是这里依然有个弊端：\n\n这些组件我们在多个页面或者组件中使用的时候，都需要导入并且在components中进行注册；\n所以我们可以将它们在全局注册一次；\n\nimport &#123;  ElButton,  ElTable,  ElAlert,  ElAside,  ElAutocomplete,  ElAvatar,  ElBacktop,  ElBadge,&#125; from &#x27;element-plus/lib/components&#x27;const app = createApp(App)const components = [  ElButton,  ElTable,  ElAlert,  ElAside,  ElAutocomplete,  ElAvatar,  ElBacktop,  ElBadge]for (const cpn of components) &#123;  app.component(cpn.name, cpn)&#125;\n\n20211212 新版本按需自动导入elementplus\n// webpack.config.jsconst AutoImport = require(&#x27;unplugin-auto-import/webpack&#x27;)const Components = require(&#x27;unplugin-vue-components/webpack&#x27;)const &#123; ElementPlusResolver &#125; = require(&#x27;unplugin-vue-components/resolvers&#x27;)module.exports = &#123;  // ...  plugins: [    AutoImport(&#123;      resolvers: [ElementPlusResolver()],    &#125;),    Components(&#123;      resolvers: [ElementPlusResolver()],    &#125;),  ],&#125;\n\n2.5. axios集成安装axios：\nnpm install axios\n\n封装axios：\nimport axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosResponse &#125; from &#x27;axios&#x27;import &#123; Result &#125; from &#x27;./types&#x27;import &#123; useUserStore &#125; from &#x27;/@/store/modules/user&#x27;class HYRequest &#123;  private instance: AxiosInstance  private readonly options: AxiosRequestConfig  constructor(options: AxiosRequestConfig) &#123;    this.options = options    this.instance = axios.create(options)    this.instance.interceptors.request.use(      (config) =&gt; &#123;        const token = useUserStore().getToken        if (token) &#123;          config.headers.Authorization = `Bearer $&#123;token&#125;`        &#125;        return config      &#125;,      (err) =&gt; &#123;        return err      &#125;    )    this.instance.interceptors.response.use(      (res) =&gt; &#123;        // 拦截响应的数据        if (res.data.code === 0) &#123;          return res.data.data        &#125;        return res.data      &#125;,      (err) =&gt; &#123;        return err      &#125;    )  &#125;  request&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;      this.instance        .request&lt;any, AxiosResponse&lt;Result&lt;T&gt;&gt;&gt;(config)        .then((res) =&gt; &#123;          resolve((res as unknown) as Promise&lt;T&gt;)        &#125;)        .catch((err) =&gt; &#123;          reject(err)        &#125;)    &#125;)  &#125;  get&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return this.request(&#123; ...config, method: &#x27;GET&#x27; &#125;)  &#125;  post&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return this.request(&#123; ...config, method: &#x27;POST&#x27; &#125;)  &#125;  patch&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return this.request(&#123; ...config, method: &#x27;PATCH&#x27; &#125;)  &#125;  delete&lt;T = any&gt;(config: AxiosRequestConfig): Promise&lt;T&gt; &#123;    return this.request(&#123; ...config, method: &#x27;DELETE&#x27; &#125;)  &#125;&#125;export default HYRequest\n\n\n\n2.6. VSCode配置&#123;  &quot;workbench.iconTheme&quot;: &quot;vscode-great-icons&quot;,  &quot;editor.fontSize&quot;: 17,  &quot;eslint.migration.2_x&quot;: &quot;off&quot;,  &quot;[javascript]&quot;: &#123;    &quot;editor.defaultFormatter&quot;: &quot;dbaeumer.vscode-eslint&quot;  &#125;,  &quot;files.autoSave&quot;: &quot;afterDelay&quot;,  &quot;editor.tabSize&quot;: 2,  &quot;terminal.integrated.fontSize&quot;: 16,  &quot;editor.renderWhitespace&quot;: &quot;all&quot;,  &quot;editor.quickSuggestions&quot;: &#123;    &quot;strings&quot;: true  &#125;,  &quot;debug.console.fontSize&quot;: 15,  &quot;window.zoomLevel&quot;: 1,  &quot;emmet.includeLanguages&quot;: &#123;    &quot;javascript&quot;: &quot;javascriptreact&quot;  &#125;,  &quot;explorer.confirmDragAndDrop&quot;: false,  &quot;workbench.tree.indent&quot;: 16,  &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,  &quot;editor.wordWrap&quot;: &quot;on&quot;,  &quot;path-intellisense.mappings&quot;: &#123;    &quot;@&quot;: &quot;$&#123;workspaceRoot&#125;/src&quot;  &#125;,  &quot;hediet.vscode-drawio.local-storage&quot;: &quot;eyIuZHJhd2lvLWNvbmZpZyI6IntcImxhbmd1YWdlXCI6XCJcIixcImN1c3RvbUZvbnRzXCI6W10sXCJsaWJyYXJpZXNcIjpcImdlbmVyYWw7YmFzaWM7YXJyb3dzMjtmbG93Y2hhcnQ7ZXI7c2l0ZW1hcDt1bWw7YnBtbjt3ZWJpY29uc1wiLFwiY3VzdG9tTGlicmFyaWVzXCI6W1wiTC5zY3JhdGNocGFkXCJdLFwicGx1Z2luc1wiOltdLFwicmVjZW50Q29sb3JzXCI6W1wiRkYwMDAwXCIsXCIwMENDNjZcIixcIm5vbmVcIixcIkNDRTVGRlwiLFwiNTI1MjUyXCIsXCJGRjMzMzNcIixcIjMzMzMzM1wiLFwiMzMwMDAwXCIsXCIwMENDQ0NcIixcIkZGNjZCM1wiLFwiRkZGRkZGMDBcIl0sXCJmb3JtYXRXaWR0aFwiOjI0MCxcImNyZWF0ZVRhcmdldFwiOmZhbHNlLFwicGFnZUZvcm1hdFwiOntcInhcIjowLFwieVwiOjAsXCJ3aWR0aFwiOjExNjksXCJoZWlnaHRcIjoxNjU0fSxcInNlYXJjaFwiOnRydWUsXCJzaG93U3RhcnRTY3JlZW5cIjp0cnVlLFwiZ3JpZENvbG9yXCI6XCIjZDBkMGQwXCIsXCJkYXJrR3JpZENvbG9yXCI6XCIjNmU2ZTZlXCIsXCJhdXRvc2F2ZVwiOnRydWUsXCJyZXNpemVJbWFnZXNcIjpudWxsLFwib3BlbkNvdW50ZXJcIjowLFwidmVyc2lvblwiOjE4LFwidW5pdFwiOjEsXCJpc1J1bGVyT25cIjpmYWxzZSxcInVpXCI6XCJcIn0ifQ==&quot;,  &quot;hediet.vscode-drawio.theme&quot;: &quot;Kennedy&quot;,  &quot;editor.fontFamily&quot;: &quot;Source Code Pro, &#x27;Courier New&#x27;, monospace&quot;,  &quot;editor.smoothScrolling&quot;: true,  &quot;editor.formatOnSave&quot;: true,  &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,  &quot;workbench.colorTheme&quot;: &quot;Atom One Dark&quot;,  &quot;vetur.completion.autoImport&quot;: false,  &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;,  &quot;eslint.lintTask.enable&quot;: true,  &quot;eslint.alwaysShowStatus&quot;: true,  &quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll.eslint&quot;: true  &#125;&#125;\n\n\n\n三. 接口文档https://documenter.getpostman.com/view/12387168/TzsfmQvw\nbaseURL的值：\nhttp://152.136.185.210:5000\n\n设置全局token的方法：\nconst res = pm.response.json();pm.globals.set(&quot;token&quot;, res.data.token);\n\n\n\n接口文档v2版本：（有部分更新）\nhttps://documenter.getpostman.com/view/12387168/TzzDKb12\n","categories":["项目"]}]